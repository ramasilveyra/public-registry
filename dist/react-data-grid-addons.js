(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"), require("react-dom"));
	else if(typeof define === 'function' && define.amd)
		define(["react", "react-dom"], factory);
	else if(typeof exports === 'object')
		exports["ReactDataGrid"] = factory(require("react"), require("react-dom"));
	else
		root["ReactDataGrid"] = factory(root["React"], root["ReactDOM"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_6__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ((function(modules) {
	// Check all modules for deduplicated modules
	for(var i in modules) {
		if(Object.prototype.hasOwnProperty.call(modules, i)) {
			switch(typeof modules[i]) {
			case "function": break;
			case "object":
				// Module can be created from a template
				modules[i] = (function(_m) {
					var args = _m.slice(1), fn = modules[_m[0]];
					return function (a,b,c) {
						fn.apply(this, [a,b,c].concat(args));
					};
				}(modules[i]));
				break;
			default:
				// Module is a copy of another module
				modules[i] = modules[modules[i]];
				break;
			}
		}
	}
	return modules;
}([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(201);


/***/ }),
/* 1 */
/***/ (function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ }),
/* 2 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_2__;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	if (false) {
	  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
	    Symbol.for &&
	    Symbol.for('react.element')) ||
	    0xeac7;

	  var isValidElement = function(object) {
	    return typeof object === 'object' &&
	      object !== null &&
	      object.$$typeof === REACT_ELEMENT_TYPE;
	  };

	  // By explicitly using `prop-types` you are opting into new development behavior.
	  // http://fb.me/prop-types-in-prod
	  var throwOnDirectAccess = true;
	  module.exports = require('./factoryWithTypeCheckers')(isValidElement, throwOnDirectAccess);
	} else {
	  // By explicitly using `prop-types` you are opting into new production behavior.
	  // http://fb.me/prop-types-in-prod
	  module.exports = __webpack_require__(91)();
	}


/***/ }),
/* 4 */,
/* 5 */,
/* 6 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_6__;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(465);

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */

	'use strict';

	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */

	var invariant = function(condition, format, a, b, c, d, e, f) {
	  if (false) {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }

	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error(
	        'Minified exception occurred; use the non-minified dev environment ' +
	        'for the full error message and additional helpful warnings.'
	      );
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(
	        format.replace(/%s/g, function() { return args[argIndex++]; })
	      );
	      error.name = 'Invariant Violation';
	    }

	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};

	module.exports = invariant;


/***/ }),
/* 9 */,
/* 10 */,
/* 11 */
[1758, 157],
/* 12 */
/***/ (function(module, exports) {

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	module.exports = isArray;


/***/ }),
/* 13 */,
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _DragDropContext = __webpack_require__(139);

	Object.defineProperty(exports, 'DragDropContext', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_DragDropContext).default;
	  }
	});

	var _DragDropContextProvider = __webpack_require__(351);

	Object.defineProperty(exports, 'DragDropContextProvider', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_DragDropContextProvider).default;
	  }
	});

	var _DragLayer = __webpack_require__(352);

	Object.defineProperty(exports, 'DragLayer', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_DragLayer).default;
	  }
	});

	var _DragSource = __webpack_require__(353);

	Object.defineProperty(exports, 'DragSource', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_DragSource).default;
	  }
	});

	var _DropTarget = __webpack_require__(354);

	Object.defineProperty(exports, 'DropTarget', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_DropTarget).default;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */
12,
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(40),
	    getPrototype = __webpack_require__(296),
	    isObjectLike = __webpack_require__(29);

	/** `Object#toString` result references. */
	var objectTag = '[object Object]';

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);

	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	    funcToString.call(Ctor) == objectCtorString;
	}

	module.exports = isPlainObject;


/***/ }),
/* 20 */
[1665, 397, 421],
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 *  Copyright (c) 2014-2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */

	(function (global, factory) {
	   true ? module.exports = factory() :
	  typeof define === 'function' && define.amd ? define(factory) :
	  (global.Immutable = factory());
	}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;

	  function createClass(ctor, superClass) {
	    if (superClass) {
	      ctor.prototype = Object.create(superClass.prototype);
	    }
	    ctor.prototype.constructor = ctor;
	  }

	  function Iterable(value) {
	      return isIterable(value) ? value : Seq(value);
	    }


	  createClass(KeyedIterable, Iterable);
	    function KeyedIterable(value) {
	      return isKeyed(value) ? value : KeyedSeq(value);
	    }


	  createClass(IndexedIterable, Iterable);
	    function IndexedIterable(value) {
	      return isIndexed(value) ? value : IndexedSeq(value);
	    }


	  createClass(SetIterable, Iterable);
	    function SetIterable(value) {
	      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
	    }



	  function isIterable(maybeIterable) {
	    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
	  }

	  function isKeyed(maybeKeyed) {
	    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
	  }

	  function isIndexed(maybeIndexed) {
	    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
	  }

	  function isAssociative(maybeAssociative) {
	    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
	  }

	  function isOrdered(maybeOrdered) {
	    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
	  }

	  Iterable.isIterable = isIterable;
	  Iterable.isKeyed = isKeyed;
	  Iterable.isIndexed = isIndexed;
	  Iterable.isAssociative = isAssociative;
	  Iterable.isOrdered = isOrdered;

	  Iterable.Keyed = KeyedIterable;
	  Iterable.Indexed = IndexedIterable;
	  Iterable.Set = SetIterable;


	  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

	  // Used for setting prototype methods that IE8 chokes on.
	  var DELETE = 'delete';

	  // Constants describing the size of trie nodes.
	  var SHIFT = 5; // Resulted in best performance after ______?
	  var SIZE = 1 << SHIFT;
	  var MASK = SIZE - 1;

	  // A consistent shared value representing "not set" which equals nothing other
	  // than itself, and nothing that could be provided externally.
	  var NOT_SET = {};

	  // Boolean references, Rough equivalent of `bool &`.
	  var CHANGE_LENGTH = { value: false };
	  var DID_ALTER = { value: false };

	  function MakeRef(ref) {
	    ref.value = false;
	    return ref;
	  }

	  function SetRef(ref) {
	    ref && (ref.value = true);
	  }

	  // A function which returns a value representing an "owner" for transient writes
	  // to tries. The return value will only ever equal itself, and will not equal
	  // the return of any subsequent call of this function.
	  function OwnerID() {}

	  // http://jsperf.com/copy-array-inline
	  function arrCopy(arr, offset) {
	    offset = offset || 0;
	    var len = Math.max(0, arr.length - offset);
	    var newArr = new Array(len);
	    for (var ii = 0; ii < len; ii++) {
	      newArr[ii] = arr[ii + offset];
	    }
	    return newArr;
	  }

	  function ensureSize(iter) {
	    if (iter.size === undefined) {
	      iter.size = iter.__iterate(returnTrue);
	    }
	    return iter.size;
	  }

	  function wrapIndex(iter, index) {
	    // This implements "is array index" which the ECMAString spec defines as:
	    //
	    //     A String property name P is an array index if and only if
	    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
	    //     to 2^32âˆ’1.
	    //
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
	    if (typeof index !== 'number') {
	      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
	      if ('' + uint32Index !== index || uint32Index === 4294967295) {
	        return NaN;
	      }
	      index = uint32Index;
	    }
	    return index < 0 ? ensureSize(iter) + index : index;
	  }

	  function returnTrue() {
	    return true;
	  }

	  function wholeSlice(begin, end, size) {
	    return (begin === 0 || (size !== undefined && begin <= -size)) &&
	      (end === undefined || (size !== undefined && end >= size));
	  }

	  function resolveBegin(begin, size) {
	    return resolveIndex(begin, size, 0);
	  }

	  function resolveEnd(end, size) {
	    return resolveIndex(end, size, size);
	  }

	  function resolveIndex(index, size, defaultIndex) {
	    return index === undefined ?
	      defaultIndex :
	      index < 0 ?
	        Math.max(0, size + index) :
	        size === undefined ?
	          index :
	          Math.min(size, index);
	  }

	  /* global Symbol */

	  var ITERATE_KEYS = 0;
	  var ITERATE_VALUES = 1;
	  var ITERATE_ENTRIES = 2;

	  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator';

	  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;


	  function Iterator(next) {
	      this.next = next;
	    }

	    Iterator.prototype.toString = function() {
	      return '[Iterator]';
	    };


	  Iterator.KEYS = ITERATE_KEYS;
	  Iterator.VALUES = ITERATE_VALUES;
	  Iterator.ENTRIES = ITERATE_ENTRIES;

	  Iterator.prototype.inspect =
	  Iterator.prototype.toSource = function () { return this.toString(); }
	  Iterator.prototype[ITERATOR_SYMBOL] = function () {
	    return this;
	  };


	  function iteratorValue(type, k, v, iteratorResult) {
	    var value = type === 0 ? k : type === 1 ? v : [k, v];
	    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {
	      value: value, done: false
	    });
	    return iteratorResult;
	  }

	  function iteratorDone() {
	    return { value: undefined, done: true };
	  }

	  function hasIterator(maybeIterable) {
	    return !!getIteratorFn(maybeIterable);
	  }

	  function isIterator(maybeIterator) {
	    return maybeIterator && typeof maybeIterator.next === 'function';
	  }

	  function getIterator(iterable) {
	    var iteratorFn = getIteratorFn(iterable);
	    return iteratorFn && iteratorFn.call(iterable);
	  }

	  function getIteratorFn(iterable) {
	    var iteratorFn = iterable && (
	      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
	      iterable[FAUX_ITERATOR_SYMBOL]
	    );
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }

	  function isArrayLike(value) {
	    return value && typeof value.length === 'number';
	  }

	  createClass(Seq, Iterable);
	    function Seq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        isIterable(value) ? value.toSeq() : seqFromValue(value);
	    }

	    Seq.of = function(/*...values*/) {
	      return Seq(arguments);
	    };

	    Seq.prototype.toSeq = function() {
	      return this;
	    };

	    Seq.prototype.toString = function() {
	      return this.__toString('Seq {', '}');
	    };

	    Seq.prototype.cacheResult = function() {
	      if (!this._cache && this.__iterateUncached) {
	        this._cache = this.entrySeq().toArray();
	        this.size = this._cache.length;
	      }
	      return this;
	    };

	    // abstract __iterateUncached(fn, reverse)

	    Seq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, true);
	    };

	    // abstract __iteratorUncached(type, reverse)

	    Seq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, true);
	    };



	  createClass(KeyedSeq, Seq);
	    function KeyedSeq(value) {
	      return value === null || value === undefined ?
	        emptySequence().toKeyedSeq() :
	        isIterable(value) ?
	          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :
	          keyedSeqFromValue(value);
	    }

	    KeyedSeq.prototype.toKeyedSeq = function() {
	      return this;
	    };



	  createClass(IndexedSeq, Seq);
	    function IndexedSeq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
	    }

	    IndexedSeq.of = function(/*...values*/) {
	      return IndexedSeq(arguments);
	    };

	    IndexedSeq.prototype.toIndexedSeq = function() {
	      return this;
	    };

	    IndexedSeq.prototype.toString = function() {
	      return this.__toString('Seq [', ']');
	    };

	    IndexedSeq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, false);
	    };

	    IndexedSeq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, false);
	    };



	  createClass(SetSeq, Seq);
	    function SetSeq(value) {
	      return (
	        value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value
	      ).toSetSeq();
	    }

	    SetSeq.of = function(/*...values*/) {
	      return SetSeq(arguments);
	    };

	    SetSeq.prototype.toSetSeq = function() {
	      return this;
	    };



	  Seq.isSeq = isSeq;
	  Seq.Keyed = KeyedSeq;
	  Seq.Set = SetSeq;
	  Seq.Indexed = IndexedSeq;

	  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';

	  Seq.prototype[IS_SEQ_SENTINEL] = true;



	  createClass(ArraySeq, IndexedSeq);
	    function ArraySeq(array) {
	      this._array = array;
	      this.size = array.length;
	    }

	    ArraySeq.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
	    };

	    ArraySeq.prototype.__iterate = function(fn, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    ArraySeq.prototype.__iterator = function(type, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      var ii = 0;
	      return new Iterator(function() 
	        {return ii > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}
	      );
	    };



	  createClass(ObjectSeq, KeyedSeq);
	    function ObjectSeq(object) {
	      var keys = Object.keys(object);
	      this._object = object;
	      this._keys = keys;
	      this.size = keys.length;
	    }

	    ObjectSeq.prototype.get = function(key, notSetValue) {
	      if (notSetValue !== undefined && !this.has(key)) {
	        return notSetValue;
	      }
	      return this._object[key];
	    };

	    ObjectSeq.prototype.has = function(key) {
	      return this._object.hasOwnProperty(key);
	    };

	    ObjectSeq.prototype.__iterate = function(fn, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        if (fn(object[key], key, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    ObjectSeq.prototype.__iterator = function(type, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      var ii = 0;
	      return new Iterator(function()  {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, key, object[key]);
	      });
	    };

	  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;


	  createClass(IterableSeq, IndexedSeq);
	    function IterableSeq(iterable) {
	      this._iterable = iterable;
	      this.size = iterable.length || iterable.size;
	    }

	    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      var iterations = 0;
	      if (isIterator(iterator)) {
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (fn(step.value, iterations++, this) === false) {
	            break;
	          }
	        }
	      }
	      return iterations;
	    };

	    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      if (!isIterator(iterator)) {
	        return new Iterator(iteratorDone);
	      }
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step : iteratorValue(type, iterations++, step.value);
	      });
	    };



	  createClass(IteratorSeq, IndexedSeq);
	    function IteratorSeq(iterator) {
	      this._iterator = iterator;
	      this._iteratorCache = [];
	    }

	    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      while (iterations < cache.length) {
	        if (fn(cache[iterations], iterations++, this) === false) {
	          return iterations;
	        }
	      }
	      var step;
	      while (!(step = iterator.next()).done) {
	        var val = step.value;
	        cache[iterations] = val;
	        if (fn(val, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };

	    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      return new Iterator(function()  {
	        if (iterations >= cache.length) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          cache[iterations] = step.value;
	        }
	        return iteratorValue(type, iterations, cache[iterations++]);
	      });
	    };




	  // # pragma Helper functions

	  function isSeq(maybeSeq) {
	    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
	  }

	  var EMPTY_SEQ;

	  function emptySequence() {
	    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
	  }

	  function keyedSeqFromValue(value) {
	    var seq =
	      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :
	      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :
	      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :
	      typeof value === 'object' ? new ObjectSeq(value) :
	      undefined;
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of [k, v] entries, '+
	        'or keyed object: ' + value
	      );
	    }
	    return seq;
	  }

	  function indexedSeqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value);
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values: ' + value
	      );
	    }
	    return seq;
	  }

	  function seqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value) ||
	      (typeof value === 'object' && new ObjectSeq(value));
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values, or keyed object: ' + value
	      );
	    }
	    return seq;
	  }

	  function maybeIndexedSeqFromValue(value) {
	    return (
	      isArrayLike(value) ? new ArraySeq(value) :
	      isIterator(value) ? new IteratorSeq(value) :
	      hasIterator(value) ? new IterableSeq(value) :
	      undefined
	    );
	  }

	  function seqIterate(seq, fn, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    }
	    return seq.__iterateUncached(fn, reverse);
	  }

	  function seqIterator(seq, type, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      var ii = 0;
	      return new Iterator(function()  {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
	      });
	    }
	    return seq.__iteratorUncached(type, reverse);
	  }

	  function fromJS(json, converter) {
	    return converter ?
	      fromJSWith(converter, json, '', {'': json}) :
	      fromJSDefault(json);
	  }

	  function fromJSWith(converter, json, key, parentJSON) {
	    if (Array.isArray(json)) {
	      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    if (isPlainObj(json)) {
	      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    return json;
	  }

	  function fromJSDefault(json) {
	    if (Array.isArray(json)) {
	      return IndexedSeq(json).map(fromJSDefault).toList();
	    }
	    if (isPlainObj(json)) {
	      return KeyedSeq(json).map(fromJSDefault).toMap();
	    }
	    return json;
	  }

	  function isPlainObj(value) {
	    return value && (value.constructor === Object || value.constructor === undefined);
	  }

	  /**
	   * An extension of the "same-value" algorithm as [described for use by ES6 Map
	   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
	   *
	   * NaN is considered the same as NaN, however -0 and 0 are considered the same
	   * value, which is different from the algorithm described by
	   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
	   *
	   * This is extended further to allow Objects to describe the values they
	   * represent, by way of `valueOf` or `equals` (and `hashCode`).
	   *
	   * Note: because of this extension, the key equality of Immutable.Map and the
	   * value equality of Immutable.Set will differ from ES6 Map and Set.
	   *
	   * ### Defining custom values
	   *
	   * The easiest way to describe the value an object represents is by implementing
	   * `valueOf`. For example, `Date` represents a value by returning a unix
	   * timestamp for `valueOf`:
	   *
	   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
	   *     var date2 = new Date(1234567890000);
	   *     date1.valueOf(); // 1234567890000
	   *     assert( date1 !== date2 );
	   *     assert( Immutable.is( date1, date2 ) );
	   *
	   * Note: overriding `valueOf` may have other implications if you use this object
	   * where JavaScript expects a primitive, such as implicit string coercion.
	   *
	   * For more complex types, especially collections, implementing `valueOf` may
	   * not be performant. An alternative is to implement `equals` and `hashCode`.
	   *
	   * `equals` takes another object, presumably of similar type, and returns true
	   * if the it is equal. Equality is symmetrical, so the same result should be
	   * returned if this and the argument are flipped.
	   *
	   *     assert( a.equals(b) === b.equals(a) );
	   *
	   * `hashCode` returns a 32bit integer number representing the object which will
	   * be used to determine how to store the value object in a Map or Set. You must
	   * provide both or neither methods, one must not exist without the other.
	   *
	   * Also, an important relationship between these methods must be upheld: if two
	   * values are equal, they *must* return the same hashCode. If the values are not
	   * equal, they might have the same hashCode; this is called a hash collision,
	   * and while undesirable for performance reasons, it is acceptable.
	   *
	   *     if (a.equals(b)) {
	   *       assert( a.hashCode() === b.hashCode() );
	   *     }
	   *
	   * All Immutable collections implement `equals` and `hashCode`.
	   *
	   */
	  function is(valueA, valueB) {
	    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	      return true;
	    }
	    if (!valueA || !valueB) {
	      return false;
	    }
	    if (typeof valueA.valueOf === 'function' &&
	        typeof valueB.valueOf === 'function') {
	      valueA = valueA.valueOf();
	      valueB = valueB.valueOf();
	      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	        return true;
	      }
	      if (!valueA || !valueB) {
	        return false;
	      }
	    }
	    if (typeof valueA.equals === 'function' &&
	        typeof valueB.equals === 'function' &&
	        valueA.equals(valueB)) {
	      return true;
	    }
	    return false;
	  }

	  function deepEqual(a, b) {
	    if (a === b) {
	      return true;
	    }

	    if (
	      !isIterable(b) ||
	      a.size !== undefined && b.size !== undefined && a.size !== b.size ||
	      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||
	      isKeyed(a) !== isKeyed(b) ||
	      isIndexed(a) !== isIndexed(b) ||
	      isOrdered(a) !== isOrdered(b)
	    ) {
	      return false;
	    }

	    if (a.size === 0 && b.size === 0) {
	      return true;
	    }

	    var notAssociative = !isAssociative(a);

	    if (isOrdered(a)) {
	      var entries = a.entries();
	      return b.every(function(v, k)  {
	        var entry = entries.next().value;
	        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
	      }) && entries.next().done;
	    }

	    var flipped = false;

	    if (a.size === undefined) {
	      if (b.size === undefined) {
	        if (typeof a.cacheResult === 'function') {
	          a.cacheResult();
	        }
	      } else {
	        flipped = true;
	        var _ = a;
	        a = b;
	        b = _;
	      }
	    }

	    var allEqual = true;
	    var bSize = b.__iterate(function(v, k)  {
	      if (notAssociative ? !a.has(v) :
	          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
	        allEqual = false;
	        return false;
	      }
	    });

	    return allEqual && a.size === bSize;
	  }

	  createClass(Repeat, IndexedSeq);

	    function Repeat(value, times) {
	      if (!(this instanceof Repeat)) {
	        return new Repeat(value, times);
	      }
	      this._value = value;
	      this.size = times === undefined ? Infinity : Math.max(0, times);
	      if (this.size === 0) {
	        if (EMPTY_REPEAT) {
	          return EMPTY_REPEAT;
	        }
	        EMPTY_REPEAT = this;
	      }
	    }

	    Repeat.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Repeat []';
	      }
	      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
	    };

	    Repeat.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._value : notSetValue;
	    };

	    Repeat.prototype.includes = function(searchValue) {
	      return is(this._value, searchValue);
	    };

	    Repeat.prototype.slice = function(begin, end) {
	      var size = this.size;
	      return wholeSlice(begin, end, size) ? this :
	        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
	    };

	    Repeat.prototype.reverse = function() {
	      return this;
	    };

	    Repeat.prototype.indexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return 0;
	      }
	      return -1;
	    };

	    Repeat.prototype.lastIndexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return this.size;
	      }
	      return -1;
	    };

	    Repeat.prototype.__iterate = function(fn, reverse) {
	      for (var ii = 0; ii < this.size; ii++) {
	        if (fn(this._value, ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      var ii = 0;
	      return new Iterator(function() 
	        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}
	      );
	    };

	    Repeat.prototype.equals = function(other) {
	      return other instanceof Repeat ?
	        is(this._value, other._value) :
	        deepEqual(other);
	    };


	  var EMPTY_REPEAT;

	  function invariant(condition, error) {
	    if (!condition) throw new Error(error);
	  }

	  createClass(Range, IndexedSeq);

	    function Range(start, end, step) {
	      if (!(this instanceof Range)) {
	        return new Range(start, end, step);
	      }
	      invariant(step !== 0, 'Cannot step a Range by 0');
	      start = start || 0;
	      if (end === undefined) {
	        end = Infinity;
	      }
	      step = step === undefined ? 1 : Math.abs(step);
	      if (end < start) {
	        step = -step;
	      }
	      this._start = start;
	      this._end = end;
	      this._step = step;
	      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
	      if (this.size === 0) {
	        if (EMPTY_RANGE) {
	          return EMPTY_RANGE;
	        }
	        EMPTY_RANGE = this;
	      }
	    }

	    Range.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Range []';
	      }
	      return 'Range [ ' +
	        this._start + '...' + this._end +
	        (this._step !== 1 ? ' by ' + this._step : '') +
	      ' ]';
	    };

	    Range.prototype.get = function(index, notSetValue) {
	      return this.has(index) ?
	        this._start + wrapIndex(this, index) * this._step :
	        notSetValue;
	    };

	    Range.prototype.includes = function(searchValue) {
	      var possibleIndex = (searchValue - this._start) / this._step;
	      return possibleIndex >= 0 &&
	        possibleIndex < this.size &&
	        possibleIndex === Math.floor(possibleIndex);
	    };

	    Range.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      begin = resolveBegin(begin, this.size);
	      end = resolveEnd(end, this.size);
	      if (end <= begin) {
	        return new Range(0, 0);
	      }
	      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
	    };

	    Range.prototype.indexOf = function(searchValue) {
	      var offsetValue = searchValue - this._start;
	      if (offsetValue % this._step === 0) {
	        var index = offsetValue / this._step;
	        if (index >= 0 && index < this.size) {
	          return index
	        }
	      }
	      return -1;
	    };

	    Range.prototype.lastIndexOf = function(searchValue) {
	      return this.indexOf(searchValue);
	    };

	    Range.prototype.__iterate = function(fn, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(value, ii, this) === false) {
	          return ii + 1;
	        }
	        value += reverse ? -step : step;
	      }
	      return ii;
	    };

	    Range.prototype.__iterator = function(type, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      var ii = 0;
	      return new Iterator(function()  {
	        var v = value;
	        value += reverse ? -step : step;
	        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
	      });
	    };

	    Range.prototype.equals = function(other) {
	      return other instanceof Range ?
	        this._start === other._start &&
	        this._end === other._end &&
	        this._step === other._step :
	        deepEqual(this, other);
	    };


	  var EMPTY_RANGE;

	  createClass(Collection, Iterable);
	    function Collection() {
	      throw TypeError('Abstract');
	    }


	  createClass(KeyedCollection, Collection);function KeyedCollection() {}

	  createClass(IndexedCollection, Collection);function IndexedCollection() {}

	  createClass(SetCollection, Collection);function SetCollection() {}


	  Collection.Keyed = KeyedCollection;
	  Collection.Indexed = IndexedCollection;
	  Collection.Set = SetCollection;

	  var imul =
	    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?
	    Math.imul :
	    function imul(a, b) {
	      a = a | 0; // int
	      b = b | 0; // int
	      var c = a & 0xffff;
	      var d = b & 0xffff;
	      // Shift by 0 fixes the sign on the high part.
	      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int
	    };

	  // v8 has an optimization for storing 31-bit signed numbers.
	  // Values which have either 00 or 11 as the high order bits qualify.
	  // This function drops the highest order bit in a signed number, maintaining
	  // the sign bit.
	  function smi(i32) {
	    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);
	  }

	  function hash(o) {
	    if (o === false || o === null || o === undefined) {
	      return 0;
	    }
	    if (typeof o.valueOf === 'function') {
	      o = o.valueOf();
	      if (o === false || o === null || o === undefined) {
	        return 0;
	      }
	    }
	    if (o === true) {
	      return 1;
	    }
	    var type = typeof o;
	    if (type === 'number') {
	      if (o !== o || o === Infinity) {
	        return 0;
	      }
	      var h = o | 0;
	      if (h !== o) {
	        h ^= o * 0xFFFFFFFF;
	      }
	      while (o > 0xFFFFFFFF) {
	        o /= 0xFFFFFFFF;
	        h ^= o;
	      }
	      return smi(h);
	    }
	    if (type === 'string') {
	      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
	    }
	    if (typeof o.hashCode === 'function') {
	      return o.hashCode();
	    }
	    if (type === 'object') {
	      return hashJSObj(o);
	    }
	    if (typeof o.toString === 'function') {
	      return hashString(o.toString());
	    }
	    throw new Error('Value type ' + type + ' cannot be hashed.');
	  }

	  function cachedHashString(string) {
	    var hash = stringHashCache[string];
	    if (hash === undefined) {
	      hash = hashString(string);
	      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
	        STRING_HASH_CACHE_SIZE = 0;
	        stringHashCache = {};
	      }
	      STRING_HASH_CACHE_SIZE++;
	      stringHashCache[string] = hash;
	    }
	    return hash;
	  }

	  // http://jsperf.com/hashing-strings
	  function hashString(string) {
	    // This is the hash from JVM
	    // The hash code for a string is computed as
	    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
	    // where s[i] is the ith character of the string and n is the length of
	    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
	    // (exclusive) by dropping high bits.
	    var hash = 0;
	    for (var ii = 0; ii < string.length; ii++) {
	      hash = 31 * hash + string.charCodeAt(ii) | 0;
	    }
	    return smi(hash);
	  }

	  function hashJSObj(obj) {
	    var hash;
	    if (usingWeakMap) {
	      hash = weakMap.get(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }

	    hash = obj[UID_HASH_KEY];
	    if (hash !== undefined) {
	      return hash;
	    }

	    if (!canDefineProperty) {
	      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
	      if (hash !== undefined) {
	        return hash;
	      }

	      hash = getIENodeHash(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }

	    hash = ++objHashUID;
	    if (objHashUID & 0x40000000) {
	      objHashUID = 0;
	    }

	    if (usingWeakMap) {
	      weakMap.set(obj, hash);
	    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
	      throw new Error('Non-extensible objects are not allowed as keys.');
	    } else if (canDefineProperty) {
	      Object.defineProperty(obj, UID_HASH_KEY, {
	        'enumerable': false,
	        'configurable': false,
	        'writable': false,
	        'value': hash
	      });
	    } else if (obj.propertyIsEnumerable !== undefined &&
	               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
	      // Since we can't define a non-enumerable property on the object
	      // we'll hijack one of the less-used non-enumerable properties to
	      // save our hash on it. Since this is a function it will not show up in
	      // `JSON.stringify` which is what we want.
	      obj.propertyIsEnumerable = function() {
	        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
	      };
	      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
	    } else if (obj.nodeType !== undefined) {
	      // At this point we couldn't get the IE `uniqueID` to use as a hash
	      // and we couldn't use a non-enumerable property to exploit the
	      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
	      // itself.
	      obj[UID_HASH_KEY] = hash;
	    } else {
	      throw new Error('Unable to set a non-enumerable property on object.');
	    }

	    return hash;
	  }

	  // Get references to ES5 object methods.
	  var isExtensible = Object.isExtensible;

	  // True if Object.defineProperty works as expected. IE8 fails this test.
	  var canDefineProperty = (function() {
	    try {
	      Object.defineProperty({}, '@', {});
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }());

	  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
	  // and avoid memory leaks from the IE cloneNode bug.
	  function getIENodeHash(node) {
	    if (node && node.nodeType > 0) {
	      switch (node.nodeType) {
	        case 1: // Element
	          return node.uniqueID;
	        case 9: // Document
	          return node.documentElement && node.documentElement.uniqueID;
	      }
	    }
	  }

	  // If possible, use a WeakMap.
	  var usingWeakMap = typeof WeakMap === 'function';
	  var weakMap;
	  if (usingWeakMap) {
	    weakMap = new WeakMap();
	  }

	  var objHashUID = 0;

	  var UID_HASH_KEY = '__immutablehash__';
	  if (typeof Symbol === 'function') {
	    UID_HASH_KEY = Symbol(UID_HASH_KEY);
	  }

	  var STRING_HASH_CACHE_MIN_STRLEN = 16;
	  var STRING_HASH_CACHE_MAX_SIZE = 255;
	  var STRING_HASH_CACHE_SIZE = 0;
	  var stringHashCache = {};

	  function assertNotInfinite(size) {
	    invariant(
	      size !== Infinity,
	      'Cannot perform this action with an infinite size.'
	    );
	  }

	  createClass(Map, KeyedCollection);

	    // @pragma Construction

	    function Map(value) {
	      return value === null || value === undefined ? emptyMap() :
	        isMap(value) && !isOrdered(value) ? value :
	        emptyMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }

	    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);
	      return emptyMap().withMutations(function(map ) {
	        for (var i = 0; i < keyValues.length; i += 2) {
	          if (i + 1 >= keyValues.length) {
	            throw new Error('Missing value for key: ' + keyValues[i]);
	          }
	          map.set(keyValues[i], keyValues[i + 1]);
	        }
	      });
	    };

	    Map.prototype.toString = function() {
	      return this.__toString('Map {', '}');
	    };

	    // @pragma Access

	    Map.prototype.get = function(k, notSetValue) {
	      return this._root ?
	        this._root.get(0, undefined, k, notSetValue) :
	        notSetValue;
	    };

	    // @pragma Modification

	    Map.prototype.set = function(k, v) {
	      return updateMap(this, k, v);
	    };

	    Map.prototype.setIn = function(keyPath, v) {
	      return this.updateIn(keyPath, NOT_SET, function()  {return v});
	    };

	    Map.prototype.remove = function(k) {
	      return updateMap(this, k, NOT_SET);
	    };

	    Map.prototype.deleteIn = function(keyPath) {
	      return this.updateIn(keyPath, function()  {return NOT_SET});
	    };

	    Map.prototype.update = function(k, notSetValue, updater) {
	      return arguments.length === 1 ?
	        k(this) :
	        this.updateIn([k], notSetValue, updater);
	    };

	    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {
	      if (!updater) {
	        updater = notSetValue;
	        notSetValue = undefined;
	      }
	      var updatedValue = updateInDeepMap(
	        this,
	        forceIterator(keyPath),
	        notSetValue,
	        updater
	      );
	      return updatedValue === NOT_SET ? undefined : updatedValue;
	    };

	    Map.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._root = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyMap();
	    };

	    // @pragma Composition

	    Map.prototype.merge = function(/*...iters*/) {
	      return mergeIntoMapWith(this, undefined, arguments);
	    };

	    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, merger, iters);
	    };

	    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.merge === 'function' ?
	          m.merge.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };

	    Map.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoMapWith(this, deepMerger, arguments);
	    };

	    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, deepMergerWith(merger), iters);
	    };

	    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.mergeDeep === 'function' ?
	          m.mergeDeep.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };

	    Map.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator));
	    };

	    Map.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator, mapper));
	    };

	    // @pragma Mutability

	    Map.prototype.withMutations = function(fn) {
	      var mutable = this.asMutable();
	      fn(mutable);
	      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
	    };

	    Map.prototype.asMutable = function() {
	      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
	    };

	    Map.prototype.asImmutable = function() {
	      return this.__ensureOwner();
	    };

	    Map.prototype.wasAltered = function() {
	      return this.__altered;
	    };

	    Map.prototype.__iterator = function(type, reverse) {
	      return new MapIterator(this, type, reverse);
	    };

	    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      this._root && this._root.iterate(function(entry ) {
	        iterations++;
	        return fn(entry[1], entry[0], this$0);
	      }, reverse);
	      return iterations;
	    };

	    Map.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeMap(this.size, this._root, ownerID, this.__hash);
	    };


	  function isMap(maybeMap) {
	    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
	  }

	  Map.isMap = isMap;

	  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';

	  var MapPrototype = Map.prototype;
	  MapPrototype[IS_MAP_SENTINEL] = true;
	  MapPrototype[DELETE] = MapPrototype.remove;
	  MapPrototype.removeIn = MapPrototype.deleteIn;


	  // #pragma Trie Nodes



	    function ArrayMapNode(ownerID, entries) {
	      this.ownerID = ownerID;
	      this.entries = entries;
	    }

	    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };

	    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;

	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;

	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }

	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);

	      if (removed && entries.length === 1) {
	        return; // undefined
	      }

	      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
	        return createNodes(ownerID, entries, key, value);
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);

	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }

	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }

	      return new ArrayMapNode(ownerID, newEntries);
	    };




	    function BitmapIndexedNode(ownerID, bitmap, nodes) {
	      this.ownerID = ownerID;
	      this.bitmap = bitmap;
	      this.nodes = nodes;
	    }

	    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));
	      var bitmap = this.bitmap;
	      return (bitmap & bit) === 0 ? notSetValue :
	        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);
	    };

	    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var bit = 1 << keyHashFrag;
	      var bitmap = this.bitmap;
	      var exists = (bitmap & bit) !== 0;

	      if (!exists && value === NOT_SET) {
	        return this;
	      }

	      var idx = popCount(bitmap & (bit - 1));
	      var nodes = this.nodes;
	      var node = exists ? nodes[idx] : undefined;
	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);

	      if (newNode === node) {
	        return this;
	      }

	      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
	        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
	      }

	      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
	        return nodes[idx ^ 1];
	      }

	      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
	        return newNode;
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
	      var newNodes = exists ? newNode ?
	        setIn(nodes, idx, newNode, isEditable) :
	        spliceOut(nodes, idx, isEditable) :
	        spliceIn(nodes, idx, newNode, isEditable);

	      if (isEditable) {
	        this.bitmap = newBitmap;
	        this.nodes = newNodes;
	        return this;
	      }

	      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
	    };




	    function HashArrayMapNode(ownerID, count, nodes) {
	      this.ownerID = ownerID;
	      this.count = count;
	      this.nodes = nodes;
	    }

	    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var node = this.nodes[idx];
	      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
	    };

	    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var removed = value === NOT_SET;
	      var nodes = this.nodes;
	      var node = nodes[idx];

	      if (removed && !node) {
	        return this;
	      }

	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
	      if (newNode === node) {
	        return this;
	      }

	      var newCount = this.count;
	      if (!node) {
	        newCount++;
	      } else if (!newNode) {
	        newCount--;
	        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
	          return packNodes(ownerID, nodes, newCount, idx);
	        }
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newNodes = setIn(nodes, idx, newNode, isEditable);

	      if (isEditable) {
	        this.count = newCount;
	        this.nodes = newNodes;
	        return this;
	      }

	      return new HashArrayMapNode(ownerID, newCount, newNodes);
	    };




	    function HashCollisionNode(ownerID, keyHash, entries) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entries = entries;
	    }

	    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };

	    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }

	      var removed = value === NOT_SET;

	      if (keyHash !== this.keyHash) {
	        if (removed) {
	          return this;
	        }
	        SetRef(didAlter);
	        SetRef(didChangeSize);
	        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
	      }

	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;

	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }

	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);

	      if (removed && len === 2) {
	        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);

	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }

	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }

	      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
	    };




	    function ValueNode(ownerID, keyHash, entry) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entry = entry;
	    }

	    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
	    };

	    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;
	      var keyMatch = is(key, this.entry[0]);
	      if (keyMatch ? value === this.entry[1] : removed) {
	        return this;
	      }

	      SetRef(didAlter);

	      if (removed) {
	        SetRef(didChangeSize);
	        return; // undefined
	      }

	      if (keyMatch) {
	        if (ownerID && ownerID === this.ownerID) {
	          this.entry[1] = value;
	          return this;
	        }
	        return new ValueNode(ownerID, this.keyHash, [key, value]);
	      }

	      SetRef(didChangeSize);
	      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
	    };



	  // #pragma Iterators

	  ArrayMapNode.prototype.iterate =
	  HashCollisionNode.prototype.iterate = function (fn, reverse) {
	    var entries = this.entries;
	    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
	      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
	        return false;
	      }
	    }
	  }

	  BitmapIndexedNode.prototype.iterate =
	  HashArrayMapNode.prototype.iterate = function (fn, reverse) {
	    var nodes = this.nodes;
	    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
	      var node = nodes[reverse ? maxIndex - ii : ii];
	      if (node && node.iterate(fn, reverse) === false) {
	        return false;
	      }
	    }
	  }

	  ValueNode.prototype.iterate = function (fn, reverse) {
	    return fn(this.entry);
	  }

	  createClass(MapIterator, Iterator);

	    function MapIterator(map, type, reverse) {
	      this._type = type;
	      this._reverse = reverse;
	      this._stack = map._root && mapIteratorFrame(map._root);
	    }

	    MapIterator.prototype.next = function() {
	      var type = this._type;
	      var stack = this._stack;
	      while (stack) {
	        var node = stack.node;
	        var index = stack.index++;
	        var maxIndex;
	        if (node.entry) {
	          if (index === 0) {
	            return mapIteratorValue(type, node.entry);
	          }
	        } else if (node.entries) {
	          maxIndex = node.entries.length - 1;
	          if (index <= maxIndex) {
	            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
	          }
	        } else {
	          maxIndex = node.nodes.length - 1;
	          if (index <= maxIndex) {
	            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
	            if (subNode) {
	              if (subNode.entry) {
	                return mapIteratorValue(type, subNode.entry);
	              }
	              stack = this._stack = mapIteratorFrame(subNode, stack);
	            }
	            continue;
	          }
	        }
	        stack = this._stack = this._stack.__prev;
	      }
	      return iteratorDone();
	    };


	  function mapIteratorValue(type, entry) {
	    return iteratorValue(type, entry[0], entry[1]);
	  }

	  function mapIteratorFrame(node, prev) {
	    return {
	      node: node,
	      index: 0,
	      __prev: prev
	    };
	  }

	  function makeMap(size, root, ownerID, hash) {
	    var map = Object.create(MapPrototype);
	    map.size = size;
	    map._root = root;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }

	  var EMPTY_MAP;
	  function emptyMap() {
	    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
	  }

	  function updateMap(map, k, v) {
	    var newRoot;
	    var newSize;
	    if (!map._root) {
	      if (v === NOT_SET) {
	        return map;
	      }
	      newSize = 1;
	      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
	    } else {
	      var didChangeSize = MakeRef(CHANGE_LENGTH);
	      var didAlter = MakeRef(DID_ALTER);
	      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
	      if (!didAlter.value) {
	        return map;
	      }
	      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
	    }
	    if (map.__ownerID) {
	      map.size = newSize;
	      map._root = newRoot;
	      map.__hash = undefined;
	      map.__altered = true;
	      return map;
	    }
	    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
	  }

	  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    if (!node) {
	      if (value === NOT_SET) {
	        return node;
	      }
	      SetRef(didAlter);
	      SetRef(didChangeSize);
	      return new ValueNode(ownerID, keyHash, [key, value]);
	    }
	    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
	  }

	  function isLeafNode(node) {
	    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
	  }

	  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
	    if (node.keyHash === keyHash) {
	      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
	    }

	    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
	    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;

	    var newNode;
	    var nodes = idx1 === idx2 ?
	      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :
	      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);

	    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
	  }

	  function createNodes(ownerID, entries, key, value) {
	    if (!ownerID) {
	      ownerID = new OwnerID();
	    }
	    var node = new ValueNode(ownerID, hash(key), [key, value]);
	    for (var ii = 0; ii < entries.length; ii++) {
	      var entry = entries[ii];
	      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
	    }
	    return node;
	  }

	  function packNodes(ownerID, nodes, count, excluding) {
	    var bitmap = 0;
	    var packedII = 0;
	    var packedNodes = new Array(count);
	    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
	      var node = nodes[ii];
	      if (node !== undefined && ii !== excluding) {
	        bitmap |= bit;
	        packedNodes[packedII++] = node;
	      }
	    }
	    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
	  }

	  function expandNodes(ownerID, nodes, bitmap, including, node) {
	    var count = 0;
	    var expandedNodes = new Array(SIZE);
	    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
	      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
	    }
	    expandedNodes[including] = node;
	    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
	  }

	  function mergeIntoMapWith(map, merger, iterables) {
	    var iters = [];
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = KeyedIterable(value);
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    return mergeIntoCollectionWith(map, merger, iters);
	  }

	  function deepMerger(existing, value, key) {
	    return existing && existing.mergeDeep && isIterable(value) ?
	      existing.mergeDeep(value) :
	      is(existing, value) ? existing : value;
	  }

	  function deepMergerWith(merger) {
	    return function(existing, value, key)  {
	      if (existing && existing.mergeDeepWith && isIterable(value)) {
	        return existing.mergeDeepWith(merger, value);
	      }
	      var nextValue = merger(existing, value, key);
	      return is(existing, nextValue) ? existing : nextValue;
	    };
	  }

	  function mergeIntoCollectionWith(collection, merger, iters) {
	    iters = iters.filter(function(x ) {return x.size !== 0});
	    if (iters.length === 0) {
	      return collection;
	    }
	    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
	      return collection.constructor(iters[0]);
	    }
	    return collection.withMutations(function(collection ) {
	      var mergeIntoMap = merger ?
	        function(value, key)  {
	          collection.update(key, NOT_SET, function(existing )
	            {return existing === NOT_SET ? value : merger(existing, value, key)}
	          );
	        } :
	        function(value, key)  {
	          collection.set(key, value);
	        }
	      for (var ii = 0; ii < iters.length; ii++) {
	        iters[ii].forEach(mergeIntoMap);
	      }
	    });
	  }

	  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
	    var isNotSet = existing === NOT_SET;
	    var step = keyPathIter.next();
	    if (step.done) {
	      var existingValue = isNotSet ? notSetValue : existing;
	      var newValue = updater(existingValue);
	      return newValue === existingValue ? existing : newValue;
	    }
	    invariant(
	      isNotSet || (existing && existing.set),
	      'invalid keyPath'
	    );
	    var key = step.value;
	    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
	    var nextUpdated = updateInDeepMap(
	      nextExisting,
	      keyPathIter,
	      notSetValue,
	      updater
	    );
	    return nextUpdated === nextExisting ? existing :
	      nextUpdated === NOT_SET ? existing.remove(key) :
	      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
	  }

	  function popCount(x) {
	    x = x - ((x >> 1) & 0x55555555);
	    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
	    x = (x + (x >> 4)) & 0x0f0f0f0f;
	    x = x + (x >> 8);
	    x = x + (x >> 16);
	    return x & 0x7f;
	  }

	  function setIn(array, idx, val, canEdit) {
	    var newArray = canEdit ? array : arrCopy(array);
	    newArray[idx] = val;
	    return newArray;
	  }

	  function spliceIn(array, idx, val, canEdit) {
	    var newLen = array.length + 1;
	    if (canEdit && idx + 1 === newLen) {
	      array[idx] = val;
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        newArray[ii] = val;
	        after = -1;
	      } else {
	        newArray[ii] = array[ii + after];
	      }
	    }
	    return newArray;
	  }

	  function spliceOut(array, idx, canEdit) {
	    var newLen = array.length - 1;
	    if (canEdit && idx === newLen) {
	      array.pop();
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        after = 1;
	      }
	      newArray[ii] = array[ii + after];
	    }
	    return newArray;
	  }

	  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
	  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
	  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;

	  createClass(List, IndexedCollection);

	    // @pragma Construction

	    function List(value) {
	      var empty = emptyList();
	      if (value === null || value === undefined) {
	        return empty;
	      }
	      if (isList(value)) {
	        return value;
	      }
	      var iter = IndexedIterable(value);
	      var size = iter.size;
	      if (size === 0) {
	        return empty;
	      }
	      assertNotInfinite(size);
	      if (size > 0 && size < SIZE) {
	        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
	      }
	      return empty.withMutations(function(list ) {
	        list.setSize(size);
	        iter.forEach(function(v, i)  {return list.set(i, v)});
	      });
	    }

	    List.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    List.prototype.toString = function() {
	      return this.__toString('List [', ']');
	    };

	    // @pragma Access

	    List.prototype.get = function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      if (index >= 0 && index < this.size) {
	        index += this._origin;
	        var node = listNodeFor(this, index);
	        return node && node.array[index & MASK];
	      }
	      return notSetValue;
	    };

	    // @pragma Modification

	    List.prototype.set = function(index, value) {
	      return updateList(this, index, value);
	    };

	    List.prototype.remove = function(index) {
	      return !this.has(index) ? this :
	        index === 0 ? this.shift() :
	        index === this.size - 1 ? this.pop() :
	        this.splice(index, 1);
	    };

	    List.prototype.insert = function(index, value) {
	      return this.splice(index, 0, value);
	    };

	    List.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = this._origin = this._capacity = 0;
	        this._level = SHIFT;
	        this._root = this._tail = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyList();
	    };

	    List.prototype.push = function(/*...values*/) {
	      var values = arguments;
	      var oldSize = this.size;
	      return this.withMutations(function(list ) {
	        setListBounds(list, 0, oldSize + values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(oldSize + ii, values[ii]);
	        }
	      });
	    };

	    List.prototype.pop = function() {
	      return setListBounds(this, 0, -1);
	    };

	    List.prototype.unshift = function(/*...values*/) {
	      var values = arguments;
	      return this.withMutations(function(list ) {
	        setListBounds(list, -values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(ii, values[ii]);
	        }
	      });
	    };

	    List.prototype.shift = function() {
	      return setListBounds(this, 1);
	    };

	    // @pragma Composition

	    List.prototype.merge = function(/*...iters*/) {
	      return mergeIntoListWith(this, undefined, arguments);
	    };

	    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, merger, iters);
	    };

	    List.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoListWith(this, deepMerger, arguments);
	    };

	    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, deepMergerWith(merger), iters);
	    };

	    List.prototype.setSize = function(size) {
	      return setListBounds(this, 0, size);
	    };

	    // @pragma Iteration

	    List.prototype.slice = function(begin, end) {
	      var size = this.size;
	      if (wholeSlice(begin, end, size)) {
	        return this;
	      }
	      return setListBounds(
	        this,
	        resolveBegin(begin, size),
	        resolveEnd(end, size)
	      );
	    };

	    List.prototype.__iterator = function(type, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      return new Iterator(function()  {
	        var value = values();
	        return value === DONE ?
	          iteratorDone() :
	          iteratorValue(type, index++, value);
	      });
	    };

	    List.prototype.__iterate = function(fn, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      var value;
	      while ((value = values()) !== DONE) {
	        if (fn(value, index++, this) === false) {
	          break;
	        }
	      }
	      return index;
	    };

	    List.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        return this;
	      }
	      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
	    };


	  function isList(maybeList) {
	    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
	  }

	  List.isList = isList;

	  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';

	  var ListPrototype = List.prototype;
	  ListPrototype[IS_LIST_SENTINEL] = true;
	  ListPrototype[DELETE] = ListPrototype.remove;
	  ListPrototype.setIn = MapPrototype.setIn;
	  ListPrototype.deleteIn =
	  ListPrototype.removeIn = MapPrototype.removeIn;
	  ListPrototype.update = MapPrototype.update;
	  ListPrototype.updateIn = MapPrototype.updateIn;
	  ListPrototype.mergeIn = MapPrototype.mergeIn;
	  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  ListPrototype.withMutations = MapPrototype.withMutations;
	  ListPrototype.asMutable = MapPrototype.asMutable;
	  ListPrototype.asImmutable = MapPrototype.asImmutable;
	  ListPrototype.wasAltered = MapPrototype.wasAltered;



	    function VNode(array, ownerID) {
	      this.array = array;
	      this.ownerID = ownerID;
	    }

	    // TODO: seems like these methods are very similar

	    VNode.prototype.removeBefore = function(ownerID, level, index) {
	      if (index === level ? 1 << level : 0 || this.array.length === 0) {
	        return this;
	      }
	      var originIndex = (index >>> level) & MASK;
	      if (originIndex >= this.array.length) {
	        return new VNode([], ownerID);
	      }
	      var removingFirst = originIndex === 0;
	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[originIndex];
	        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && removingFirst) {
	          return this;
	        }
	      }
	      if (removingFirst && !newChild) {
	        return this;
	      }
	      var editable = editableVNode(this, ownerID);
	      if (!removingFirst) {
	        for (var ii = 0; ii < originIndex; ii++) {
	          editable.array[ii] = undefined;
	        }
	      }
	      if (newChild) {
	        editable.array[originIndex] = newChild;
	      }
	      return editable;
	    };

	    VNode.prototype.removeAfter = function(ownerID, level, index) {
	      if (index === (level ? 1 << level : 0) || this.array.length === 0) {
	        return this;
	      }
	      var sizeIndex = ((index - 1) >>> level) & MASK;
	      if (sizeIndex >= this.array.length) {
	        return this;
	      }

	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[sizeIndex];
	        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
	          return this;
	        }
	      }

	      var editable = editableVNode(this, ownerID);
	      editable.array.splice(sizeIndex + 1);
	      if (newChild) {
	        editable.array[sizeIndex] = newChild;
	      }
	      return editable;
	    };



	  var DONE = {};

	  function iterateList(list, reverse) {
	    var left = list._origin;
	    var right = list._capacity;
	    var tailPos = getTailOffset(right);
	    var tail = list._tail;

	    return iterateNodeOrLeaf(list._root, list._level, 0);

	    function iterateNodeOrLeaf(node, level, offset) {
	      return level === 0 ?
	        iterateLeaf(node, offset) :
	        iterateNode(node, level, offset);
	    }

	    function iterateLeaf(node, offset) {
	      var array = offset === tailPos ? tail && tail.array : node && node.array;
	      var from = offset > left ? 0 : left - offset;
	      var to = right - offset;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        if (from === to) {
	          return DONE;
	        }
	        var idx = reverse ? --to : from++;
	        return array && array[idx];
	      };
	    }

	    function iterateNode(node, level, offset) {
	      var values;
	      var array = node && node.array;
	      var from = offset > left ? 0 : (left - offset) >> level;
	      var to = ((right - offset) >> level) + 1;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        do {
	          if (values) {
	            var value = values();
	            if (value !== DONE) {
	              return value;
	            }
	            values = null;
	          }
	          if (from === to) {
	            return DONE;
	          }
	          var idx = reverse ? --to : from++;
	          values = iterateNodeOrLeaf(
	            array && array[idx], level - SHIFT, offset + (idx << level)
	          );
	        } while (true);
	      };
	    }
	  }

	  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
	    var list = Object.create(ListPrototype);
	    list.size = capacity - origin;
	    list._origin = origin;
	    list._capacity = capacity;
	    list._level = level;
	    list._root = root;
	    list._tail = tail;
	    list.__ownerID = ownerID;
	    list.__hash = hash;
	    list.__altered = false;
	    return list;
	  }

	  var EMPTY_LIST;
	  function emptyList() {
	    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
	  }

	  function updateList(list, index, value) {
	    index = wrapIndex(list, index);

	    if (index !== index) {
	      return list;
	    }

	    if (index >= list.size || index < 0) {
	      return list.withMutations(function(list ) {
	        index < 0 ?
	          setListBounds(list, index).set(0, value) :
	          setListBounds(list, 0, index + 1).set(index, value)
	      });
	    }

	    index += list._origin;

	    var newTail = list._tail;
	    var newRoot = list._root;
	    var didAlter = MakeRef(DID_ALTER);
	    if (index >= getTailOffset(list._capacity)) {
	      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
	    } else {
	      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
	    }

	    if (!didAlter.value) {
	      return list;
	    }

	    if (list.__ownerID) {
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
	  }

	  function updateVNode(node, ownerID, level, index, value, didAlter) {
	    var idx = (index >>> level) & MASK;
	    var nodeHas = node && idx < node.array.length;
	    if (!nodeHas && value === undefined) {
	      return node;
	    }

	    var newNode;

	    if (level > 0) {
	      var lowerNode = node && node.array[idx];
	      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
	      if (newLowerNode === lowerNode) {
	        return node;
	      }
	      newNode = editableVNode(node, ownerID);
	      newNode.array[idx] = newLowerNode;
	      return newNode;
	    }

	    if (nodeHas && node.array[idx] === value) {
	      return node;
	    }

	    SetRef(didAlter);

	    newNode = editableVNode(node, ownerID);
	    if (value === undefined && idx === newNode.array.length - 1) {
	      newNode.array.pop();
	    } else {
	      newNode.array[idx] = value;
	    }
	    return newNode;
	  }

	  function editableVNode(node, ownerID) {
	    if (ownerID && node && ownerID === node.ownerID) {
	      return node;
	    }
	    return new VNode(node ? node.array.slice() : [], ownerID);
	  }

	  function listNodeFor(list, rawIndex) {
	    if (rawIndex >= getTailOffset(list._capacity)) {
	      return list._tail;
	    }
	    if (rawIndex < 1 << (list._level + SHIFT)) {
	      var node = list._root;
	      var level = list._level;
	      while (node && level > 0) {
	        node = node.array[(rawIndex >>> level) & MASK];
	        level -= SHIFT;
	      }
	      return node;
	    }
	  }

	  function setListBounds(list, begin, end) {
	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      end = end | 0;
	    }
	    var owner = list.__ownerID || new OwnerID();
	    var oldOrigin = list._origin;
	    var oldCapacity = list._capacity;
	    var newOrigin = oldOrigin + begin;
	    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
	    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
	      return list;
	    }

	    // If it's going to end after it starts, it's empty.
	    if (newOrigin >= newCapacity) {
	      return list.clear();
	    }

	    var newLevel = list._level;
	    var newRoot = list._root;

	    // New origin might need creating a higher root.
	    var offsetShift = 0;
	    while (newOrigin + offsetShift < 0) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
	      newLevel += SHIFT;
	      offsetShift += 1 << newLevel;
	    }
	    if (offsetShift) {
	      newOrigin += offsetShift;
	      oldOrigin += offsetShift;
	      newCapacity += offsetShift;
	      oldCapacity += offsetShift;
	    }

	    var oldTailOffset = getTailOffset(oldCapacity);
	    var newTailOffset = getTailOffset(newCapacity);

	    // New size might need creating a higher root.
	    while (newTailOffset >= 1 << (newLevel + SHIFT)) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
	      newLevel += SHIFT;
	    }

	    // Locate or create the new tail.
	    var oldTail = list._tail;
	    var newTail = newTailOffset < oldTailOffset ?
	      listNodeFor(list, newCapacity - 1) :
	      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;

	    // Merge Tail into tree.
	    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
	      newRoot = editableVNode(newRoot, owner);
	      var node = newRoot;
	      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
	        var idx = (oldTailOffset >>> level) & MASK;
	        node = node.array[idx] = editableVNode(node.array[idx], owner);
	      }
	      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
	    }

	    // If the size has been reduced, there's a chance the tail needs to be trimmed.
	    if (newCapacity < oldCapacity) {
	      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
	    }

	    // If the new origin is within the tail, then we do not need a root.
	    if (newOrigin >= newTailOffset) {
	      newOrigin -= newTailOffset;
	      newCapacity -= newTailOffset;
	      newLevel = SHIFT;
	      newRoot = null;
	      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

	    // Otherwise, if the root has been trimmed, garbage collect.
	    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
	      offsetShift = 0;

	      // Identify the new top root node of the subtree of the old root.
	      while (newRoot) {
	        var beginIndex = (newOrigin >>> newLevel) & MASK;
	        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {
	          break;
	        }
	        if (beginIndex) {
	          offsetShift += (1 << newLevel) * beginIndex;
	        }
	        newLevel -= SHIFT;
	        newRoot = newRoot.array[beginIndex];
	      }

	      // Trim the new sides of the new root.
	      if (newRoot && newOrigin > oldOrigin) {
	        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
	      }
	      if (newRoot && newTailOffset < oldTailOffset) {
	        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
	      }
	      if (offsetShift) {
	        newOrigin -= offsetShift;
	        newCapacity -= offsetShift;
	      }
	    }

	    if (list.__ownerID) {
	      list.size = newCapacity - newOrigin;
	      list._origin = newOrigin;
	      list._capacity = newCapacity;
	      list._level = newLevel;
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
	  }

	  function mergeIntoListWith(list, merger, iterables) {
	    var iters = [];
	    var maxSize = 0;
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = IndexedIterable(value);
	      if (iter.size > maxSize) {
	        maxSize = iter.size;
	      }
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    if (maxSize > list.size) {
	      list = list.setSize(maxSize);
	    }
	    return mergeIntoCollectionWith(list, merger, iters);
	  }

	  function getTailOffset(size) {
	    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);
	  }

	  createClass(OrderedMap, Map);

	    // @pragma Construction

	    function OrderedMap(value) {
	      return value === null || value === undefined ? emptyOrderedMap() :
	        isOrderedMap(value) ? value :
	        emptyOrderedMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }

	    OrderedMap.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    OrderedMap.prototype.toString = function() {
	      return this.__toString('OrderedMap {', '}');
	    };

	    // @pragma Access

	    OrderedMap.prototype.get = function(k, notSetValue) {
	      var index = this._map.get(k);
	      return index !== undefined ? this._list.get(index)[1] : notSetValue;
	    };

	    // @pragma Modification

	    OrderedMap.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._map.clear();
	        this._list.clear();
	        return this;
	      }
	      return emptyOrderedMap();
	    };

	    OrderedMap.prototype.set = function(k, v) {
	      return updateOrderedMap(this, k, v);
	    };

	    OrderedMap.prototype.remove = function(k) {
	      return updateOrderedMap(this, k, NOT_SET);
	    };

	    OrderedMap.prototype.wasAltered = function() {
	      return this._map.wasAltered() || this._list.wasAltered();
	    };

	    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._list.__iterate(
	        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},
	        reverse
	      );
	    };

	    OrderedMap.prototype.__iterator = function(type, reverse) {
	      return this._list.fromEntrySeq().__iterator(type, reverse);
	    };

	    OrderedMap.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      var newList = this._list.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        this._list = newList;
	        return this;
	      }
	      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
	    };


	  function isOrderedMap(maybeOrderedMap) {
	    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
	  }

	  OrderedMap.isOrderedMap = isOrderedMap;

	  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
	  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;



	  function makeOrderedMap(map, list, ownerID, hash) {
	    var omap = Object.create(OrderedMap.prototype);
	    omap.size = map ? map.size : 0;
	    omap._map = map;
	    omap._list = list;
	    omap.__ownerID = ownerID;
	    omap.__hash = hash;
	    return omap;
	  }

	  var EMPTY_ORDERED_MAP;
	  function emptyOrderedMap() {
	    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
	  }

	  function updateOrderedMap(omap, k, v) {
	    var map = omap._map;
	    var list = omap._list;
	    var i = map.get(k);
	    var has = i !== undefined;
	    var newMap;
	    var newList;
	    if (v === NOT_SET) { // removed
	      if (!has) {
	        return omap;
	      }
	      if (list.size >= SIZE && list.size >= map.size * 2) {
	        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});
	        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();
	        if (omap.__ownerID) {
	          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
	        }
	      } else {
	        newMap = map.remove(k);
	        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
	      }
	    } else {
	      if (has) {
	        if (v === list.get(i)[1]) {
	          return omap;
	        }
	        newMap = map;
	        newList = list.set(i, [k, v]);
	      } else {
	        newMap = map.set(k, list.size);
	        newList = list.set(list.size, [k, v]);
	      }
	    }
	    if (omap.__ownerID) {
	      omap.size = newMap.size;
	      omap._map = newMap;
	      omap._list = newList;
	      omap.__hash = undefined;
	      return omap;
	    }
	    return makeOrderedMap(newMap, newList);
	  }

	  createClass(ToKeyedSequence, KeyedSeq);
	    function ToKeyedSequence(indexed, useKeys) {
	      this._iter = indexed;
	      this._useKeys = useKeys;
	      this.size = indexed.size;
	    }

	    ToKeyedSequence.prototype.get = function(key, notSetValue) {
	      return this._iter.get(key, notSetValue);
	    };

	    ToKeyedSequence.prototype.has = function(key) {
	      return this._iter.has(key);
	    };

	    ToKeyedSequence.prototype.valueSeq = function() {
	      return this._iter.valueSeq();
	    };

	    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;
	      var reversedSequence = reverseFactory(this, true);
	      if (!this._useKeys) {
	        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};
	      }
	      return reversedSequence;
	    };

	    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;
	      var mappedSequence = mapFactory(this, mapper, context);
	      if (!this._useKeys) {
	        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};
	      }
	      return mappedSequence;
	    };

	    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var ii;
	      return this._iter.__iterate(
	        this._useKeys ?
	          function(v, k)  {return fn(v, k, this$0)} :
	          ((ii = reverse ? resolveSize(this) : 0),
	            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),
	        reverse
	      );
	    };

	    ToKeyedSequence.prototype.__iterator = function(type, reverse) {
	      if (this._useKeys) {
	        return this._iter.__iterator(type, reverse);
	      }
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var ii = reverse ? resolveSize(this) : 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, reverse ? --ii : ii++, step.value, step);
	      });
	    };

	  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;


	  createClass(ToIndexedSequence, IndexedSeq);
	    function ToIndexedSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }

	    ToIndexedSequence.prototype.includes = function(value) {
	      return this._iter.includes(value);
	    };

	    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);
	    };

	    ToIndexedSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, iterations++, step.value, step)
	      });
	    };



	  createClass(ToSetSequence, SetSeq);
	    function ToSetSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }

	    ToSetSequence.prototype.has = function(key) {
	      return this._iter.includes(key);
	    };

	    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);
	    };

	    ToSetSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, step.value, step.value, step);
	      });
	    };



	  createClass(FromEntriesSequence, KeyedSeq);
	    function FromEntriesSequence(entries) {
	      this._iter = entries;
	      this.size = entries.size;
	    }

	    FromEntriesSequence.prototype.entrySeq = function() {
	      return this._iter.toSeq();
	    };

	    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(entry ) {
	        // Check if entry exists first so array access doesn't throw for holes
	        // in the parent iteration.
	        if (entry) {
	          validateEntry(entry);
	          var indexedIterable = isIterable(entry);
	          return fn(
	            indexedIterable ? entry.get(1) : entry[1],
	            indexedIterable ? entry.get(0) : entry[0],
	            this$0
	          );
	        }
	      }, reverse);
	    };

	    FromEntriesSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          // Check if entry exists first so array access doesn't throw for holes
	          // in the parent iteration.
	          if (entry) {
	            validateEntry(entry);
	            var indexedIterable = isIterable(entry);
	            return iteratorValue(
	              type,
	              indexedIterable ? entry.get(0) : entry[0],
	              indexedIterable ? entry.get(1) : entry[1],
	              step
	            );
	          }
	        }
	      });
	    };


	  ToIndexedSequence.prototype.cacheResult =
	  ToKeyedSequence.prototype.cacheResult =
	  ToSetSequence.prototype.cacheResult =
	  FromEntriesSequence.prototype.cacheResult =
	    cacheResultThrough;


	  function flipFactory(iterable) {
	    var flipSequence = makeSequence(iterable);
	    flipSequence._iter = iterable;
	    flipSequence.size = iterable.size;
	    flipSequence.flip = function()  {return iterable};
	    flipSequence.reverse = function () {
	      var reversedSequence = iterable.reverse.apply(this); // super.reverse()
	      reversedSequence.flip = function()  {return iterable.reverse()};
	      return reversedSequence;
	    };
	    flipSequence.has = function(key ) {return iterable.includes(key)};
	    flipSequence.includes = function(key ) {return iterable.has(key)};
	    flipSequence.cacheResult = cacheResultThrough;
	    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);
	    }
	    flipSequence.__iteratorUncached = function(type, reverse) {
	      if (type === ITERATE_ENTRIES) {
	        var iterator = iterable.__iterator(type, reverse);
	        return new Iterator(function()  {
	          var step = iterator.next();
	          if (!step.done) {
	            var k = step.value[0];
	            step.value[0] = step.value[1];
	            step.value[1] = k;
	          }
	          return step;
	        });
	      }
	      return iterable.__iterator(
	        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
	        reverse
	      );
	    }
	    return flipSequence;
	  }


	  function mapFactory(iterable, mapper, context) {
	    var mappedSequence = makeSequence(iterable);
	    mappedSequence.size = iterable.size;
	    mappedSequence.has = function(key ) {return iterable.has(key)};
	    mappedSequence.get = function(key, notSetValue)  {
	      var v = iterable.get(key, NOT_SET);
	      return v === NOT_SET ?
	        notSetValue :
	        mapper.call(context, v, key, iterable);
	    };
	    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(
	        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},
	        reverse
	      );
	    }
	    mappedSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      return new Iterator(function()  {
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var key = entry[0];
	        return iteratorValue(
	          type,
	          key,
	          mapper.call(context, entry[1], key, iterable),
	          step
	        );
	      });
	    }
	    return mappedSequence;
	  }


	  function reverseFactory(iterable, useKeys) {
	    var reversedSequence = makeSequence(iterable);
	    reversedSequence._iter = iterable;
	    reversedSequence.size = iterable.size;
	    reversedSequence.reverse = function()  {return iterable};
	    if (iterable.flip) {
	      reversedSequence.flip = function () {
	        var flipSequence = flipFactory(iterable);
	        flipSequence.reverse = function()  {return iterable.flip()};
	        return flipSequence;
	      };
	    }
	    reversedSequence.get = function(key, notSetValue) 
	      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};
	    reversedSequence.has = function(key )
	      {return iterable.has(useKeys ? key : -1 - key)};
	    reversedSequence.includes = function(value ) {return iterable.includes(value)};
	    reversedSequence.cacheResult = cacheResultThrough;
	    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);
	    };
	    reversedSequence.__iterator =
	      function(type, reverse)  {return iterable.__iterator(type, !reverse)};
	    return reversedSequence;
	  }


	  function filterFactory(iterable, predicate, context, useKeys) {
	    var filterSequence = makeSequence(iterable);
	    if (useKeys) {
	      filterSequence.has = function(key ) {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
	      };
	      filterSequence.get = function(key, notSetValue)  {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?
	          v : notSetValue;
	      };
	    }
	    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      }, reverse);
	      return iterations;
	    };
	    filterSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          var key = entry[0];
	          var value = entry[1];
	          if (predicate.call(context, value, key, iterable)) {
	            return iteratorValue(type, useKeys ? key : iterations++, value, step);
	          }
	        }
	      });
	    }
	    return filterSequence;
	  }


	  function countByFactory(iterable, grouper, context) {
	    var groups = Map().asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        0,
	        function(a ) {return a + 1}
	      );
	    });
	    return groups.asImmutable();
	  }


	  function groupByFactory(iterable, grouper, context) {
	    var isKeyedIter = isKeyed(iterable);
	    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}
	      );
	    });
	    var coerce = iterableClass(iterable);
	    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});
	  }


	  function sliceFactory(iterable, begin, end, useKeys) {
	    var originalSize = iterable.size;

	    // Sanitize begin & end using this shorthand for ToInt32(argument)
	    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
	    if (begin !== undefined) {
	      begin = begin | 0;
	    }
	    if (end !== undefined) {
	      if (end === Infinity) {
	        end = originalSize;
	      } else {
	        end = end | 0;
	      }
	    }

	    if (wholeSlice(begin, end, originalSize)) {
	      return iterable;
	    }

	    var resolvedBegin = resolveBegin(begin, originalSize);
	    var resolvedEnd = resolveEnd(end, originalSize);

	    // begin or end will be NaN if they were provided as negative numbers and
	    // this iterable's size is unknown. In that case, cache first so there is
	    // a known size and these do not resolve to NaN.
	    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
	      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
	    }

	    // Note: resolvedEnd is undefined when the original sequence's length is
	    // unknown and this slice did not supply an end and should contain all
	    // elements after resolvedBegin.
	    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
	    var resolvedSize = resolvedEnd - resolvedBegin;
	    var sliceSize;
	    if (resolvedSize === resolvedSize) {
	      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
	    }

	    var sliceSeq = makeSequence(iterable);

	    // If iterable.size is undefined, the size of the realized sliceSeq is
	    // unknown at this point unless the number of items to slice is 0
	    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;

	    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
	      sliceSeq.get = function (index, notSetValue) {
	        index = wrapIndex(this, index);
	        return index >= 0 && index < sliceSize ?
	          iterable.get(index + resolvedBegin, notSetValue) :
	          notSetValue;
	      }
	    }

	    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (sliceSize === 0) {
	        return 0;
	      }
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var skipped = 0;
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k)  {
	        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&
	                 iterations !== sliceSize;
	        }
	      });
	      return iterations;
	    };

	    sliceSeq.__iteratorUncached = function(type, reverse) {
	      if (sliceSize !== 0 && reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      // Don't bother instantiating parent iterator if taking 0.
	      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
	      var skipped = 0;
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (skipped++ < resolvedBegin) {
	          iterator.next();
	        }
	        if (++iterations > sliceSize) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (useKeys || type === ITERATE_VALUES) {
	          return step;
	        } else if (type === ITERATE_KEYS) {
	          return iteratorValue(type, iterations - 1, undefined, step);
	        } else {
	          return iteratorValue(type, iterations - 1, step.value[1], step);
	        }
	      });
	    }

	    return sliceSeq;
	  }


	  function takeWhileFactory(iterable, predicate, context) {
	    var takeSequence = makeSequence(iterable);
	    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c) 
	        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}
	      );
	      return iterations;
	    };
	    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterating = true;
	      return new Iterator(function()  {
	        if (!iterating) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var k = entry[0];
	        var v = entry[1];
	        if (!predicate.call(context, v, k, this$0)) {
	          iterating = false;
	          return iteratorDone();
	        }
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return takeSequence;
	  }


	  function skipWhileFactory(iterable, predicate, context, useKeys) {
	    var skipSequence = makeSequence(iterable);
	    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      });
	      return iterations;
	    };
	    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var skipping = true;
	      var iterations = 0;
	      return new Iterator(function()  {
	        var step, k, v;
	        do {
	          step = iterator.next();
	          if (step.done) {
	            if (useKeys || type === ITERATE_VALUES) {
	              return step;
	            } else if (type === ITERATE_KEYS) {
	              return iteratorValue(type, iterations++, undefined, step);
	            } else {
	              return iteratorValue(type, iterations++, step.value[1], step);
	            }
	          }
	          var entry = step.value;
	          k = entry[0];
	          v = entry[1];
	          skipping && (skipping = predicate.call(context, v, k, this$0));
	        } while (skipping);
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return skipSequence;
	  }


	  function concatFactory(iterable, values) {
	    var isKeyedIterable = isKeyed(iterable);
	    var iters = [iterable].concat(values).map(function(v ) {
	      if (!isIterable(v)) {
	        v = isKeyedIterable ?
	          keyedSeqFromValue(v) :
	          indexedSeqFromValue(Array.isArray(v) ? v : [v]);
	      } else if (isKeyedIterable) {
	        v = KeyedIterable(v);
	      }
	      return v;
	    }).filter(function(v ) {return v.size !== 0});

	    if (iters.length === 0) {
	      return iterable;
	    }

	    if (iters.length === 1) {
	      var singleton = iters[0];
	      if (singleton === iterable ||
	          isKeyedIterable && isKeyed(singleton) ||
	          isIndexed(iterable) && isIndexed(singleton)) {
	        return singleton;
	      }
	    }

	    var concatSeq = new ArraySeq(iters);
	    if (isKeyedIterable) {
	      concatSeq = concatSeq.toKeyedSeq();
	    } else if (!isIndexed(iterable)) {
	      concatSeq = concatSeq.toSetSeq();
	    }
	    concatSeq = concatSeq.flatten(true);
	    concatSeq.size = iters.reduce(
	      function(sum, seq)  {
	        if (sum !== undefined) {
	          var size = seq.size;
	          if (size !== undefined) {
	            return sum + size;
	          }
	        }
	      },
	      0
	    );
	    return concatSeq;
	  }


	  function flattenFactory(iterable, depth, useKeys) {
	    var flatSequence = makeSequence(iterable);
	    flatSequence.__iterateUncached = function(fn, reverse) {
	      var iterations = 0;
	      var stopped = false;
	      function flatDeep(iter, currentDepth) {var this$0 = this;
	        iter.__iterate(function(v, k)  {
	          if ((!depth || currentDepth < depth) && isIterable(v)) {
	            flatDeep(v, currentDepth + 1);
	          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
	            stopped = true;
	          }
	          return !stopped;
	        }, reverse);
	      }
	      flatDeep(iterable, 0);
	      return iterations;
	    }
	    flatSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(type, reverse);
	      var stack = [];
	      var iterations = 0;
	      return new Iterator(function()  {
	        while (iterator) {
	          var step = iterator.next();
	          if (step.done !== false) {
	            iterator = stack.pop();
	            continue;
	          }
	          var v = step.value;
	          if (type === ITERATE_ENTRIES) {
	            v = v[1];
	          }
	          if ((!depth || stack.length < depth) && isIterable(v)) {
	            stack.push(iterator);
	            iterator = v.__iterator(type, reverse);
	          } else {
	            return useKeys ? step : iteratorValue(type, iterations++, v, step);
	          }
	        }
	        return iteratorDone();
	      });
	    }
	    return flatSequence;
	  }


	  function flatMapFactory(iterable, mapper, context) {
	    var coerce = iterableClass(iterable);
	    return iterable.toSeq().map(
	      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}
	    ).flatten(true);
	  }


	  function interposeFactory(iterable, separator) {
	    var interposedSequence = makeSequence(iterable);
	    interposedSequence.size = iterable.size && iterable.size * 2 -1;
	    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k) 
	        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&
	        fn(v, iterations++, this$0) !== false},
	        reverse
	      );
	      return iterations;
	    };
	    interposedSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      var step;
	      return new Iterator(function()  {
	        if (!step || iterations % 2) {
	          step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	        }
	        return iterations % 2 ?
	          iteratorValue(type, iterations++, separator) :
	          iteratorValue(type, iterations++, step.value, step);
	      });
	    };
	    return interposedSequence;
	  }


	  function sortFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    var isKeyedIterable = isKeyed(iterable);
	    var index = 0;
	    var entries = iterable.toSeq().map(
	      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}
	    ).toArray();
	    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(
	      isKeyedIterable ?
	      function(v, i)  { entries[i].length = 2; } :
	      function(v, i)  { entries[i] = v[1]; }
	    );
	    return isKeyedIterable ? KeyedSeq(entries) :
	      isIndexed(iterable) ? IndexedSeq(entries) :
	      SetSeq(entries);
	  }


	  function maxFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    if (mapper) {
	      var entry = iterable.toSeq()
	        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})
	        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});
	      return entry && entry[0];
	    } else {
	      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});
	    }
	  }

	  function maxCompare(comparator, a, b) {
	    var comp = comparator(b, a);
	    // b is considered the new max if the comparator declares them equal, but
	    // they are not equal and b is in fact a nullish value.
	    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;
	  }


	  function zipWithFactory(keyIter, zipper, iters) {
	    var zipSequence = makeSequence(keyIter);
	    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();
	    // Note: this a generic base implementation of __iterate in terms of
	    // __iterator which may be more generically useful in the future.
	    zipSequence.__iterate = function(fn, reverse) {
	      /* generic:
	      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        iterations++;
	        if (fn(step.value[1], step.value[0], this) === false) {
	          break;
	        }
	      }
	      return iterations;
	      */
	      // indexed:
	      var iterator = this.__iterator(ITERATE_VALUES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        if (fn(step.value, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };
	    zipSequence.__iteratorUncached = function(type, reverse) {
	      var iterators = iters.map(function(i )
	        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}
	      );
	      var iterations = 0;
	      var isDone = false;
	      return new Iterator(function()  {
	        var steps;
	        if (!isDone) {
	          steps = iterators.map(function(i ) {return i.next()});
	          isDone = steps.some(function(s ) {return s.done});
	        }
	        if (isDone) {
	          return iteratorDone();
	        }
	        return iteratorValue(
	          type,
	          iterations++,
	          zipper.apply(null, steps.map(function(s ) {return s.value}))
	        );
	      });
	    };
	    return zipSequence
	  }


	  // #pragma Helper Functions

	  function reify(iter, seq) {
	    return isSeq(iter) ? seq : iter.constructor(seq);
	  }

	  function validateEntry(entry) {
	    if (entry !== Object(entry)) {
	      throw new TypeError('Expected [K, V] tuple: ' + entry);
	    }
	  }

	  function resolveSize(iter) {
	    assertNotInfinite(iter.size);
	    return ensureSize(iter);
	  }

	  function iterableClass(iterable) {
	    return isKeyed(iterable) ? KeyedIterable :
	      isIndexed(iterable) ? IndexedIterable :
	      SetIterable;
	  }

	  function makeSequence(iterable) {
	    return Object.create(
	      (
	        isKeyed(iterable) ? KeyedSeq :
	        isIndexed(iterable) ? IndexedSeq :
	        SetSeq
	      ).prototype
	    );
	  }

	  function cacheResultThrough() {
	    if (this._iter.cacheResult) {
	      this._iter.cacheResult();
	      this.size = this._iter.size;
	      return this;
	    } else {
	      return Seq.prototype.cacheResult.call(this);
	    }
	  }

	  function defaultComparator(a, b) {
	    return a > b ? 1 : a < b ? -1 : 0;
	  }

	  function forceIterator(keyPath) {
	    var iter = getIterator(keyPath);
	    if (!iter) {
	      // Array might not be iterable in this environment, so we need a fallback
	      // to our wrapped type.
	      if (!isArrayLike(keyPath)) {
	        throw new TypeError('Expected iterable or array-like: ' + keyPath);
	      }
	      iter = getIterator(Iterable(keyPath));
	    }
	    return iter;
	  }

	  createClass(Record, KeyedCollection);

	    function Record(defaultValues, name) {
	      var hasInitialized;

	      var RecordType = function Record(values) {
	        if (values instanceof RecordType) {
	          return values;
	        }
	        if (!(this instanceof RecordType)) {
	          return new RecordType(values);
	        }
	        if (!hasInitialized) {
	          hasInitialized = true;
	          var keys = Object.keys(defaultValues);
	          setProps(RecordTypePrototype, keys);
	          RecordTypePrototype.size = keys.length;
	          RecordTypePrototype._name = name;
	          RecordTypePrototype._keys = keys;
	          RecordTypePrototype._defaultValues = defaultValues;
	        }
	        this._map = Map(values);
	      };

	      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
	      RecordTypePrototype.constructor = RecordType;

	      return RecordType;
	    }

	    Record.prototype.toString = function() {
	      return this.__toString(recordName(this) + ' {', '}');
	    };

	    // @pragma Access

	    Record.prototype.has = function(k) {
	      return this._defaultValues.hasOwnProperty(k);
	    };

	    Record.prototype.get = function(k, notSetValue) {
	      if (!this.has(k)) {
	        return notSetValue;
	      }
	      var defaultVal = this._defaultValues[k];
	      return this._map ? this._map.get(k, defaultVal) : defaultVal;
	    };

	    // @pragma Modification

	    Record.prototype.clear = function() {
	      if (this.__ownerID) {
	        this._map && this._map.clear();
	        return this;
	      }
	      var RecordType = this.constructor;
	      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
	    };

	    Record.prototype.set = function(k, v) {
	      if (!this.has(k)) {
	        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
	      }
	      if (this._map && !this._map.has(k)) {
	        var defaultVal = this._defaultValues[k];
	        if (v === defaultVal) {
	          return this;
	        }
	      }
	      var newMap = this._map && this._map.set(k, v);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };

	    Record.prototype.remove = function(k) {
	      if (!this.has(k)) {
	        return this;
	      }
	      var newMap = this._map && this._map.remove(k);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };

	    Record.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };

	    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);
	    };

	    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);
	    };

	    Record.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map && this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return makeRecord(this, newMap, ownerID);
	    };


	  var RecordPrototype = Record.prototype;
	  RecordPrototype[DELETE] = RecordPrototype.remove;
	  RecordPrototype.deleteIn =
	  RecordPrototype.removeIn = MapPrototype.removeIn;
	  RecordPrototype.merge = MapPrototype.merge;
	  RecordPrototype.mergeWith = MapPrototype.mergeWith;
	  RecordPrototype.mergeIn = MapPrototype.mergeIn;
	  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
	  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
	  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  RecordPrototype.setIn = MapPrototype.setIn;
	  RecordPrototype.update = MapPrototype.update;
	  RecordPrototype.updateIn = MapPrototype.updateIn;
	  RecordPrototype.withMutations = MapPrototype.withMutations;
	  RecordPrototype.asMutable = MapPrototype.asMutable;
	  RecordPrototype.asImmutable = MapPrototype.asImmutable;


	  function makeRecord(likeRecord, map, ownerID) {
	    var record = Object.create(Object.getPrototypeOf(likeRecord));
	    record._map = map;
	    record.__ownerID = ownerID;
	    return record;
	  }

	  function recordName(record) {
	    return record._name || record.constructor.name || 'Record';
	  }

	  function setProps(prototype, names) {
	    try {
	      names.forEach(setProp.bind(undefined, prototype));
	    } catch (error) {
	      // Object.defineProperty failed. Probably IE8.
	    }
	  }

	  function setProp(prototype, name) {
	    Object.defineProperty(prototype, name, {
	      get: function() {
	        return this.get(name);
	      },
	      set: function(value) {
	        invariant(this.__ownerID, 'Cannot set on an immutable record.');
	        this.set(name, value);
	      }
	    });
	  }

	  createClass(Set, SetCollection);

	    // @pragma Construction

	    function Set(value) {
	      return value === null || value === undefined ? emptySet() :
	        isSet(value) && !isOrdered(value) ? value :
	        emptySet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }

	    Set.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    Set.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };

	    Set.prototype.toString = function() {
	      return this.__toString('Set {', '}');
	    };

	    // @pragma Access

	    Set.prototype.has = function(value) {
	      return this._map.has(value);
	    };

	    // @pragma Modification

	    Set.prototype.add = function(value) {
	      return updateSet(this, this._map.set(value, true));
	    };

	    Set.prototype.remove = function(value) {
	      return updateSet(this, this._map.remove(value));
	    };

	    Set.prototype.clear = function() {
	      return updateSet(this, this._map.clear());
	    };

	    // @pragma Composition

	    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);
	      iters = iters.filter(function(x ) {return x.size !== 0});
	      if (iters.length === 0) {
	        return this;
	      }
	      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
	        return this.constructor(iters[0]);
	      }
	      return this.withMutations(function(set ) {
	        for (var ii = 0; ii < iters.length; ii++) {
	          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});
	        }
	      });
	    };

	    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (!iters.every(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };

	    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (iters.some(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };

	    Set.prototype.merge = function() {
	      return this.union.apply(this, arguments);
	    };

	    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return this.union.apply(this, iters);
	    };

	    Set.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator));
	    };

	    Set.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator, mapper));
	    };

	    Set.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };

	    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);
	    };

	    Set.prototype.__iterator = function(type, reverse) {
	      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);
	    };

	    Set.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return this.__make(newMap, ownerID);
	    };


	  function isSet(maybeSet) {
	    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
	  }

	  Set.isSet = isSet;

	  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';

	  var SetPrototype = Set.prototype;
	  SetPrototype[IS_SET_SENTINEL] = true;
	  SetPrototype[DELETE] = SetPrototype.remove;
	  SetPrototype.mergeDeep = SetPrototype.merge;
	  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
	  SetPrototype.withMutations = MapPrototype.withMutations;
	  SetPrototype.asMutable = MapPrototype.asMutable;
	  SetPrototype.asImmutable = MapPrototype.asImmutable;

	  SetPrototype.__empty = emptySet;
	  SetPrototype.__make = makeSet;

	  function updateSet(set, newMap) {
	    if (set.__ownerID) {
	      set.size = newMap.size;
	      set._map = newMap;
	      return set;
	    }
	    return newMap === set._map ? set :
	      newMap.size === 0 ? set.__empty() :
	      set.__make(newMap);
	  }

	  function makeSet(map, ownerID) {
	    var set = Object.create(SetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }

	  var EMPTY_SET;
	  function emptySet() {
	    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
	  }

	  createClass(OrderedSet, Set);

	    // @pragma Construction

	    function OrderedSet(value) {
	      return value === null || value === undefined ? emptyOrderedSet() :
	        isOrderedSet(value) ? value :
	        emptyOrderedSet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }

	    OrderedSet.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    OrderedSet.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };

	    OrderedSet.prototype.toString = function() {
	      return this.__toString('OrderedSet {', '}');
	    };


	  function isOrderedSet(maybeOrderedSet) {
	    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
	  }

	  OrderedSet.isOrderedSet = isOrderedSet;

	  var OrderedSetPrototype = OrderedSet.prototype;
	  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;

	  OrderedSetPrototype.__empty = emptyOrderedSet;
	  OrderedSetPrototype.__make = makeOrderedSet;

	  function makeOrderedSet(map, ownerID) {
	    var set = Object.create(OrderedSetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }

	  var EMPTY_ORDERED_SET;
	  function emptyOrderedSet() {
	    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
	  }

	  createClass(Stack, IndexedCollection);

	    // @pragma Construction

	    function Stack(value) {
	      return value === null || value === undefined ? emptyStack() :
	        isStack(value) ? value :
	        emptyStack().unshiftAll(value);
	    }

	    Stack.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    Stack.prototype.toString = function() {
	      return this.__toString('Stack [', ']');
	    };

	    // @pragma Access

	    Stack.prototype.get = function(index, notSetValue) {
	      var head = this._head;
	      index = wrapIndex(this, index);
	      while (head && index--) {
	        head = head.next;
	      }
	      return head ? head.value : notSetValue;
	    };

	    Stack.prototype.peek = function() {
	      return this._head && this._head.value;
	    };

	    // @pragma Modification

	    Stack.prototype.push = function(/*...values*/) {
	      if (arguments.length === 0) {
	        return this;
	      }
	      var newSize = this.size + arguments.length;
	      var head = this._head;
	      for (var ii = arguments.length - 1; ii >= 0; ii--) {
	        head = {
	          value: arguments[ii],
	          next: head
	        };
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    Stack.prototype.pushAll = function(iter) {
	      iter = IndexedIterable(iter);
	      if (iter.size === 0) {
	        return this;
	      }
	      assertNotInfinite(iter.size);
	      var newSize = this.size;
	      var head = this._head;
	      iter.reverse().forEach(function(value ) {
	        newSize++;
	        head = {
	          value: value,
	          next: head
	        };
	      });
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    Stack.prototype.pop = function() {
	      return this.slice(1);
	    };

	    Stack.prototype.unshift = function(/*...values*/) {
	      return this.push.apply(this, arguments);
	    };

	    Stack.prototype.unshiftAll = function(iter) {
	      return this.pushAll(iter);
	    };

	    Stack.prototype.shift = function() {
	      return this.pop.apply(this, arguments);
	    };

	    Stack.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._head = undefined;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyStack();
	    };

	    Stack.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      var resolvedBegin = resolveBegin(begin, this.size);
	      var resolvedEnd = resolveEnd(end, this.size);
	      if (resolvedEnd !== this.size) {
	        // super.slice(begin, end);
	        return IndexedCollection.prototype.slice.call(this, begin, end);
	      }
	      var newSize = this.size - resolvedBegin;
	      var head = this._head;
	      while (resolvedBegin--) {
	        head = head.next;
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    // @pragma Mutability

	    Stack.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeStack(this.size, this._head, ownerID, this.__hash);
	    };

	    // @pragma Iteration

	    Stack.prototype.__iterate = function(fn, reverse) {
	      if (reverse) {
	        return this.reverse().__iterate(fn);
	      }
	      var iterations = 0;
	      var node = this._head;
	      while (node) {
	        if (fn(node.value, iterations++, this) === false) {
	          break;
	        }
	        node = node.next;
	      }
	      return iterations;
	    };

	    Stack.prototype.__iterator = function(type, reverse) {
	      if (reverse) {
	        return this.reverse().__iterator(type);
	      }
	      var iterations = 0;
	      var node = this._head;
	      return new Iterator(function()  {
	        if (node) {
	          var value = node.value;
	          node = node.next;
	          return iteratorValue(type, iterations++, value);
	        }
	        return iteratorDone();
	      });
	    };


	  function isStack(maybeStack) {
	    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
	  }

	  Stack.isStack = isStack;

	  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';

	  var StackPrototype = Stack.prototype;
	  StackPrototype[IS_STACK_SENTINEL] = true;
	  StackPrototype.withMutations = MapPrototype.withMutations;
	  StackPrototype.asMutable = MapPrototype.asMutable;
	  StackPrototype.asImmutable = MapPrototype.asImmutable;
	  StackPrototype.wasAltered = MapPrototype.wasAltered;


	  function makeStack(size, head, ownerID, hash) {
	    var map = Object.create(StackPrototype);
	    map.size = size;
	    map._head = head;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }

	  var EMPTY_STACK;
	  function emptyStack() {
	    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
	  }

	  /**
	   * Contributes additional methods to a constructor
	   */
	  function mixin(ctor, methods) {
	    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };
	    Object.keys(methods).forEach(keyCopier);
	    Object.getOwnPropertySymbols &&
	      Object.getOwnPropertySymbols(methods).forEach(keyCopier);
	    return ctor;
	  }

	  Iterable.Iterator = Iterator;

	  mixin(Iterable, {

	    // ### Conversion to other types

	    toArray: function() {
	      assertNotInfinite(this.size);
	      var array = new Array(this.size || 0);
	      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });
	      return array;
	    },

	    toIndexedSeq: function() {
	      return new ToIndexedSequence(this);
	    },

	    toJS: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}
	      ).__toJS();
	    },

	    toJSON: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}
	      ).__toJS();
	    },

	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, true);
	    },

	    toMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Map(this.toKeyedSeq());
	    },

	    toObject: function() {
	      assertNotInfinite(this.size);
	      var object = {};
	      this.__iterate(function(v, k)  { object[k] = v; });
	      return object;
	    },

	    toOrderedMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedMap(this.toKeyedSeq());
	    },

	    toOrderedSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Set(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toSetSeq: function() {
	      return new ToSetSequence(this);
	    },

	    toSeq: function() {
	      return isIndexed(this) ? this.toIndexedSeq() :
	        isKeyed(this) ? this.toKeyedSeq() :
	        this.toSetSeq();
	    },

	    toStack: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Stack(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toList: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return List(isKeyed(this) ? this.valueSeq() : this);
	    },


	    // ### Common JavaScript methods and properties

	    toString: function() {
	      return '[Iterable]';
	    },

	    __toString: function(head, tail) {
	      if (this.size === 0) {
	        return head + tail;
	      }
	      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
	    },


	    // ### ES6 Collection methods (ES6 Array and Map)

	    concat: function() {var values = SLICE$0.call(arguments, 0);
	      return reify(this, concatFactory(this, values));
	    },

	    includes: function(searchValue) {
	      return this.some(function(value ) {return is(value, searchValue)});
	    },

	    entries: function() {
	      return this.__iterator(ITERATE_ENTRIES);
	    },

	    every: function(predicate, context) {
	      assertNotInfinite(this.size);
	      var returnValue = true;
	      this.__iterate(function(v, k, c)  {
	        if (!predicate.call(context, v, k, c)) {
	          returnValue = false;
	          return false;
	        }
	      });
	      return returnValue;
	    },

	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, true));
	    },

	    find: function(predicate, context, notSetValue) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[1] : notSetValue;
	    },

	    forEach: function(sideEffect, context) {
	      assertNotInfinite(this.size);
	      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
	    },

	    join: function(separator) {
	      assertNotInfinite(this.size);
	      separator = separator !== undefined ? '' + separator : ',';
	      var joined = '';
	      var isFirst = true;
	      this.__iterate(function(v ) {
	        isFirst ? (isFirst = false) : (joined += separator);
	        joined += v !== null && v !== undefined ? v.toString() : '';
	      });
	      return joined;
	    },

	    keys: function() {
	      return this.__iterator(ITERATE_KEYS);
	    },

	    map: function(mapper, context) {
	      return reify(this, mapFactory(this, mapper, context));
	    },

	    reduce: function(reducer, initialReduction, context) {
	      assertNotInfinite(this.size);
	      var reduction;
	      var useFirst;
	      if (arguments.length < 2) {
	        useFirst = true;
	      } else {
	        reduction = initialReduction;
	      }
	      this.__iterate(function(v, k, c)  {
	        if (useFirst) {
	          useFirst = false;
	          reduction = v;
	        } else {
	          reduction = reducer.call(context, reduction, v, k, c);
	        }
	      });
	      return reduction;
	    },

	    reduceRight: function(reducer, initialReduction, context) {
	      var reversed = this.toKeyedSeq().reverse();
	      return reversed.reduce.apply(reversed, arguments);
	    },

	    reverse: function() {
	      return reify(this, reverseFactory(this, true));
	    },

	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, true));
	    },

	    some: function(predicate, context) {
	      return !this.every(not(predicate), context);
	    },

	    sort: function(comparator) {
	      return reify(this, sortFactory(this, comparator));
	    },

	    values: function() {
	      return this.__iterator(ITERATE_VALUES);
	    },


	    // ### More sequential methods

	    butLast: function() {
	      return this.slice(0, -1);
	    },

	    isEmpty: function() {
	      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});
	    },

	    count: function(predicate, context) {
	      return ensureSize(
	        predicate ? this.toSeq().filter(predicate, context) : this
	      );
	    },

	    countBy: function(grouper, context) {
	      return countByFactory(this, grouper, context);
	    },

	    equals: function(other) {
	      return deepEqual(this, other);
	    },

	    entrySeq: function() {
	      var iterable = this;
	      if (iterable._cache) {
	        // We cache as an entries array, so we can just return the cache!
	        return new ArraySeq(iterable._cache);
	      }
	      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
	      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};
	      return entriesSequence;
	    },

	    filterNot: function(predicate, context) {
	      return this.filter(not(predicate), context);
	    },

	    findEntry: function(predicate, context, notSetValue) {
	      var found = notSetValue;
	      this.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          found = [k, v];
	          return false;
	        }
	      });
	      return found;
	    },

	    findKey: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry && entry[0];
	    },

	    findLast: function(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
	    },

	    findLastEntry: function(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
	    },

	    findLastKey: function(predicate, context) {
	      return this.toKeyedSeq().reverse().findKey(predicate, context);
	    },

	    first: function() {
	      return this.find(returnTrue);
	    },

	    flatMap: function(mapper, context) {
	      return reify(this, flatMapFactory(this, mapper, context));
	    },

	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, true));
	    },

	    fromEntrySeq: function() {
	      return new FromEntriesSequence(this);
	    },

	    get: function(searchKey, notSetValue) {
	      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);
	    },

	    getIn: function(searchKeyPath, notSetValue) {
	      var nested = this;
	      // Note: in an ES6 environment, we would prefer:
	      // for (var key of searchKeyPath) {
	      var iter = forceIterator(searchKeyPath);
	      var step;
	      while (!(step = iter.next()).done) {
	        var key = step.value;
	        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
	        if (nested === NOT_SET) {
	          return notSetValue;
	        }
	      }
	      return nested;
	    },

	    groupBy: function(grouper, context) {
	      return groupByFactory(this, grouper, context);
	    },

	    has: function(searchKey) {
	      return this.get(searchKey, NOT_SET) !== NOT_SET;
	    },

	    hasIn: function(searchKeyPath) {
	      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
	    },

	    isSubset: function(iter) {
	      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
	      return this.every(function(value ) {return iter.includes(value)});
	    },

	    isSuperset: function(iter) {
	      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
	      return iter.isSubset(this);
	    },

	    keyOf: function(searchValue) {
	      return this.findKey(function(value ) {return is(value, searchValue)});
	    },

	    keySeq: function() {
	      return this.toSeq().map(keyMapper).toIndexedSeq();
	    },

	    last: function() {
	      return this.toSeq().reverse().first();
	    },

	    lastKeyOf: function(searchValue) {
	      return this.toKeyedSeq().reverse().keyOf(searchValue);
	    },

	    max: function(comparator) {
	      return maxFactory(this, comparator);
	    },

	    maxBy: function(mapper, comparator) {
	      return maxFactory(this, comparator, mapper);
	    },

	    min: function(comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
	    },

	    minBy: function(mapper, comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
	    },

	    rest: function() {
	      return this.slice(1);
	    },

	    skip: function(amount) {
	      return this.slice(Math.max(0, amount));
	    },

	    skipLast: function(amount) {
	      return reify(this, this.toSeq().reverse().skip(amount).reverse());
	    },

	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, true));
	    },

	    skipUntil: function(predicate, context) {
	      return this.skipWhile(not(predicate), context);
	    },

	    sortBy: function(mapper, comparator) {
	      return reify(this, sortFactory(this, comparator, mapper));
	    },

	    take: function(amount) {
	      return this.slice(0, Math.max(0, amount));
	    },

	    takeLast: function(amount) {
	      return reify(this, this.toSeq().reverse().take(amount).reverse());
	    },

	    takeWhile: function(predicate, context) {
	      return reify(this, takeWhileFactory(this, predicate, context));
	    },

	    takeUntil: function(predicate, context) {
	      return this.takeWhile(not(predicate), context);
	    },

	    valueSeq: function() {
	      return this.toIndexedSeq();
	    },


	    // ### Hashable Object

	    hashCode: function() {
	      return this.__hash || (this.__hash = hashIterable(this));
	    }


	    // ### Internal

	    // abstract __iterate(fn, reverse)

	    // abstract __iterator(type, reverse)
	  });

	  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

	  var IterablePrototype = Iterable.prototype;
	  IterablePrototype[IS_ITERABLE_SENTINEL] = true;
	  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
	  IterablePrototype.__toJS = IterablePrototype.toArray;
	  IterablePrototype.__toStringMapper = quoteString;
	  IterablePrototype.inspect =
	  IterablePrototype.toSource = function() { return this.toString(); };
	  IterablePrototype.chain = IterablePrototype.flatMap;
	  IterablePrototype.contains = IterablePrototype.includes;

	  mixin(KeyedIterable, {

	    // ### More sequential methods

	    flip: function() {
	      return reify(this, flipFactory(this));
	    },

	    mapEntries: function(mapper, context) {var this$0 = this;
	      var iterations = 0;
	      return reify(this,
	        this.toSeq().map(
	          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}
	        ).fromEntrySeq()
	      );
	    },

	    mapKeys: function(mapper, context) {var this$0 = this;
	      return reify(this,
	        this.toSeq().flip().map(
	          function(k, v)  {return mapper.call(context, k, v, this$0)}
	        ).flip()
	      );
	    }

	  });

	  var KeyedIterablePrototype = KeyedIterable.prototype;
	  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
	  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
	  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
	  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};



	  mixin(IndexedIterable, {

	    // ### Conversion to other types

	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, false);
	    },


	    // ### ES6 Collection methods (ES6 Array and Map)

	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, false));
	    },

	    findIndex: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },

	    indexOf: function(searchValue) {
	      var key = this.keyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },

	    lastIndexOf: function(searchValue) {
	      var key = this.lastKeyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },

	    reverse: function() {
	      return reify(this, reverseFactory(this, false));
	    },

	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, false));
	    },

	    splice: function(index, removeNum /*, ...values*/) {
	      var numArgs = arguments.length;
	      removeNum = Math.max(removeNum | 0, 0);
	      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
	        return this;
	      }
	      // If index is negative, it should resolve relative to the size of the
	      // collection. However size may be expensive to compute if not cached, so
	      // only call count() if the number is in fact negative.
	      index = resolveBegin(index, index < 0 ? this.count() : this.size);
	      var spliced = this.slice(0, index);
	      return reify(
	        this,
	        numArgs === 1 ?
	          spliced :
	          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
	      );
	    },


	    // ### More collection methods

	    findLastIndex: function(predicate, context) {
	      var entry = this.findLastEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },

	    first: function() {
	      return this.get(0);
	    },

	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, false));
	    },

	    get: function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      return (index < 0 || (this.size === Infinity ||
	          (this.size !== undefined && index > this.size))) ?
	        notSetValue :
	        this.find(function(_, key)  {return key === index}, undefined, notSetValue);
	    },

	    has: function(index) {
	      index = wrapIndex(this, index);
	      return index >= 0 && (this.size !== undefined ?
	        this.size === Infinity || index < this.size :
	        this.indexOf(index) !== -1
	      );
	    },

	    interpose: function(separator) {
	      return reify(this, interposeFactory(this, separator));
	    },

	    interleave: function(/*...iterables*/) {
	      var iterables = [this].concat(arrCopy(arguments));
	      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
	      var interleaved = zipped.flatten(true);
	      if (zipped.size) {
	        interleaved.size = zipped.size * iterables.length;
	      }
	      return reify(this, interleaved);
	    },

	    keySeq: function() {
	      return Range(0, this.size);
	    },

	    last: function() {
	      return this.get(-1);
	    },

	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, false));
	    },

	    zip: function(/*, ...iterables */) {
	      var iterables = [this].concat(arrCopy(arguments));
	      return reify(this, zipWithFactory(this, defaultZipper, iterables));
	    },

	    zipWith: function(zipper/*, ...iterables */) {
	      var iterables = arrCopy(arguments);
	      iterables[0] = this;
	      return reify(this, zipWithFactory(this, zipper, iterables));
	    }

	  });

	  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
	  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;



	  mixin(SetIterable, {

	    // ### ES6 Collection methods (ES6 Array and Map)

	    get: function(value, notSetValue) {
	      return this.has(value) ? value : notSetValue;
	    },

	    includes: function(value) {
	      return this.has(value);
	    },


	    // ### More sequential methods

	    keySeq: function() {
	      return this.valueSeq();
	    }

	  });

	  SetIterable.prototype.has = IterablePrototype.includes;
	  SetIterable.prototype.contains = SetIterable.prototype.includes;


	  // Mixin subclasses

	  mixin(KeyedSeq, KeyedIterable.prototype);
	  mixin(IndexedSeq, IndexedIterable.prototype);
	  mixin(SetSeq, SetIterable.prototype);

	  mixin(KeyedCollection, KeyedIterable.prototype);
	  mixin(IndexedCollection, IndexedIterable.prototype);
	  mixin(SetCollection, SetIterable.prototype);


	  // #pragma Helper functions

	  function keyMapper(v, k) {
	    return k;
	  }

	  function entryMapper(v, k) {
	    return [k, v];
	  }

	  function not(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    }
	  }

	  function neg(predicate) {
	    return function() {
	      return -predicate.apply(this, arguments);
	    }
	  }

	  function quoteString(value) {
	    return typeof value === 'string' ? JSON.stringify(value) : String(value);
	  }

	  function defaultZipper() {
	    return arrCopy(arguments);
	  }

	  function defaultNegComparator(a, b) {
	    return a < b ? 1 : a > b ? -1 : 0;
	  }

	  function hashIterable(iterable) {
	    if (iterable.size === Infinity) {
	      return 0;
	    }
	    var ordered = isOrdered(iterable);
	    var keyed = isKeyed(iterable);
	    var h = ordered ? 1 : 0;
	    var size = iterable.__iterate(
	      keyed ?
	        ordered ?
	          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :
	          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :
	        ordered ?
	          function(v ) { h = 31 * h + hash(v) | 0; } :
	          function(v ) { h = h + hash(v) | 0; }
	    );
	    return murmurHashOfSize(size, h);
	  }

	  function murmurHashOfSize(size, h) {
	    h = imul(h, 0xCC9E2D51);
	    h = imul(h << 15 | h >>> -15, 0x1B873593);
	    h = imul(h << 13 | h >>> -13, 5);
	    h = (h + 0xE6546B64 | 0) ^ size;
	    h = imul(h ^ h >>> 16, 0x85EBCA6B);
	    h = imul(h ^ h >>> 13, 0xC2B2AE35);
	    h = smi(h ^ h >>> 16);
	    return h;
	  }

	  function hashMerge(a, b) {
	    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
	  }

	  var Immutable = {

	    Iterable: Iterable,

	    Seq: Seq,
	    Collection: Collection,
	    Map: Map,
	    OrderedMap: OrderedMap,
	    List: List,
	    Stack: Stack,
	    Set: Set,
	    OrderedSet: OrderedSet,

	    Record: Record,
	    Range: Range,
	    Repeat: Repeat,

	    is: is,
	    fromJS: fromJS

	  };

	  return Immutable;

	}));

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	var identity = __webpack_require__(127),
	    overRest = __webpack_require__(323),
	    setToString = __webpack_require__(326);

	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest(func, start) {
	  return setToString(overRest(func, start, identity), func + '');
	}

	module.exports = baseRest;


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.MENU_HIDE = exports.MENU_SHOW = undefined;
	exports.dispatchGlobalEvent = dispatchGlobalEvent;
	exports.showMenu = showMenu;
	exports.hideMenu = hideMenu;

	var _objectAssign = __webpack_require__(30);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	var _helpers = __webpack_require__(24);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var MENU_SHOW = exports.MENU_SHOW = 'REACT_CONTEXTMENU_SHOW';
	var MENU_HIDE = exports.MENU_HIDE = 'REACT_CONTEXTMENU_HIDE';

	function dispatchGlobalEvent(eventName, opts) {
	    var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : window;

	    // Compatibale with IE
	    // @see http://stackoverflow.com/questions/26596123/internet-explorer-9-10-11-event-constructor-doesnt-work
	    var event = void 0;

	    if (typeof window.CustomEvent === 'function') {
	        event = new window.CustomEvent(eventName, { detail: opts });
	    } else {
	        event = document.createEvent('CustomEvent');
	        event.initCustomEvent(eventName, false, true, opts);
	    }

	    if (target) {
	        target.dispatchEvent(event);
	        (0, _objectAssign2.default)(_helpers.store, opts);
	    }
	}

	function showMenu() {
	    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var target = arguments[1];

	    dispatchGlobalEvent(MENU_SHOW, (0, _objectAssign2.default)({}, opts, { type: MENU_SHOW }), target);
	}

	function hideMenu() {
	    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var target = arguments[1];

	    dispatchGlobalEvent(MENU_HIDE, (0, _objectAssign2.default)({}, opts, { type: MENU_HIDE }), target);
	}

/***/ }),
/* 24 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.callIfExists = callIfExists;
	exports.hasOwnProp = hasOwnProp;
	exports.uniqueId = uniqueId;
	function callIfExists(func) {
	    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	    }

	    return typeof func === 'function' && func.apply(undefined, args);
	}

	function hasOwnProp(obj, prop) {
	    return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	function uniqueId() {
	    return Math.random().toString(36).substring(7);
	}

	var cssClasses = exports.cssClasses = {
	    menu: 'react-contextmenu',
	    menuVisible: 'react-contextmenu--visible',
	    menuWrapper: 'react-contextmenu-wrapper',
	    menuItem: 'react-contextmenu-item',
	    menuItemActive: 'react-contextmenu-item--active',
	    menuItemDisabled: 'react-contextmenu-item--disabled',
	    menuItemDivider: 'react-contextmenu-item--divider',
	    menuItemSelected: 'react-contextmenu-item--selected',
	    subMenu: 'react-contextmenu-submenu'
	};

	var store = exports.store = {};

	var canUseDOM = exports.canUseDOM = Boolean(typeof window !== 'undefined' && window.document && window.document.createElement);

/***/ }),
/* 25 */,
/* 26 */,
/* 27 */
[1758, 124],
/* 28 */
/***/ (function(module, exports) {

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	module.exports = isObject;


/***/ }),
/* 29 */
/***/ (function(module, exports) {

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	module.exports = isObjectLike;


/***/ }),
/* 30 */
/***/ (function(module, exports) {

	/*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/

	'use strict';
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};


/***/ }),
/* 31 */
[1632, 51, 418, 445],
/* 32 */
29,
/* 33 */
/***/ (function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ }),
/* 34 */,
/* 35 */,
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.END_DRAG = exports.DROP = exports.HOVER = exports.PUBLISH_DRAG_SOURCE = exports.BEGIN_DRAG = undefined;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	exports.beginDrag = beginDrag;
	exports.publishDragSource = publishDragSource;
	exports.hover = hover;
	exports.drop = drop;
	exports.endDrag = endDrag;

	var _invariant = __webpack_require__(8);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _isArray = __webpack_require__(18);

	var _isArray2 = _interopRequireDefault(_isArray);

	var _isObject = __webpack_require__(28);

	var _isObject2 = _interopRequireDefault(_isObject);

	var _matchesType = __webpack_require__(113);

	var _matchesType2 = _interopRequireDefault(_matchesType);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var BEGIN_DRAG = exports.BEGIN_DRAG = 'dnd-core/BEGIN_DRAG';
	var PUBLISH_DRAG_SOURCE = exports.PUBLISH_DRAG_SOURCE = 'dnd-core/PUBLISH_DRAG_SOURCE';
	var HOVER = exports.HOVER = 'dnd-core/HOVER';
	var DROP = exports.DROP = 'dnd-core/DROP';
	var END_DRAG = exports.END_DRAG = 'dnd-core/END_DRAG';

	function beginDrag(sourceIds) {
		var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { publishSource: true, clientOffset: null };
		var publishSource = options.publishSource,
		    clientOffset = options.clientOffset,
		    getSourceClientOffset = options.getSourceClientOffset;

		(0, _invariant2.default)((0, _isArray2.default)(sourceIds), 'Expected sourceIds to be an array.');

		var monitor = this.getMonitor();
		var registry = this.getRegistry();
		(0, _invariant2.default)(!monitor.isDragging(), 'Cannot call beginDrag while dragging.');

		for (var i = 0; i < sourceIds.length; i++) {
			(0, _invariant2.default)(registry.getSource(sourceIds[i]), 'Expected sourceIds to be registered.');
		}

		var sourceId = null;
		for (var _i = sourceIds.length - 1; _i >= 0; _i--) {
			if (monitor.canDragSource(sourceIds[_i])) {
				sourceId = sourceIds[_i];
				break;
			}
		}
		if (sourceId === null) {
			return;
		}

		var sourceClientOffset = null;
		if (clientOffset) {
			(0, _invariant2.default)(typeof getSourceClientOffset === 'function', 'When clientOffset is provided, getSourceClientOffset must be a function.');
			sourceClientOffset = getSourceClientOffset(sourceId);
		}

		var source = registry.getSource(sourceId);
		var item = source.beginDrag(monitor, sourceId);
		(0, _invariant2.default)((0, _isObject2.default)(item), 'Item must be an object.');

		registry.pinSource(sourceId);

		var itemType = registry.getSourceType(sourceId);
		return {
			type: BEGIN_DRAG,
			itemType: itemType,
			item: item,
			sourceId: sourceId,
			clientOffset: clientOffset,
			sourceClientOffset: sourceClientOffset,
			isSourcePublic: publishSource
		};
	}

	function publishDragSource() {
		var monitor = this.getMonitor();
		if (!monitor.isDragging()) {
			return;
		}

		return { type: PUBLISH_DRAG_SOURCE };
	}

	function hover(targetIdsArg) {
		var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
		    _ref$clientOffset = _ref.clientOffset,
		    clientOffset = _ref$clientOffset === undefined ? null : _ref$clientOffset;

		(0, _invariant2.default)((0, _isArray2.default)(targetIdsArg), 'Expected targetIds to be an array.');
		var targetIds = targetIdsArg.slice(0);

		var monitor = this.getMonitor();
		var registry = this.getRegistry();
		(0, _invariant2.default)(monitor.isDragging(), 'Cannot call hover while not dragging.');
		(0, _invariant2.default)(!monitor.didDrop(), 'Cannot call hover after drop.');

		// First check invariants.
		for (var i = 0; i < targetIds.length; i++) {
			var targetId = targetIds[i];
			(0, _invariant2.default)(targetIds.lastIndexOf(targetId) === i, 'Expected targetIds to be unique in the passed array.');

			var target = registry.getTarget(targetId);
			(0, _invariant2.default)(target, 'Expected targetIds to be registered.');
		}

		var draggedItemType = monitor.getItemType();

		// Remove those targetIds that don't match the targetType.  This
		// fixes shallow isOver which would only be non-shallow because of
		// non-matching targets.
		for (var _i2 = targetIds.length - 1; _i2 >= 0; _i2--) {
			var _targetId = targetIds[_i2];
			var targetType = registry.getTargetType(_targetId);
			if (!(0, _matchesType2.default)(targetType, draggedItemType)) {
				targetIds.splice(_i2, 1);
			}
		}

		// Finally call hover on all matching targets.
		for (var _i3 = 0; _i3 < targetIds.length; _i3++) {
			var _targetId2 = targetIds[_i3];
			var _target = registry.getTarget(_targetId2);
			_target.hover(monitor, _targetId2);
		}

		return {
			type: HOVER,
			targetIds: targetIds,
			clientOffset: clientOffset
		};
	}

	function drop() {
		var _this = this;

		var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

		var monitor = this.getMonitor();
		var registry = this.getRegistry();
		(0, _invariant2.default)(monitor.isDragging(), 'Cannot call drop while not dragging.');
		(0, _invariant2.default)(!monitor.didDrop(), 'Cannot call drop twice during one drag operation.');

		var targetIds = monitor.getTargetIds().filter(monitor.canDropOnTarget, monitor);

		targetIds.reverse();
		targetIds.forEach(function (targetId, index) {
			var target = registry.getTarget(targetId);

			var dropResult = target.drop(monitor, targetId);
			(0, _invariant2.default)(typeof dropResult === 'undefined' || (0, _isObject2.default)(dropResult), 'Drop result must either be an object or undefined.');
			if (typeof dropResult === 'undefined') {
				dropResult = index === 0 ? {} : monitor.getDropResult();
			}

			_this.store.dispatch({
				type: DROP,
				dropResult: _extends({}, options, dropResult)
			});
		});
	}

	function endDrag() {
		var monitor = this.getMonitor();
		var registry = this.getRegistry();
		(0, _invariant2.default)(monitor.isDragging(), 'Cannot call endDrag while not dragging.');

		var sourceId = monitor.getSourceId();
		var source = registry.getSource(sourceId, true);
		source.endDrag(monitor, sourceId);

		registry.unpinSource();

		return { type: END_DRAG };
	}

/***/ }),
/* 37 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.addSource = addSource;
	exports.addTarget = addTarget;
	exports.removeSource = removeSource;
	exports.removeTarget = removeTarget;
	var ADD_SOURCE = exports.ADD_SOURCE = 'dnd-core/ADD_SOURCE';
	var ADD_TARGET = exports.ADD_TARGET = 'dnd-core/ADD_TARGET';
	var REMOVE_SOURCE = exports.REMOVE_SOURCE = 'dnd-core/REMOVE_SOURCE';
	var REMOVE_TARGET = exports.REMOVE_TARGET = 'dnd-core/REMOVE_TARGET';

	function addSource(sourceId) {
		return {
			type: ADD_SOURCE,
			sourceId: sourceId
		};
	}

	function addTarget(targetId) {
		return {
			type: ADD_TARGET,
			targetId: targetId
		};
	}

	function removeSource(sourceId) {
		return {
			type: REMOVE_SOURCE,
			sourceId: sourceId
		};
	}

	function removeTarget(targetId) {
		return {
			type: REMOVE_TARGET,
			targetId: targetId
		};
	}

/***/ }),
/* 38 */,
/* 39 */
[1622, 44],
/* 40 */
[1632, 68, 297, 321],
/* 41 */
[1664, 306],
/* 42 */
[1665, 284, 298],
/* 43 */
[1746, 42],
/* 44 */
/***/ (function(module, exports) {

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	module.exports = eq;


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	var isArrayLike = __webpack_require__(74),
	    isObjectLike = __webpack_require__(29);

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}

	module.exports = isArrayLikeObject;


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	  Copyright (c) 2016 Jed Watson.
	  Licensed under the MIT License (MIT), see
	  http://jedwatson.github.io/classnames
	*/
	/* global define */

	(function () {
		'use strict';

		var hasOwn = {}.hasOwnProperty;

		function classNames () {
			var classes = [];

			for (var i = 0; i < arguments.length; i++) {
				var arg = arguments[i];
				if (!arg) continue;

				var argType = typeof arg;

				if (argType === 'string' || argType === 'number') {
					classes.push(arg);
				} else if (Array.isArray(arg)) {
					classes.push(classNames.apply(null, arg));
				} else if (argType === 'object') {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				}
			}

			return classes.join(' ');
		}

		if (typeof module !== 'undefined' && module.exports) {
			module.exports = classNames;
		} else if (true) {
			// register as 'classnames', consistent with npm package name
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return classNames;
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
			window.classNames = classNames;
		}
	}());


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = checkDecoratorArguments;
	function checkDecoratorArguments(functionName, signature) {
		if (false) {
			for (var i = 0; i < (arguments.length <= 2 ? 0 : arguments.length - 2); i += 1) {
				var arg = arguments.length <= i + 2 ? undefined : arguments[i + 2];
				if (arg && arg.prototype && arg.prototype.render) {
					// eslint-disable-next-line no-console
					console.error('You seem to be applying the arguments in the wrong order. ' + ('It should be ' + functionName + '(' + signature + ')(Component), not the other way around. ') + 'Read more: http://react-dnd.github.io/react-dnd/docs-troubleshooting.html#you-seem-to-be-applying-the-arguments-in-the-wrong-order');
					return;
				}
			}
		}
	}

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _reactDom = __webpack_require__(6);

	var _reactInputAutosize = __webpack_require__(367);

	var _reactInputAutosize2 = _interopRequireDefault(_reactInputAutosize);

	var _classnames = __webpack_require__(49);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _defaultArrowRenderer = __webpack_require__(149);

	var _defaultArrowRenderer2 = _interopRequireDefault(_defaultArrowRenderer);

	var _defaultFilterOptions = __webpack_require__(79);

	var _defaultFilterOptions2 = _interopRequireDefault(_defaultFilterOptions);

	var _defaultMenuRenderer = __webpack_require__(80);

	var _defaultMenuRenderer2 = _interopRequireDefault(_defaultMenuRenderer);

	var _defaultClearRenderer = __webpack_require__(150);

	var _defaultClearRenderer2 = _interopRequireDefault(_defaultClearRenderer);

	var _Option = __webpack_require__(147);

	var _Option2 = _interopRequireDefault(_Option);

	var _Value = __webpack_require__(148);

	var _Value2 = _interopRequireDefault(_Value);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*!
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Copyright (c) 2017 Jed Watson.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Licensed under the MIT License (MIT), see
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 http://jedwatson.github.io/react-select
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */


	var stringifyValue = function stringifyValue(value) {
		return typeof value === 'string' ? value : value !== null && JSON.stringify(value) || '';
	};

	var stringOrNode = _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.node]);
	var stringOrNumber = _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]);

	var instanceId = 1;

	var Select = function (_React$Component) {
		_inherits(Select, _React$Component);

		function Select(props) {
			_classCallCheck(this, Select);

			var _this = _possibleConstructorReturn(this, (Select.__proto__ || Object.getPrototypeOf(Select)).call(this, props));

			['clearValue', 'focusOption', 'handleInputBlur', 'handleInputChange', 'handleInputFocus', 'handleInputValueChange', 'handleKeyDown', 'handleMenuScroll', 'handleMouseDown', 'handleMouseDownOnArrow', 'handleMouseDownOnMenu', 'handleRequired', 'handleTouchOutside', 'handleTouchMove', 'handleTouchStart', 'handleTouchEnd', 'handleTouchEndClearValue', 'handleValueClick', 'getOptionLabel', 'onOptionRef', 'removeValue', 'selectValue'].forEach(function (fn) {
				return _this[fn] = _this[fn].bind(_this);
			});

			_this.state = {
				inputValue: '',
				isFocused: false,
				isOpen: false,
				isPseudoFocused: false,
				required: false
			};
			return _this;
		}

		_createClass(Select, [{
			key: 'componentWillMount',
			value: function componentWillMount() {
				this._instancePrefix = 'react-select-' + (this.props.instanceId || ++instanceId) + '-';
				var valueArray = this.getValueArray(this.props.value);

				if (this.props.required) {
					this.setState({
						required: this.handleRequired(valueArray[0], this.props.multi)
					});
				}
			}
		}, {
			key: 'componentDidMount',
			value: function componentDidMount() {
				if (typeof this.props.autofocus !== 'undefined' && typeof console !== 'undefined') {
					console.warn('Warning: The autofocus prop has changed to autoFocus, support will be removed after react-select@1.0');
				}
				if (this.props.autoFocus || this.props.autofocus) {
					this.focus();
				}
			}
		}, {
			key: 'componentWillReceiveProps',
			value: function componentWillReceiveProps(nextProps) {
				var valueArray = this.getValueArray(nextProps.value, nextProps);

				if (nextProps.required) {
					this.setState({
						required: this.handleRequired(valueArray[0], nextProps.multi)
					});
				} else if (this.props.required) {
					// Used to be required but it's not any more
					this.setState({ required: false });
				}
			}
		}, {
			key: 'componentDidUpdate',
			value: function componentDidUpdate(prevProps, prevState) {
				// focus to the selected option
				if (this.menu && this.focused && this.state.isOpen && !this.hasScrolledToOption) {
					var focusedOptionNode = (0, _reactDom.findDOMNode)(this.focused);
					var menuNode = (0, _reactDom.findDOMNode)(this.menu);

					var scrollTop = menuNode.scrollTop;
					var scrollBottom = scrollTop + menuNode.offsetHeight;
					var optionTop = focusedOptionNode.offsetTop;
					var optionBottom = optionTop + focusedOptionNode.offsetHeight;

					if (scrollTop > optionTop || scrollBottom < optionBottom) {
						menuNode.scrollTop = focusedOptionNode.offsetTop;
					}

					// We still set hasScrolledToOption to true even if we didn't
					// actually need to scroll, as we've still confirmed that the
					// option is in view.
					this.hasScrolledToOption = true;
				} else if (!this.state.isOpen) {
					this.hasScrolledToOption = false;
				}

				if (this._scrollToFocusedOptionOnUpdate && this.focused && this.menu) {
					this._scrollToFocusedOptionOnUpdate = false;
					var focusedDOM = (0, _reactDom.findDOMNode)(this.focused);
					var menuDOM = (0, _reactDom.findDOMNode)(this.menu);
					var focusedRect = focusedDOM.getBoundingClientRect();
					var menuRect = menuDOM.getBoundingClientRect();
					if (focusedRect.bottom > menuRect.bottom) {
						menuDOM.scrollTop = focusedDOM.offsetTop + focusedDOM.clientHeight - menuDOM.offsetHeight;
					} else if (focusedRect.top < menuRect.top) {
						menuDOM.scrollTop = focusedDOM.offsetTop;
					}
				}
				if (this.props.scrollMenuIntoView && this.menuContainer) {
					var menuContainerRect = this.menuContainer.getBoundingClientRect();
					if (window.innerHeight < menuContainerRect.bottom + this.props.menuBuffer) {
						window.scrollBy(0, menuContainerRect.bottom + this.props.menuBuffer - window.innerHeight);
					}
				}
				if (prevProps.disabled !== this.props.disabled) {
					this.setState({ isFocused: false }); // eslint-disable-line react/no-did-update-set-state
					this.closeMenu();
				}
				if (prevState.isOpen !== this.state.isOpen) {
					this.toggleTouchOutsideEvent(this.state.isOpen);
					var handler = this.state.isOpen ? this.props.onOpen : this.props.onClose;
					handler && handler();
				}
			}
		}, {
			key: 'componentWillUnmount',
			value: function componentWillUnmount() {
				this.toggleTouchOutsideEvent(false);
			}
		}, {
			key: 'toggleTouchOutsideEvent',
			value: function toggleTouchOutsideEvent(enabled) {
				if (enabled) {
					if (!document.addEventListener && document.attachEvent) {
						document.attachEvent('ontouchstart', this.handleTouchOutside);
					} else {
						document.addEventListener('touchstart', this.handleTouchOutside);
					}
				} else {
					if (!document.removeEventListener && document.detachEvent) {
						document.detachEvent('ontouchstart', this.handleTouchOutside);
					} else {
						document.removeEventListener('touchstart', this.handleTouchOutside);
					}
				}
			}
		}, {
			key: 'handleTouchOutside',
			value: function handleTouchOutside(event) {
				// handle touch outside on ios to dismiss menu
				if (this.wrapper && !this.wrapper.contains(event.target)) {
					this.closeMenu();
				}
			}
		}, {
			key: 'focus',
			value: function focus() {
				if (!this.input) return;
				this.input.focus();
			}
		}, {
			key: 'blurInput',
			value: function blurInput() {
				if (!this.input) return;
				this.input.blur();
			}
		}, {
			key: 'handleTouchMove',
			value: function handleTouchMove(event) {
				// Set a flag that the view is being dragged
				this.dragging = true;
			}
		}, {
			key: 'handleTouchStart',
			value: function handleTouchStart(event) {
				// Set a flag that the view is not being dragged
				this.dragging = false;
			}
		}, {
			key: 'handleTouchEnd',
			value: function handleTouchEnd(event) {
				// Check if the view is being dragged, In this case
				// we don't want to fire the click event (because the user only wants to scroll)
				if (this.dragging) return;

				// Fire the mouse events
				this.handleMouseDown(event);
			}
		}, {
			key: 'handleTouchEndClearValue',
			value: function handleTouchEndClearValue(event) {
				// Check if the view is being dragged, In this case
				// we don't want to fire the click event (because the user only wants to scroll)
				if (this.dragging) return;

				// Clear the value
				this.clearValue(event);
			}
		}, {
			key: 'handleMouseDown',
			value: function handleMouseDown(event) {
				// if the event was triggered by a mousedown and not the primary
				// button, or if the component is disabled, ignore it.
				if (this.props.disabled || event.type === 'mousedown' && event.button !== 0) {
					return;
				}

				if (event.target.tagName === 'INPUT') {
					if (!this.state.isFocused) {
						this._openAfterFocus = this.props.openOnClick;
						this.focus();
					} else if (!this.state.isOpen) {
						this.setState({
							isOpen: true,
							isPseudoFocused: false
						});
					}
					return;
				}

				// prevent default event handlers
				event.preventDefault();

				// for the non-searchable select, toggle the menu
				if (!this.props.searchable) {
					// TODO: This code means that if a select is searchable, onClick the options menu will not appear, only on subsequent click will it open.
					this.focus();
					return this.setState({
						isOpen: !this.state.isOpen
					});
				}

				if (this.state.isFocused) {
					// On iOS, we can get into a state where we think the input is focused but it isn't really,
					// since iOS ignores programmatic calls to input.focus() that weren't triggered by a click event.
					// Call focus() again here to be safe.
					this.focus();

					var input = this.input;
					if (typeof input.getInput === 'function') {
						// Get the actual DOM input if the ref is an <AutosizeInput /> component
						input = input.getInput();
					}

					// clears the value so that the cursor will be at the end of input when the component re-renders
					input.value = '';

					// if the input is focused, ensure the menu is open
					this.setState({
						isOpen: true,
						isPseudoFocused: false
					});
				} else {
					// otherwise, focus the input and open the menu
					this._openAfterFocus = this.props.openOnClick;
					this.focus();
				}
			}
		}, {
			key: 'handleMouseDownOnArrow',
			value: function handleMouseDownOnArrow(event) {
				// if the event was triggered by a mousedown and not the primary
				// button, or if the component is disabled, ignore it.
				if (this.props.disabled || event.type === 'mousedown' && event.button !== 0) {
					return;
				}
				// If the menu isn't open, let the event bubble to the main handleMouseDown
				if (!this.state.isOpen) {
					this.setState({
						isOpen: true
					});
				}
				// prevent default event handlers
				event.stopPropagation();
				event.preventDefault();
				// close the menu
				if (this.state.isOpen) {
					this.closeMenu();
				}
			}
		}, {
			key: 'handleMouseDownOnMenu',
			value: function handleMouseDownOnMenu(event) {
				// if the event was triggered by a mousedown and not the primary
				// button, or if the component is disabled, ignore it.
				if (this.props.disabled || event.type === 'mousedown' && event.button !== 0) {
					return;
				}
				event.stopPropagation();
				event.preventDefault();

				this._openAfterFocus = true;
				this.focus();
			}
		}, {
			key: 'closeMenu',
			value: function closeMenu() {
				if (this.props.onCloseResetsInput) {
					this.setState({
						isOpen: false,
						isPseudoFocused: this.state.isFocused && !this.props.multi,
						inputValue: this.handleInputValueChange('')
					});
				} else {
					this.setState({
						isOpen: false,
						isPseudoFocused: this.state.isFocused && !this.props.multi
					});
				}
				this.hasScrolledToOption = false;
			}
		}, {
			key: 'handleInputFocus',
			value: function handleInputFocus(event) {
				if (this.props.disabled) return;
				var isOpen = this.state.isOpen || this._openAfterFocus || this.props.openOnFocus;
				if (this.props.onFocus) {
					this.props.onFocus(event);
				}
				this.setState({
					isFocused: true,
					isOpen: isOpen
				});
				this._openAfterFocus = false;
			}
		}, {
			key: 'handleInputBlur',
			value: function handleInputBlur(event) {
				// The check for menu.contains(activeElement) is necessary to prevent IE11's scrollbar from closing the menu in certain contexts.
				if (this.menu && (this.menu === document.activeElement || this.menu.contains(document.activeElement))) {
					this.focus();
					return;
				}

				if (this.props.onBlur) {
					this.props.onBlur(event);
				}
				var onBlurredState = {
					isFocused: false,
					isOpen: false,
					isPseudoFocused: false
				};
				if (this.props.onBlurResetsInput) {
					onBlurredState.inputValue = this.handleInputValueChange('');
				}
				this.setState(onBlurredState);
			}
		}, {
			key: 'handleInputChange',
			value: function handleInputChange(event) {
				var newInputValue = event.target.value;

				if (this.state.inputValue !== event.target.value) {
					newInputValue = this.handleInputValueChange(newInputValue);
				}

				this.setState({
					isOpen: true,
					isPseudoFocused: false,
					inputValue: newInputValue
				});
			}
		}, {
			key: 'handleInputValueChange',
			value: function handleInputValueChange(newValue) {
				if (this.props.onInputChange) {
					var nextState = this.props.onInputChange(newValue);
					// Note: != used deliberately here to catch undefined and null
					if (nextState != null && (typeof nextState === 'undefined' ? 'undefined' : _typeof(nextState)) !== 'object') {
						newValue = '' + nextState;
					}
				}
				return newValue;
			}
		}, {
			key: 'handleKeyDown',
			value: function handleKeyDown(event) {
				if (this.props.disabled) return;

				if (typeof this.props.onInputKeyDown === 'function') {
					this.props.onInputKeyDown(event);
					if (event.defaultPrevented) {
						return;
					}
				}

				switch (event.keyCode) {
					case 8:
						// backspace
						if (!this.state.inputValue && this.props.backspaceRemoves) {
							event.preventDefault();
							this.popValue();
						}
						return;
					case 9:
						// tab
						if (event.shiftKey || !this.state.isOpen || !this.props.tabSelectsValue) {
							return;
						}
						event.preventDefault();
						this.selectFocusedOption();
						return;
					case 13:
						// enter
						event.preventDefault();
						event.stopPropagation();
						if (this.state.isOpen) {
							this.selectFocusedOption();
						} else {
							this.focusNextOption();
						}
						return;
						break;
					case 27:
						// escape
						if (this.state.isOpen) {
							this.closeMenu();
							event.stopPropagation();
						} else if (this.props.clearable && this.props.escapeClearsValue) {
							this.clearValue(event);
							event.stopPropagation();
						}
						break;
					case 32:
						// space
						if (this.props.searchable) {
							return;
						}
						event.preventDefault();
						if (!this.state.isOpen) {
							this.focusNextOption();
							return;
						}
						event.stopPropagation();
						this.selectFocusedOption();
						break;
					case 38:
						// up
						this.focusPreviousOption();
						break;
					case 40:
						// down
						this.focusNextOption();
						break;
					case 33:
						// page up
						this.focusPageUpOption();
						break;
					case 34:
						// page down
						this.focusPageDownOption();
						break;
					case 35:
						// end key
						if (event.shiftKey) {
							return;
						}
						this.focusEndOption();
						break;
					case 36:
						// home key
						if (event.shiftKey) {
							return;
						}
						this.focusStartOption();
						break;
					case 46:
						// delete
						if (!this.state.inputValue && this.props.deleteRemoves) {
							event.preventDefault();
							this.popValue();
						}
						return;
					default:
						return;
				}
				event.preventDefault();
			}
		}, {
			key: 'handleValueClick',
			value: function handleValueClick(option, event) {
				if (!this.props.onValueClick) return;
				this.props.onValueClick(option, event);
			}
		}, {
			key: 'handleMenuScroll',
			value: function handleMenuScroll(event) {
				if (!this.props.onMenuScrollToBottom) return;
				var target = event.target;

				if (target.scrollHeight > target.offsetHeight && target.scrollHeight - target.offsetHeight - target.scrollTop <= 0) {
					this.props.onMenuScrollToBottom();
				}
			}
		}, {
			key: 'handleRequired',
			value: function handleRequired(value, multi) {
				if (!value) return true;
				return multi ? value.length === 0 : Object.keys(value).length === 0;
			}
		}, {
			key: 'getOptionLabel',
			value: function getOptionLabel(op) {
				return op[this.props.labelKey];
			}

			/**
	   * Turns a value into an array from the given options
	   * @param	{String|Number|Array}	value		- the value of the select input
	   * @param	{Object}		nextProps	- optionally specify the nextProps so the returned array uses the latest configuration
	   * @returns	{Array}	the value of the select represented in an array
	   */

		}, {
			key: 'getValueArray',
			value: function getValueArray(value, nextProps) {
				var _this2 = this;

				/** support optionally passing in the `nextProps` so `componentWillReceiveProps` updates will function as expected */
				var props = (typeof nextProps === 'undefined' ? 'undefined' : _typeof(nextProps)) === 'object' ? nextProps : this.props;
				if (props.multi) {
					if (typeof value === 'string') {
						value = value.split(props.delimiter);
					}
					if (!Array.isArray(value)) {
						if (value === null || value === undefined) return [];
						value = [value];
					}
					return value.map(function (value) {
						return _this2.expandValue(value, props);
					}).filter(function (i) {
						return i;
					});
				}
				var expandedValue = this.expandValue(value, props);
				return expandedValue ? [expandedValue] : [];
			}

			/**
	   * Retrieve a value from the given options and valueKey
	   * @param	{String|Number|Array}	value	- the selected value(s)
	   * @param	{Object}		props	- the Select component's props (or nextProps)
	   */

		}, {
			key: 'expandValue',
			value: function expandValue(value, props) {
				var valueType = typeof value === 'undefined' ? 'undefined' : _typeof(value);
				if (valueType !== 'string' && valueType !== 'number' && valueType !== 'boolean') return value;
				var options = props.options,
				    valueKey = props.valueKey;

				if (!options) return;
				for (var i = 0; i < options.length; i++) {
					if (String(options[i][valueKey]) === String(value)) return options[i];
				}
			}
		}, {
			key: 'setValue',
			value: function setValue(value) {
				var _this3 = this;

				if (this.props.autoBlur) {
					this.blurInput();
				}
				if (this.props.required) {
					var required = this.handleRequired(value, this.props.multi);
					this.setState({ required: required });
				}
				if (this.props.onChange) {
					if (this.props.simpleValue && value) {
						value = this.props.multi ? value.map(function (i) {
							return i[_this3.props.valueKey];
						}).join(this.props.delimiter) : value[this.props.valueKey];
					}
					this.props.onChange(value);
				}
			}
		}, {
			key: 'selectValue',
			value: function selectValue(value) {
				var _this4 = this;

				// NOTE: we actually add/set the value in a callback to make sure the
				// input value is empty to avoid styling issues in Chrome
				if (this.props.closeOnSelect) {
					this.hasScrolledToOption = false;
				}
				if (this.props.multi) {
					var updatedValue = this.props.onSelectResetsInput ? '' : this.state.inputValue;
					this.setState({
						focusedIndex: null,
						inputValue: this.handleInputValueChange(updatedValue),
						isOpen: !this.props.closeOnSelect
					}, function () {
						var valueArray = _this4.getValueArray(_this4.props.value);
						if (valueArray.some(function (i) {
							return i[_this4.props.valueKey] === value[_this4.props.valueKey];
						})) {
							_this4.removeValue(value);
						} else {
							_this4.addValue(value);
						}
					});
				} else {
					this.setState({
						inputValue: this.handleInputValueChange(''),
						isOpen: !this.props.closeOnSelect,
						isPseudoFocused: this.state.isFocused
					}, function () {
						_this4.setValue(value);
					});
				}
			}
		}, {
			key: 'addValue',
			value: function addValue(value) {
				var valueArray = this.getValueArray(this.props.value);
				var visibleOptions = this._visibleOptions.filter(function (val) {
					return !val.disabled;
				});
				var lastValueIndex = visibleOptions.indexOf(value);
				this.setValue(valueArray.concat(value));
				if (visibleOptions.length - 1 === lastValueIndex) {
					// the last option was selected; focus the second-last one
					this.focusOption(visibleOptions[lastValueIndex - 1]);
				} else if (visibleOptions.length > lastValueIndex) {
					// focus the option below the selected one
					this.focusOption(visibleOptions[lastValueIndex + 1]);
				}
			}
		}, {
			key: 'popValue',
			value: function popValue() {
				var valueArray = this.getValueArray(this.props.value);
				if (!valueArray.length) return;
				if (valueArray[valueArray.length - 1].clearableValue === false) return;
				this.setValue(this.props.multi ? valueArray.slice(0, valueArray.length - 1) : null);
			}
		}, {
			key: 'removeValue',
			value: function removeValue(value) {
				var _this5 = this;

				var valueArray = this.getValueArray(this.props.value);
				this.setValue(valueArray.filter(function (i) {
					return i[_this5.props.valueKey] !== value[_this5.props.valueKey];
				}));
				this.focus();
			}
		}, {
			key: 'clearValue',
			value: function clearValue(event) {
				// if the event was triggered by a mousedown and not the primary
				// button, ignore it.
				if (event && event.type === 'mousedown' && event.button !== 0) {
					return;
				}
				event.preventDefault();
				this.setValue(this.getResetValue());
				this.setState({
					isOpen: false,
					inputValue: this.handleInputValueChange('')
				}, this.focus);
			}
		}, {
			key: 'getResetValue',
			value: function getResetValue() {
				if (this.props.resetValue !== undefined) {
					return this.props.resetValue;
				} else if (this.props.multi) {
					return [];
				} else {
					return null;
				}
			}
		}, {
			key: 'focusOption',
			value: function focusOption(option) {
				this.setState({
					focusedOption: option
				});
			}
		}, {
			key: 'focusNextOption',
			value: function focusNextOption() {
				this.focusAdjacentOption('next');
			}
		}, {
			key: 'focusPreviousOption',
			value: function focusPreviousOption() {
				this.focusAdjacentOption('previous');
			}
		}, {
			key: 'focusPageUpOption',
			value: function focusPageUpOption() {
				this.focusAdjacentOption('page_up');
			}
		}, {
			key: 'focusPageDownOption',
			value: function focusPageDownOption() {
				this.focusAdjacentOption('page_down');
			}
		}, {
			key: 'focusStartOption',
			value: function focusStartOption() {
				this.focusAdjacentOption('start');
			}
		}, {
			key: 'focusEndOption',
			value: function focusEndOption() {
				this.focusAdjacentOption('end');
			}
		}, {
			key: 'focusAdjacentOption',
			value: function focusAdjacentOption(dir) {
				var options = this._visibleOptions.map(function (option, index) {
					return { option: option, index: index };
				}).filter(function (option) {
					return !option.option.disabled;
				});
				this._scrollToFocusedOptionOnUpdate = true;
				if (!this.state.isOpen) {
					this.setState({
						isOpen: true,
						inputValue: '',
						focusedOption: this._focusedOption || (options.length ? options[dir === 'next' ? 0 : options.length - 1].option : null)
					});
					return;
				}
				if (!options.length) return;
				var focusedIndex = -1;
				for (var i = 0; i < options.length; i++) {
					if (this._focusedOption === options[i].option) {
						focusedIndex = i;
						break;
					}
				}
				if (dir === 'next' && focusedIndex !== -1) {
					focusedIndex = (focusedIndex + 1) % options.length;
				} else if (dir === 'previous') {
					if (focusedIndex > 0) {
						focusedIndex = focusedIndex - 1;
					} else {
						focusedIndex = options.length - 1;
					}
				} else if (dir === 'start') {
					focusedIndex = 0;
				} else if (dir === 'end') {
					focusedIndex = options.length - 1;
				} else if (dir === 'page_up') {
					var potentialIndex = focusedIndex - this.props.pageSize;
					if (potentialIndex < 0) {
						focusedIndex = 0;
					} else {
						focusedIndex = potentialIndex;
					}
				} else if (dir === 'page_down') {
					var potentialIndex = focusedIndex + this.props.pageSize;
					if (potentialIndex > options.length - 1) {
						focusedIndex = options.length - 1;
					} else {
						focusedIndex = potentialIndex;
					}
				}

				if (focusedIndex === -1) {
					focusedIndex = 0;
				}

				this.setState({
					focusedIndex: options[focusedIndex].index,
					focusedOption: options[focusedIndex].option
				});
			}
		}, {
			key: 'getFocusedOption',
			value: function getFocusedOption() {
				return this._focusedOption;
			}
		}, {
			key: 'selectFocusedOption',
			value: function selectFocusedOption() {
				if (this._focusedOption) {
					return this.selectValue(this._focusedOption);
				}
			}
		}, {
			key: 'renderLoading',
			value: function renderLoading() {
				if (!this.props.isLoading) return;
				return _react2.default.createElement(
					'span',
					{ className: 'Select-loading-zone', 'aria-hidden': 'true' },
					_react2.default.createElement('span', { className: 'Select-loading' })
				);
			}
		}, {
			key: 'renderValue',
			value: function renderValue(valueArray, isOpen) {
				var _this6 = this;

				var renderLabel = this.props.valueRenderer || this.getOptionLabel;
				var ValueComponent = this.props.valueComponent;
				if (!valueArray.length) {
					return !this.state.inputValue ? _react2.default.createElement(
						'div',
						{ className: 'Select-placeholder' },
						this.props.placeholder
					) : null;
				}
				var onClick = this.props.onValueClick ? this.handleValueClick : null;
				if (this.props.multi) {
					return valueArray.map(function (value, i) {
						return _react2.default.createElement(
							ValueComponent,
							{
								id: _this6._instancePrefix + '-value-' + i,
								instancePrefix: _this6._instancePrefix,
								disabled: _this6.props.disabled || value.clearableValue === false,
								key: 'value-' + i + '-' + value[_this6.props.valueKey],
								onClick: onClick,
								onRemove: _this6.removeValue,
								value: value
							},
							renderLabel(value, i),
							_react2.default.createElement(
								'span',
								{ className: 'Select-aria-only' },
								'\xA0'
							)
						);
					});
				} else if (!this.state.inputValue) {
					if (isOpen) onClick = null;
					return _react2.default.createElement(
						ValueComponent,
						{
							id: this._instancePrefix + '-value-item',
							disabled: this.props.disabled,
							instancePrefix: this._instancePrefix,
							onClick: onClick,
							value: valueArray[0]
						},
						renderLabel(valueArray[0])
					);
				}
			}
		}, {
			key: 'renderInput',
			value: function renderInput(valueArray, focusedOptionIndex) {
				var _classNames,
				    _this7 = this;

				var className = (0, _classnames2.default)('Select-input', this.props.inputProps.className);
				var isOpen = !!this.state.isOpen;

				var ariaOwns = (0, _classnames2.default)((_classNames = {}, _defineProperty(_classNames, this._instancePrefix + '-list', isOpen), _defineProperty(_classNames, this._instancePrefix + '-backspace-remove-message', this.props.multi && !this.props.disabled && this.state.isFocused && !this.state.inputValue), _classNames));
				var inputProps = _extends({}, this.props.inputProps, {
					role: 'combobox',
					'aria-expanded': '' + isOpen,
					'aria-owns': ariaOwns,
					'aria-haspopup': '' + isOpen,
					'aria-activedescendant': isOpen ? this._instancePrefix + '-option-' + focusedOptionIndex : this._instancePrefix + '-value',
					'aria-describedby': this.props['aria-describedby'],
					'aria-labelledby': this.props['aria-labelledby'],
					'aria-label': this.props['aria-label'],
					className: className,
					tabIndex: this.props.tabIndex,
					onBlur: this.handleInputBlur,
					onChange: this.handleInputChange,
					onFocus: this.handleInputFocus,
					ref: function ref(_ref) {
						return _this7.input = _ref;
					},
					required: this.state.required,
					value: this.state.inputValue
				});

				if (this.props.inputRenderer) {
					return this.props.inputRenderer(inputProps);
				}

				if (this.props.disabled || !this.props.searchable) {
					var _props$inputProps = this.props.inputProps,
					    inputClassName = _props$inputProps.inputClassName,
					    divProps = _objectWithoutProperties(_props$inputProps, ['inputClassName']);

					var _ariaOwns = (0, _classnames2.default)(_defineProperty({}, this._instancePrefix + '-list', isOpen));
					return _react2.default.createElement('div', _extends({}, divProps, {
						role: 'combobox',
						'aria-expanded': isOpen,
						'aria-owns': _ariaOwns,
						'aria-activedescendant': isOpen ? this._instancePrefix + '-option-' + focusedOptionIndex : this._instancePrefix + '-value',
						'aria-labelledby': this.props['aria-labelledby'],
						'aria-label': this.props['aria-label'],
						className: className,
						tabIndex: this.props.tabIndex || 0,
						onBlur: this.handleInputBlur,
						onFocus: this.handleInputFocus,
						ref: function ref(_ref2) {
							return _this7.input = _ref2;
						},
						'aria-disabled': '' + !!this.props.disabled,
						style: { border: 0, width: 1, display: 'inline-block' } }));
				}

				if (this.props.autosize) {
					return _react2.default.createElement(_reactInputAutosize2.default, _extends({ id: this.props.id }, inputProps, { minWidth: '5' }));
				}
				return _react2.default.createElement(
					'div',
					{ className: className, key: 'input-wrap' },
					_react2.default.createElement('input', _extends({ id: this.props.id }, inputProps))
				);
			}
		}, {
			key: 'renderClear',
			value: function renderClear() {
				var valueArray = this.getValueArray(this.props.value);
				if (!this.props.clearable || !valueArray.length || this.props.disabled || this.props.isLoading) return;
				var clear = this.props.clearRenderer();

				return _react2.default.createElement(
					'span',
					{ className: 'Select-clear-zone', title: this.props.multi ? this.props.clearAllText : this.props.clearValueText,
						'aria-label': this.props.multi ? this.props.clearAllText : this.props.clearValueText,
						onMouseDown: this.clearValue,
						onTouchStart: this.handleTouchStart,
						onTouchMove: this.handleTouchMove,
						onTouchEnd: this.handleTouchEndClearValue
					},
					clear
				);
			}
		}, {
			key: 'renderArrow',
			value: function renderArrow() {
				if (!this.props.arrowRenderer) return;

				var onMouseDown = this.handleMouseDownOnArrow;
				var isOpen = this.state.isOpen;
				var arrow = this.props.arrowRenderer({ onMouseDown: onMouseDown, isOpen: isOpen });

				if (!arrow) {
					return null;
				}

				return _react2.default.createElement(
					'span',
					{
						className: 'Select-arrow-zone',
						onMouseDown: onMouseDown
					},
					arrow
				);
			}
		}, {
			key: 'filterOptions',
			value: function filterOptions(excludeOptions) {
				var filterValue = this.state.inputValue;
				var options = this.props.options || [];
				if (this.props.filterOptions) {
					// Maintain backwards compatibility with boolean attribute
					var filterOptions = typeof this.props.filterOptions === 'function' ? this.props.filterOptions : _defaultFilterOptions2.default;

					return filterOptions(options, filterValue, excludeOptions, {
						filterOption: this.props.filterOption,
						ignoreAccents: this.props.ignoreAccents,
						ignoreCase: this.props.ignoreCase,
						labelKey: this.props.labelKey,
						matchPos: this.props.matchPos,
						matchProp: this.props.matchProp,
						valueKey: this.props.valueKey,
						trimFilter: this.props.trimFilter
					});
				} else {
					return options;
				}
			}
		}, {
			key: 'onOptionRef',
			value: function onOptionRef(ref, isFocused) {
				if (isFocused) {
					this.focused = ref;
				}
			}
		}, {
			key: 'renderMenu',
			value: function renderMenu(options, valueArray, focusedOption) {
				if (options && options.length) {
					return this.props.menuRenderer({
						focusedOption: focusedOption,
						focusOption: this.focusOption,
						inputValue: this.state.inputValue,
						instancePrefix: this._instancePrefix,
						labelKey: this.props.labelKey,
						onFocus: this.focusOption,
						onSelect: this.selectValue,
						optionClassName: this.props.optionClassName,
						optionComponent: this.props.optionComponent,
						optionRenderer: this.props.optionRenderer || this.getOptionLabel,
						options: options,
						selectValue: this.selectValue,
						removeValue: this.removeValue,
						valueArray: valueArray,
						valueKey: this.props.valueKey,
						onOptionRef: this.onOptionRef
					});
				} else if (this.props.noResultsText) {
					return _react2.default.createElement(
						'div',
						{ className: 'Select-noresults' },
						this.props.noResultsText
					);
				} else {
					return null;
				}
			}
		}, {
			key: 'renderHiddenField',
			value: function renderHiddenField(valueArray) {
				var _this8 = this;

				if (!this.props.name) return;
				if (this.props.joinValues) {
					var value = valueArray.map(function (i) {
						return stringifyValue(i[_this8.props.valueKey]);
					}).join(this.props.delimiter);
					return _react2.default.createElement('input', {
						type: 'hidden',
						ref: function ref(_ref3) {
							return _this8.value = _ref3;
						},
						name: this.props.name,
						value: value,
						disabled: this.props.disabled });
				}
				return valueArray.map(function (item, index) {
					return _react2.default.createElement('input', { key: 'hidden.' + index,
						type: 'hidden',
						ref: 'value' + index,
						name: _this8.props.name,
						value: stringifyValue(item[_this8.props.valueKey]),
						disabled: _this8.props.disabled });
				});
			}
		}, {
			key: 'getFocusableOptionIndex',
			value: function getFocusableOptionIndex(selectedOption) {
				var options = this._visibleOptions;
				if (!options.length) return null;

				var valueKey = this.props.valueKey;
				var focusedOption = this.state.focusedOption || selectedOption;
				if (focusedOption && !focusedOption.disabled) {
					var focusedOptionIndex = -1;
					options.some(function (option, index) {
						var isOptionEqual = option[valueKey] === focusedOption[valueKey];
						if (isOptionEqual) {
							focusedOptionIndex = index;
						}
						return isOptionEqual;
					});
					if (focusedOptionIndex !== -1) {
						return focusedOptionIndex;
					}
				}

				for (var i = 0; i < options.length; i++) {
					if (!options[i].disabled) return i;
				}
				return null;
			}
		}, {
			key: 'renderOuter',
			value: function renderOuter(options, valueArray, focusedOption) {
				var _this9 = this;

				var menu = this.renderMenu(options, valueArray, focusedOption);
				if (!menu) {
					return null;
				}

				return _react2.default.createElement(
					'div',
					{ ref: function ref(_ref5) {
							return _this9.menuContainer = _ref5;
						}, className: 'Select-menu-outer', style: this.props.menuContainerStyle },
					_react2.default.createElement(
						'div',
						{ ref: function ref(_ref4) {
								return _this9.menu = _ref4;
							}, role: 'listbox', tabIndex: -1, className: 'Select-menu', id: this._instancePrefix + '-list',
							style: this.props.menuStyle,
							onScroll: this.handleMenuScroll,
							onMouseDown: this.handleMouseDownOnMenu },
						menu
					)
				);
			}
		}, {
			key: 'render',
			value: function render() {
				var _this10 = this;

				var valueArray = this.getValueArray(this.props.value);
				var options = this._visibleOptions = this.filterOptions(this.props.multi && this.props.removeSelected ? valueArray : null);
				var isOpen = this.state.isOpen;
				if (this.props.multi && !options.length && valueArray.length && !this.state.inputValue) isOpen = false;
				var focusedOptionIndex = this.getFocusableOptionIndex(valueArray[0]);

				var focusedOption = null;
				if (focusedOptionIndex !== null) {
					focusedOption = this._focusedOption = options[focusedOptionIndex];
				} else {
					focusedOption = this._focusedOption = null;
				}
				var className = (0, _classnames2.default)('Select', this.props.className, {
					'Select--multi': this.props.multi,
					'Select--single': !this.props.multi,
					'is-clearable': this.props.clearable,
					'is-disabled': this.props.disabled,
					'is-focused': this.state.isFocused,
					'is-loading': this.props.isLoading,
					'is-open': isOpen,
					'is-pseudo-focused': this.state.isPseudoFocused,
					'is-searchable': this.props.searchable,
					'has-value': valueArray.length,
					'Select--rtl': this.props.rtl
				});

				var removeMessage = null;
				if (this.props.multi && !this.props.disabled && valueArray.length && !this.state.inputValue && this.state.isFocused && this.props.backspaceRemoves) {
					removeMessage = _react2.default.createElement(
						'span',
						{ id: this._instancePrefix + '-backspace-remove-message', className: 'Select-aria-only', 'aria-live': 'assertive' },
						this.props.backspaceToRemoveMessage.replace('{label}', valueArray[valueArray.length - 1][this.props.labelKey])
					);
				}

				return _react2.default.createElement(
					'div',
					{ ref: function ref(_ref7) {
							return _this10.wrapper = _ref7;
						},
						className: className,
						style: this.props.wrapperStyle },
					this.renderHiddenField(valueArray),
					_react2.default.createElement(
						'div',
						{ ref: function ref(_ref6) {
								return _this10.control = _ref6;
							},
							className: 'Select-control',
							style: this.props.style,
							onKeyDown: this.handleKeyDown,
							onMouseDown: this.handleMouseDown,
							onTouchEnd: this.handleTouchEnd,
							onTouchStart: this.handleTouchStart,
							onTouchMove: this.handleTouchMove
						},
						_react2.default.createElement(
							'span',
							{ className: 'Select-multi-value-wrapper', id: this._instancePrefix + '-value' },
							this.renderValue(valueArray, isOpen),
							this.renderInput(valueArray, focusedOptionIndex)
						),
						removeMessage,
						this.renderLoading(),
						this.renderClear(),
						this.renderArrow()
					),
					isOpen ? this.renderOuter(options, valueArray, focusedOption) : null
				);
			}
		}]);

		return Select;
	}(_react2.default.Component);

	;

	Select.propTypes = {
		'aria-describedby': _propTypes2.default.string, // html id(s) of element(s) that should be used to describe this input (for assistive tech)
		'aria-label': _propTypes2.default.string, // aria label (for assistive tech)
		'aria-labelledby': _propTypes2.default.string, // html id of an element that should be used as the label (for assistive tech)
		arrowRenderer: _propTypes2.default.func, // create the drop-down caret element
		autoBlur: _propTypes2.default.bool, // automatically blur the component when an option is selected
		autoFocus: _propTypes2.default.bool, // autofocus the component on mount
		autofocus: _propTypes2.default.bool, // deprecated; use autoFocus instead
		autosize: _propTypes2.default.bool, // whether to enable autosizing or not
		backspaceRemoves: _propTypes2.default.bool, // whether backspace removes an item if there is no text input
		backspaceToRemoveMessage: _propTypes2.default.string, // message to use for screenreaders to press backspace to remove the current item - {label} is replaced with the item label
		className: _propTypes2.default.string, // className for the outer element
		clearAllText: stringOrNode, // title for the "clear" control when multi: true
		clearRenderer: _propTypes2.default.func, // create clearable x element
		clearValueText: stringOrNode, // title for the "clear" control
		clearable: _propTypes2.default.bool, // should it be possible to reset value
		closeOnSelect: _propTypes2.default.bool, // whether to close the menu when a value is selected
		deleteRemoves: _propTypes2.default.bool, // whether delete removes an item if there is no text input
		delimiter: _propTypes2.default.string, // delimiter to use to join multiple values for the hidden field value
		disabled: _propTypes2.default.bool, // whether the Select is disabled or not
		escapeClearsValue: _propTypes2.default.bool, // whether escape clears the value when the menu is closed
		filterOption: _propTypes2.default.func, // method to filter a single option (option, filterString)
		filterOptions: _propTypes2.default.any, // boolean to enable default filtering or function to filter the options array ([options], filterString, [values])
		id: _propTypes2.default.string, // html id to set on the input element for accessibility or tests
		ignoreAccents: _propTypes2.default.bool, // whether to strip diacritics when filtering
		ignoreCase: _propTypes2.default.bool, // whether to perform case-insensitive filtering
		inputProps: _propTypes2.default.object, // custom attributes for the Input
		inputRenderer: _propTypes2.default.func, // returns a custom input component
		instanceId: _propTypes2.default.string, // set the components instanceId
		isLoading: _propTypes2.default.bool, // whether the Select is loading externally or not (such as options being loaded)
		joinValues: _propTypes2.default.bool, // joins multiple values into a single form field with the delimiter (legacy mode)
		labelKey: _propTypes2.default.string, // path of the label value in option objects
		matchPos: _propTypes2.default.string, // (any|start) match the start or entire string when filtering
		matchProp: _propTypes2.default.string, // (any|label|value) which option property to filter on
		menuBuffer: _propTypes2.default.number, // optional buffer (in px) between the bottom of the viewport and the bottom of the menu
		menuContainerStyle: _propTypes2.default.object, // optional style to apply to the menu container
		menuRenderer: _propTypes2.default.func, // renders a custom menu with options
		menuStyle: _propTypes2.default.object, // optional style to apply to the menu
		multi: _propTypes2.default.bool, // multi-value input
		name: _propTypes2.default.string, // generates a hidden <input /> tag with this field name for html forms
		noResultsText: stringOrNode, // placeholder displayed when there are no matching search results
		onBlur: _propTypes2.default.func, // onBlur handler: function (event) {}
		onBlurResetsInput: _propTypes2.default.bool, // whether input is cleared on blur
		onChange: _propTypes2.default.func, // onChange handler: function (newValue) {}
		onClose: _propTypes2.default.func, // fires when the menu is closed
		onCloseResetsInput: _propTypes2.default.bool, // whether input is cleared when menu is closed through the arrow
		onFocus: _propTypes2.default.func, // onFocus handler: function (event) {}
		onInputChange: _propTypes2.default.func, // onInputChange handler: function (inputValue) {}
		onInputKeyDown: _propTypes2.default.func, // input keyDown handler: function (event) {}
		onMenuScrollToBottom: _propTypes2.default.func, // fires when the menu is scrolled to the bottom; can be used to paginate options
		onOpen: _propTypes2.default.func, // fires when the menu is opened
		onSelectResetsInput: _propTypes2.default.bool, // whether input is cleared on select (works only for multiselect)
		onValueClick: _propTypes2.default.func, // onClick handler for value labels: function (value, event) {}
		openOnClick: _propTypes2.default.bool, // boolean to control opening the menu when the control is clicked
		openOnFocus: _propTypes2.default.bool, // always open options menu on focus
		optionClassName: _propTypes2.default.string, // additional class(es) to apply to the <Option /> elements
		optionComponent: _propTypes2.default.func, // option component to render in dropdown
		optionRenderer: _propTypes2.default.func, // optionRenderer: function (option) {}
		options: _propTypes2.default.array, // array of options
		pageSize: _propTypes2.default.number, // number of entries to page when using page up/down keys
		placeholder: stringOrNode, // field placeholder, displayed when there's no value
		removeSelected: _propTypes2.default.bool, // whether the selected option is removed from the dropdown on multi selects
		required: _propTypes2.default.bool, // applies HTML5 required attribute when needed
		resetValue: _propTypes2.default.any, // value to use when you clear the control
		rtl: _propTypes2.default.bool, // set to true in order to use react-select in right-to-left direction
		scrollMenuIntoView: _propTypes2.default.bool, // boolean to enable the viewport to shift so that the full menu fully visible when engaged
		searchable: _propTypes2.default.bool, // whether to enable searching feature or not
		simpleValue: _propTypes2.default.bool, // pass the value to onChange as a simple value (legacy pre 1.0 mode), defaults to false
		style: _propTypes2.default.object, // optional style to apply to the control
		tabIndex: stringOrNumber, // optional tab index of the control
		tabSelectsValue: _propTypes2.default.bool, // whether to treat tabbing out while focused to be value selection
		trimFilter: _propTypes2.default.bool, // whether to trim whitespace around filter value
		value: _propTypes2.default.any, // initial field value
		valueComponent: _propTypes2.default.func, // value component to render
		valueKey: _propTypes2.default.string, // path of the label value in option objects
		valueRenderer: _propTypes2.default.func, // valueRenderer: function (option) {}
		wrapperStyle: _propTypes2.default.object // optional style to apply to the component wrapper
	};

	Select.defaultProps = {
		arrowRenderer: _defaultArrowRenderer2.default,
		autosize: true,
		backspaceRemoves: true,
		backspaceToRemoveMessage: 'Press backspace to remove {label}',
		clearable: true,
		clearAllText: 'Clear all',
		clearRenderer: _defaultClearRenderer2.default,
		clearValueText: 'Clear value',
		closeOnSelect: true,
		deleteRemoves: true,
		delimiter: ',',
		disabled: false,
		escapeClearsValue: true,
		filterOptions: _defaultFilterOptions2.default,
		ignoreAccents: true,
		ignoreCase: true,
		inputProps: {},
		isLoading: false,
		joinValues: false,
		labelKey: 'label',
		matchPos: 'any',
		matchProp: 'any',
		menuBuffer: 0,
		menuRenderer: _defaultMenuRenderer2.default,
		multi: false,
		noResultsText: 'No results found',
		onBlurResetsInput: true,
		onSelectResetsInput: true,
		onCloseResetsInput: true,
		openOnClick: true,
		optionComponent: _Option2.default,
		pageSize: 5,
		placeholder: 'Select...',
		removeSelected: true,
		required: false,
		rtl: false,
		scrollMenuIntoView: true,
		searchable: true,
		simpleValue: false,
		tabSelectsValue: true,
		trimFilter: true,
		valueComponent: _Value2.default,
		valueKey: 'value'
	};

	exports.default = Select;

/***/ }),
/* 49 */
46,
/* 50 */
[1588, 431, 432, 433, 434, 435],
/* 51 */
[1613, 11],
/* 52 */
[1622, 162],
/* 53 */
[1664, 428],
/* 54 */
[1746, 20],
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	var isSymbol = __webpack_require__(86);

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */
	function toKey(value) {
	  if (typeof value == 'string' || isSymbol(value)) {
	    return value;
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	module.exports = toKey;


/***/ }),
/* 56 */,
/* 57 */
33,
/* 58 */,
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	__webpack_require__(265);

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _reactSelect = __webpack_require__(365);

	var _reactSelect2 = _interopRequireDefault(_reactSelect);

	var _reactDataGrid = __webpack_require__(7);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var isEmptyArray = _reactDataGrid.utils.isEmptyArray;
	var ExcelColumn = _reactDataGrid.shapes.ExcelColumn;

	var AutoCompleteFilter = function (_React$Component) {
	  _inherits(AutoCompleteFilter, _React$Component);

	  function AutoCompleteFilter(props) {
	    _classCallCheck(this, AutoCompleteFilter);

	    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	    _this.getOptions = _this.getOptions.bind(_this);
	    _this.handleChange = _this.handleChange.bind(_this);
	    _this.filterValues = _this.filterValues.bind(_this);
	    _this.state = { options: _this.getOptions(), rawValue: '', placeholder: 'Search' };
	    return _this;
	  }

	  AutoCompleteFilter.prototype.componentWillReceiveProps = function componentWillReceiveProps(newProps) {
	    this.setState({ options: this.getOptions(newProps) });
	  };

	  AutoCompleteFilter.prototype.getOptions = function getOptions(newProps) {
	    var props = newProps || this.props;
	    var options = props.getValidFilterValues(props.column.key);
	    options = options.map(function (o) {
	      if (typeof o === 'string') {
	        return { value: o, label: o };
	      }
	      return o;
	    });
	    return options;
	  };

	  AutoCompleteFilter.prototype.columnValueContainsSearchTerms = function columnValueContainsSearchTerms(columnValue, filterTermValue) {
	    if (columnValue !== undefined && filterTermValue !== undefined) {
	      var strColumnValue = columnValue.toString();
	      var strFilterTermValue = filterTermValue.toString();
	      var checkValueIndex = strColumnValue.trim().toLowerCase().indexOf(strFilterTermValue.trim().toLowerCase());
	      return checkValueIndex !== -1 && (checkValueIndex !== 0 || strColumnValue === strFilterTermValue);
	    }
	    return false;
	  };

	  AutoCompleteFilter.prototype.filterValues = function filterValues(row, columnFilter, columnKey) {
	    var _this2 = this;

	    var include = true;
	    if (columnFilter === null) {
	      include = false;
	    } else if (columnFilter.filterTerm && !isEmptyArray(columnFilter.filterTerm)) {
	      if (columnFilter.filterTerm.length) {
	        include = columnFilter.filterTerm.some(function (filterTerm) {
	          return _this2.columnValueContainsSearchTerms(row[columnKey], filterTerm.value) === true;
	        });
	      } else {
	        include = this.columnValueContainsSearchTerms(row[columnKey], columnFilter.filterTerm.value);
	      }
	    }
	    return include;
	  };

	  AutoCompleteFilter.prototype.handleChange = function handleChange(value) {
	    var filters = value;
	    this.setState({ filters: filters });
	    this.props.onChange({ filterTerm: filters, column: this.props.column, rawValue: value, filterValues: this.filterValues });
	  };

	  AutoCompleteFilter.prototype.render = function render() {
	    return _react2['default'].createElement(_reactSelect2['default'], {
	      autosize: false,
	      name: 'filter-' + this.props.column.key,
	      options: this.state.options,
	      placeholder: this.state.placeholder,
	      onChange: this.handleChange,
	      escapeClearsValue: true,
	      multi: this.props.multiSelection !== undefined && this.props.multiSelection !== null ? this.props.multiSelection : true,
	      value: this.state.filters });
	  };

	  return AutoCompleteFilter;
	}(_react2['default'].Component);

	AutoCompleteFilter.propTypes = {
	  onChange: _propTypes2['default'].func.isRequired,
	  column: _propTypes2['default'].shape(ExcelColumn),
	  getValidFilterValues: _propTypes2['default'].func,
	  multiSelection: _propTypes2['default'].bool
	};

	exports['default'] = AutoCompleteFilter;

/***/ }),
/* 60 */,
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */
/***/ (function(module, exports) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = isDisposable;

	function isDisposable(obj) {
	  return Boolean(obj && typeof obj.dispose === 'function');
	}

	module.exports = exports['default'];

/***/ }),
/* 66 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2015, Yahoo! Inc.
	 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
	 */
	'use strict';

	var REACT_STATICS = {
	    childContextTypes: true,
	    contextTypes: true,
	    defaultProps: true,
	    displayName: true,
	    getDefaultProps: true,
	    mixins: true,
	    propTypes: true,
	    type: true
	};

	var KNOWN_STATICS = {
	  name: true,
	  length: true,
	  prototype: true,
	  caller: true,
	  callee: true,
	  arguments: true,
	  arity: true
	};

	var defineProperty = Object.defineProperty;
	var getOwnPropertyNames = Object.getOwnPropertyNames;
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
	var getPrototypeOf = Object.getPrototypeOf;
	var objectPrototype = getPrototypeOf && getPrototypeOf(Object);

	module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
	    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components

	        if (objectPrototype) {
	            var inheritedComponent = getPrototypeOf(sourceComponent);
	            if (inheritedComponent && inheritedComponent !== objectPrototype) {
	                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
	            }
	        }

	        var keys = getOwnPropertyNames(sourceComponent);

	        if (getOwnPropertySymbols) {
	            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
	        }

	        for (var i = 0; i < keys.length; ++i) {
	            var key = keys[i];
	            if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {
	                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
	                try { // Avoid failures from read-only properties
	                    defineProperty(targetComponent, key, descriptor);
	                } catch (e) {}
	            }
	        }

	        return targetComponent;
	    }

	    return targetComponent;
	};


/***/ }),
/* 67 */
[1607, 117, 324, 325],
/* 68 */
[1613, 27],
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

	var baseIndexOf = __webpack_require__(280);

	/**
	 * A specialized version of `_.includes` for arrays without support for
	 * specifying an index to search from.
	 *
	 * @private
	 * @param {Array} [array] The array to inspect.
	 * @param {*} target The value to search for.
	 * @returns {boolean} Returns `true` if `target` is found, else `false`.
	 */
	function arrayIncludes(array, value) {
	  var length = array == null ? 0 : array.length;
	  return !!length && baseIndexOf(array, value, 0) > -1;
	}

	module.exports = arrayIncludes;


/***/ }),
/* 70 */
/***/ (function(module, exports) {

	/**
	 * This function is like `arrayIncludes` except that it accepts a comparator.
	 *
	 * @private
	 * @param {Array} [array] The array to inspect.
	 * @param {*} target The value to search for.
	 * @param {Function} comparator The comparator invoked per element.
	 * @returns {boolean} Returns `true` if `target` is found, else `false`.
	 */
	function arrayIncludesWith(array, value, comparator) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (comparator(value, array[index])) {
	      return true;
	    }
	  }
	  return false;
	}

	module.exports = arrayIncludesWith;


/***/ }),
/* 71 */
/***/ (function(module, exports) {

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}

	module.exports = arrayMap;


/***/ }),
/* 72 */
/***/ (function(module, exports) {

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	module.exports = baseUnary;


/***/ }),
/* 73 */
/***/ (function(module, exports) {

	/**
	 * Checks if a `cache` value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function cacheHas(cache, key) {
	  return cache.has(key);
	}

	module.exports = cacheHas;


/***/ }),
/* 74 */
[1768, 129, 130],
/* 75 */,
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _actions = __webpack_require__(23);

	var _helpers = __webpack_require__(24);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var GlobalEventListener = function GlobalEventListener() {
	    var _this = this;

	    _classCallCheck(this, GlobalEventListener);

	    this.handleShowEvent = function (event) {
	        for (var id in _this.callbacks) {
	            if ((0, _helpers.hasOwnProp)(_this.callbacks, id)) _this.callbacks[id].show(event);
	        }
	    };

	    this.handleHideEvent = function (event) {
	        for (var id in _this.callbacks) {
	            if ((0, _helpers.hasOwnProp)(_this.callbacks, id)) _this.callbacks[id].hide(event);
	        }
	    };

	    this.register = function (showCallback, hideCallback) {
	        var id = (0, _helpers.uniqueId)();

	        _this.callbacks[id] = {
	            show: showCallback,
	            hide: hideCallback
	        };

	        return id;
	    };

	    this.unregister = function (id) {
	        if (id && _this.callbacks[id]) {
	            delete _this.callbacks[id];
	        }
	    };

	    this.callbacks = {};

	    if (_helpers.canUseDOM) {
	        window.addEventListener(_actions.MENU_SHOW, this.handleShowEvent);
	        window.addEventListener(_actions.MENU_HIDE, this.handleHideEvent);
	    }
	};

	exports.default = new GlobalEventListener();

/***/ }),
/* 77 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var FILE = exports.FILE = '__NATIVE_FILE__';
	var URL = exports.URL = '__NATIVE_URL__';
	var TEXT = exports.TEXT = '__NATIVE_TEXT__';

/***/ }),
/* 78 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = shallowEqual;
	function shallowEqual(objA, objB) {
		if (objA === objB) {
			return true;
		}

		var keysA = Object.keys(objA);
		var keysB = Object.keys(objB);

		if (keysA.length !== keysB.length) {
			return false;
		}

		// Test for A's keys different from B.
		var hasOwn = Object.prototype.hasOwnProperty;
		for (var i = 0; i < keysA.length; i += 1) {
			if (!hasOwn.call(objB, keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
				return false;
			}

			var valA = objA[keysA[i]];
			var valB = objB[keysA[i]];

			if (valA !== valB) {
				return false;
			}
		}

		return true;
	}

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _stripDiacritics = __webpack_require__(151);

	var _stripDiacritics2 = _interopRequireDefault(_stripDiacritics);

	var _trim = __webpack_require__(366);

	var _trim2 = _interopRequireDefault(_trim);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function filterOptions(options, filterValue, excludeOptions, props) {
		var _this = this;

		if (props.ignoreAccents) {
			filterValue = (0, _stripDiacritics2.default)(filterValue);
		}

		if (props.ignoreCase) {
			filterValue = filterValue.toLowerCase();
		}

		if (props.trimFilter) {
			filterValue = (0, _trim2.default)(filterValue);
		}

		if (excludeOptions) excludeOptions = excludeOptions.map(function (i) {
			return i[props.valueKey];
		});

		return options.filter(function (option) {
			if (excludeOptions && excludeOptions.indexOf(option[props.valueKey]) > -1) return false;
			if (props.filterOption) return props.filterOption.call(_this, option, filterValue);
			if (!filterValue) return true;
			var valueTest = String(option[props.valueKey]);
			var labelTest = String(option[props.labelKey]);

			if (props.ignoreAccents) {
				if (props.matchProp !== 'label') valueTest = (0, _stripDiacritics2.default)(valueTest);
				if (props.matchProp !== 'value') labelTest = (0, _stripDiacritics2.default)(labelTest);
			}

			if (props.ignoreCase) {
				if (props.matchProp !== 'label') valueTest = valueTest.toLowerCase();
				if (props.matchProp !== 'value') labelTest = labelTest.toLowerCase();
			}
			return props.matchPos === 'start' ? props.matchProp !== 'label' && valueTest.substr(0, filterValue.length) === filterValue || props.matchProp !== 'value' && labelTest.substr(0, filterValue.length) === filterValue : props.matchProp !== 'label' && valueTest.indexOf(filterValue) >= 0 || props.matchProp !== 'value' && labelTest.indexOf(filterValue) >= 0;
		});
	}

	exports.default = filterOptions;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _classnames = __webpack_require__(49);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function menuRenderer(_ref) {
		var focusedOption = _ref.focusedOption,
		    focusOption = _ref.focusOption,
		    inputValue = _ref.inputValue,
		    instancePrefix = _ref.instancePrefix,
		    labelKey = _ref.labelKey,
		    onFocus = _ref.onFocus,
		    onOptionRef = _ref.onOptionRef,
		    onSelect = _ref.onSelect,
		    optionClassName = _ref.optionClassName,
		    optionComponent = _ref.optionComponent,
		    optionRenderer = _ref.optionRenderer,
		    options = _ref.options,
		    removeValue = _ref.removeValue,
		    selectValue = _ref.selectValue,
		    valueArray = _ref.valueArray,
		    valueKey = _ref.valueKey;

		var Option = optionComponent;

		return options.map(function (option, i) {
			var isSelected = valueArray && valueArray.some(function (x) {
				return x[valueKey] == option[valueKey];
			});
			var isFocused = option === focusedOption;
			var optionClass = (0, _classnames2.default)(optionClassName, {
				'Select-option': true,
				'is-selected': isSelected,
				'is-focused': isFocused,
				'is-disabled': option.disabled
			});

			return _react2.default.createElement(
				Option,
				{
					className: optionClass,
					focusOption: focusOption,
					inputValue: inputValue,
					instancePrefix: instancePrefix,
					isDisabled: option.disabled,
					isFocused: isFocused,
					isSelected: isSelected,
					key: 'option-' + i + '-' + option[valueKey],
					onFocus: onFocus,
					onSelect: onSelect,
					option: option,
					optionIndex: i,
					ref: function ref(_ref2) {
						onOptionRef(_ref2, isFocused);
					},
					removeValue: removeValue,
					selectValue: selectValue
				},
				optionRenderer(option, i, inputValue)
			);
		});
	}

	exports.default = menuRenderer;

/***/ }),
/* 81 */
[1590, 20, 11],
/* 82 */
[1596, 436, 437, 438, 439, 440],
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

	var isArray = __webpack_require__(12),
	    isSymbol = __webpack_require__(86);

	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/;

	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  if (isArray(value)) {
	    return false;
	  }
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	      value == null || isSymbol(value)) {
	    return true;
	  }
	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	    (object != null && value in Object(object));
	}

	module.exports = isKey;


/***/ }),
/* 84 */
/***/ (function(module, exports) {

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	module.exports = isLength;


/***/ }),
/* 85 */
28,
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(31),
	    isObjectLike = __webpack_require__(32);

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && baseGetTag(value) == symbolTag);
	}

	module.exports = isSymbol;


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

	var arrayLikeKeys = __webpack_require__(383),
	    baseKeys = __webpack_require__(400),
	    isArrayLike = __webpack_require__(164);

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}

	module.exports = keys;


/***/ }),
/* 88 */,
/* 89 */,
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.8.3
	//     http://underscorejs.org
	//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	//     Underscore may be freely distributed under the MIT license.

	(function() {

	  // Baseline setup
	  // --------------

	  // Establish the root object, `window` in the browser, or `exports` on the server.
	  var root = this;

	  // Save the previous value of the `_` variable.
	  var previousUnderscore = root._;

	  // Save bytes in the minified (but not gzipped) version:
	  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

	  // Create quick reference variables for speed access to core prototypes.
	  var
	    push             = ArrayProto.push,
	    slice            = ArrayProto.slice,
	    toString         = ObjProto.toString,
	    hasOwnProperty   = ObjProto.hasOwnProperty;

	  // All **ECMAScript 5** native function implementations that we hope to use
	  // are declared here.
	  var
	    nativeIsArray      = Array.isArray,
	    nativeKeys         = Object.keys,
	    nativeBind         = FuncProto.bind,
	    nativeCreate       = Object.create;

	  // Naked function reference for surrogate-prototype-swapping.
	  var Ctor = function(){};

	  // Create a safe reference to the Underscore object for use below.
	  var _ = function(obj) {
	    if (obj instanceof _) return obj;
	    if (!(this instanceof _)) return new _(obj);
	    this._wrapped = obj;
	  };

	  // Export the Underscore object for **Node.js**, with
	  // backwards-compatibility for the old `require()` API. If we're in
	  // the browser, add `_` as a global object.
	  if (true) {
	    if (typeof module !== 'undefined' && module.exports) {
	      exports = module.exports = _;
	    }
	    exports._ = _;
	  } else {
	    root._ = _;
	  }

	  // Current version.
	  _.VERSION = '1.8.3';

	  // Internal function that returns an efficient (for current engines) version
	  // of the passed-in callback, to be repeatedly applied in other Underscore
	  // functions.
	  var optimizeCb = function(func, context, argCount) {
	    if (context === void 0) return func;
	    switch (argCount == null ? 3 : argCount) {
	      case 1: return function(value) {
	        return func.call(context, value);
	      };
	      case 2: return function(value, other) {
	        return func.call(context, value, other);
	      };
	      case 3: return function(value, index, collection) {
	        return func.call(context, value, index, collection);
	      };
	      case 4: return function(accumulator, value, index, collection) {
	        return func.call(context, accumulator, value, index, collection);
	      };
	    }
	    return function() {
	      return func.apply(context, arguments);
	    };
	  };

	  // A mostly-internal function to generate callbacks that can be applied
	  // to each element in a collection, returning the desired result â€” either
	  // identity, an arbitrary callback, a property matcher, or a property accessor.
	  var cb = function(value, context, argCount) {
	    if (value == null) return _.identity;
	    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
	    if (_.isObject(value)) return _.matcher(value);
	    return _.property(value);
	  };
	  _.iteratee = function(value, context) {
	    return cb(value, context, Infinity);
	  };

	  // An internal function for creating assigner functions.
	  var createAssigner = function(keysFunc, undefinedOnly) {
	    return function(obj) {
	      var length = arguments.length;
	      if (length < 2 || obj == null) return obj;
	      for (var index = 1; index < length; index++) {
	        var source = arguments[index],
	            keys = keysFunc(source),
	            l = keys.length;
	        for (var i = 0; i < l; i++) {
	          var key = keys[i];
	          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
	        }
	      }
	      return obj;
	    };
	  };

	  // An internal function for creating a new object that inherits from another.
	  var baseCreate = function(prototype) {
	    if (!_.isObject(prototype)) return {};
	    if (nativeCreate) return nativeCreate(prototype);
	    Ctor.prototype = prototype;
	    var result = new Ctor;
	    Ctor.prototype = null;
	    return result;
	  };

	  var property = function(key) {
	    return function(obj) {
	      return obj == null ? void 0 : obj[key];
	    };
	  };

	  // Helper for collection methods to determine whether a collection
	  // should be iterated as an array or as an object
	  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
	  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
	  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
	  var getLength = property('length');
	  var isArrayLike = function(collection) {
	    var length = getLength(collection);
	    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
	  };

	  // Collection Functions
	  // --------------------

	  // The cornerstone, an `each` implementation, aka `forEach`.
	  // Handles raw objects in addition to array-likes. Treats all
	  // sparse array-likes as if they were dense.
	  _.each = _.forEach = function(obj, iteratee, context) {
	    iteratee = optimizeCb(iteratee, context);
	    var i, length;
	    if (isArrayLike(obj)) {
	      for (i = 0, length = obj.length; i < length; i++) {
	        iteratee(obj[i], i, obj);
	      }
	    } else {
	      var keys = _.keys(obj);
	      for (i = 0, length = keys.length; i < length; i++) {
	        iteratee(obj[keys[i]], keys[i], obj);
	      }
	    }
	    return obj;
	  };

	  // Return the results of applying the iteratee to each element.
	  _.map = _.collect = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length,
	        results = Array(length);
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      results[index] = iteratee(obj[currentKey], currentKey, obj);
	    }
	    return results;
	  };

	  // Create a reducing function iterating left or right.
	  function createReduce(dir) {
	    // Optimized iterator function as using arguments.length
	    // in the main function will deoptimize the, see #1991.
	    function iterator(obj, iteratee, memo, keys, index, length) {
	      for (; index >= 0 && index < length; index += dir) {
	        var currentKey = keys ? keys[index] : index;
	        memo = iteratee(memo, obj[currentKey], currentKey, obj);
	      }
	      return memo;
	    }

	    return function(obj, iteratee, memo, context) {
	      iteratee = optimizeCb(iteratee, context, 4);
	      var keys = !isArrayLike(obj) && _.keys(obj),
	          length = (keys || obj).length,
	          index = dir > 0 ? 0 : length - 1;
	      // Determine the initial value if none is provided.
	      if (arguments.length < 3) {
	        memo = obj[keys ? keys[index] : index];
	        index += dir;
	      }
	      return iterator(obj, iteratee, memo, keys, index, length);
	    };
	  }

	  // **Reduce** builds up a single result from a list of values, aka `inject`,
	  // or `foldl`.
	  _.reduce = _.foldl = _.inject = createReduce(1);

	  // The right-associative version of reduce, also known as `foldr`.
	  _.reduceRight = _.foldr = createReduce(-1);

	  // Return the first value which passes a truth test. Aliased as `detect`.
	  _.find = _.detect = function(obj, predicate, context) {
	    var key;
	    if (isArrayLike(obj)) {
	      key = _.findIndex(obj, predicate, context);
	    } else {
	      key = _.findKey(obj, predicate, context);
	    }
	    if (key !== void 0 && key !== -1) return obj[key];
	  };

	  // Return all the elements that pass a truth test.
	  // Aliased as `select`.
	  _.filter = _.select = function(obj, predicate, context) {
	    var results = [];
	    predicate = cb(predicate, context);
	    _.each(obj, function(value, index, list) {
	      if (predicate(value, index, list)) results.push(value);
	    });
	    return results;
	  };

	  // Return all the elements for which a truth test fails.
	  _.reject = function(obj, predicate, context) {
	    return _.filter(obj, _.negate(cb(predicate)), context);
	  };

	  // Determine whether all of the elements match a truth test.
	  // Aliased as `all`.
	  _.every = _.all = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (!predicate(obj[currentKey], currentKey, obj)) return false;
	    }
	    return true;
	  };

	  // Determine if at least one element in the object matches a truth test.
	  // Aliased as `any`.
	  _.some = _.any = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (predicate(obj[currentKey], currentKey, obj)) return true;
	    }
	    return false;
	  };

	  // Determine if the array or object contains a given item (using `===`).
	  // Aliased as `includes` and `include`.
	  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
	    if (!isArrayLike(obj)) obj = _.values(obj);
	    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
	    return _.indexOf(obj, item, fromIndex) >= 0;
	  };

	  // Invoke a method (with arguments) on every item in a collection.
	  _.invoke = function(obj, method) {
	    var args = slice.call(arguments, 2);
	    var isFunc = _.isFunction(method);
	    return _.map(obj, function(value) {
	      var func = isFunc ? method : value[method];
	      return func == null ? func : func.apply(value, args);
	    });
	  };

	  // Convenience version of a common use case of `map`: fetching a property.
	  _.pluck = function(obj, key) {
	    return _.map(obj, _.property(key));
	  };

	  // Convenience version of a common use case of `filter`: selecting only objects
	  // containing specific `key:value` pairs.
	  _.where = function(obj, attrs) {
	    return _.filter(obj, _.matcher(attrs));
	  };

	  // Convenience version of a common use case of `find`: getting the first object
	  // containing specific `key:value` pairs.
	  _.findWhere = function(obj, attrs) {
	    return _.find(obj, _.matcher(attrs));
	  };

	  // Return the maximum element (or element-based computation).
	  _.max = function(obj, iteratee, context) {
	    var result = -Infinity, lastComputed = -Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value > result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Return the minimum element (or element-based computation).
	  _.min = function(obj, iteratee, context) {
	    var result = Infinity, lastComputed = Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value < result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed < lastComputed || computed === Infinity && result === Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Shuffle a collection, using the modern version of the
	  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisherâ€“Yates_shuffle).
	  _.shuffle = function(obj) {
	    var set = isArrayLike(obj) ? obj : _.values(obj);
	    var length = set.length;
	    var shuffled = Array(length);
	    for (var index = 0, rand; index < length; index++) {
	      rand = _.random(0, index);
	      if (rand !== index) shuffled[index] = shuffled[rand];
	      shuffled[rand] = set[index];
	    }
	    return shuffled;
	  };

	  // Sample **n** random values from a collection.
	  // If **n** is not specified, returns a single random element.
	  // The internal `guard` argument allows it to work with `map`.
	  _.sample = function(obj, n, guard) {
	    if (n == null || guard) {
	      if (!isArrayLike(obj)) obj = _.values(obj);
	      return obj[_.random(obj.length - 1)];
	    }
	    return _.shuffle(obj).slice(0, Math.max(0, n));
	  };

	  // Sort the object's values by a criterion produced by an iteratee.
	  _.sortBy = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    return _.pluck(_.map(obj, function(value, index, list) {
	      return {
	        value: value,
	        index: index,
	        criteria: iteratee(value, index, list)
	      };
	    }).sort(function(left, right) {
	      var a = left.criteria;
	      var b = right.criteria;
	      if (a !== b) {
	        if (a > b || a === void 0) return 1;
	        if (a < b || b === void 0) return -1;
	      }
	      return left.index - right.index;
	    }), 'value');
	  };

	  // An internal function used for aggregate "group by" operations.
	  var group = function(behavior) {
	    return function(obj, iteratee, context) {
	      var result = {};
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index) {
	        var key = iteratee(value, index, obj);
	        behavior(result, value, key);
	      });
	      return result;
	    };
	  };

	  // Groups the object's values by a criterion. Pass either a string attribute
	  // to group by, or a function that returns the criterion.
	  _.groupBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
	  });

	  // Indexes the object's values by a criterion, similar to `groupBy`, but for
	  // when you know that your index values will be unique.
	  _.indexBy = group(function(result, value, key) {
	    result[key] = value;
	  });

	  // Counts instances of an object that group by a certain criterion. Pass
	  // either a string attribute to count by, or a function that returns the
	  // criterion.
	  _.countBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key]++; else result[key] = 1;
	  });

	  // Safely create a real, live array from anything iterable.
	  _.toArray = function(obj) {
	    if (!obj) return [];
	    if (_.isArray(obj)) return slice.call(obj);
	    if (isArrayLike(obj)) return _.map(obj, _.identity);
	    return _.values(obj);
	  };

	  // Return the number of elements in an object.
	  _.size = function(obj) {
	    if (obj == null) return 0;
	    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
	  };

	  // Split a collection into two arrays: one whose elements all satisfy the given
	  // predicate, and one whose elements all do not satisfy the predicate.
	  _.partition = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var pass = [], fail = [];
	    _.each(obj, function(value, key, obj) {
	      (predicate(value, key, obj) ? pass : fail).push(value);
	    });
	    return [pass, fail];
	  };

	  // Array Functions
	  // ---------------

	  // Get the first element of an array. Passing **n** will return the first N
	  // values in the array. Aliased as `head` and `take`. The **guard** check
	  // allows it to work with `_.map`.
	  _.first = _.head = _.take = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[0];
	    return _.initial(array, array.length - n);
	  };

	  // Returns everything but the last entry of the array. Especially useful on
	  // the arguments object. Passing **n** will return all the values in
	  // the array, excluding the last N.
	  _.initial = function(array, n, guard) {
	    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
	  };

	  // Get the last element of an array. Passing **n** will return the last N
	  // values in the array.
	  _.last = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[array.length - 1];
	    return _.rest(array, Math.max(0, array.length - n));
	  };

	  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
	  // Especially useful on the arguments object. Passing an **n** will return
	  // the rest N values in the array.
	  _.rest = _.tail = _.drop = function(array, n, guard) {
	    return slice.call(array, n == null || guard ? 1 : n);
	  };

	  // Trim out all falsy values from an array.
	  _.compact = function(array) {
	    return _.filter(array, _.identity);
	  };

	  // Internal implementation of a recursive `flatten` function.
	  var flatten = function(input, shallow, strict, startIndex) {
	    var output = [], idx = 0;
	    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
	      var value = input[i];
	      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
	        //flatten current level of array or arguments object
	        if (!shallow) value = flatten(value, shallow, strict);
	        var j = 0, len = value.length;
	        output.length += len;
	        while (j < len) {
	          output[idx++] = value[j++];
	        }
	      } else if (!strict) {
	        output[idx++] = value;
	      }
	    }
	    return output;
	  };

	  // Flatten out an array, either recursively (by default), or just one level.
	  _.flatten = function(array, shallow) {
	    return flatten(array, shallow, false);
	  };

	  // Return a version of the array that does not contain the specified value(s).
	  _.without = function(array) {
	    return _.difference(array, slice.call(arguments, 1));
	  };

	  // Produce a duplicate-free version of the array. If the array has already
	  // been sorted, you have the option of using a faster algorithm.
	  // Aliased as `unique`.
	  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
	    if (!_.isBoolean(isSorted)) {
	      context = iteratee;
	      iteratee = isSorted;
	      isSorted = false;
	    }
	    if (iteratee != null) iteratee = cb(iteratee, context);
	    var result = [];
	    var seen = [];
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var value = array[i],
	          computed = iteratee ? iteratee(value, i, array) : value;
	      if (isSorted) {
	        if (!i || seen !== computed) result.push(value);
	        seen = computed;
	      } else if (iteratee) {
	        if (!_.contains(seen, computed)) {
	          seen.push(computed);
	          result.push(value);
	        }
	      } else if (!_.contains(result, value)) {
	        result.push(value);
	      }
	    }
	    return result;
	  };

	  // Produce an array that contains the union: each distinct element from all of
	  // the passed-in arrays.
	  _.union = function() {
	    return _.uniq(flatten(arguments, true, true));
	  };

	  // Produce an array that contains every item shared between all the
	  // passed-in arrays.
	  _.intersection = function(array) {
	    var result = [];
	    var argsLength = arguments.length;
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var item = array[i];
	      if (_.contains(result, item)) continue;
	      for (var j = 1; j < argsLength; j++) {
	        if (!_.contains(arguments[j], item)) break;
	      }
	      if (j === argsLength) result.push(item);
	    }
	    return result;
	  };

	  // Take the difference between one array and a number of other arrays.
	  // Only the elements present in just the first array will remain.
	  _.difference = function(array) {
	    var rest = flatten(arguments, true, true, 1);
	    return _.filter(array, function(value){
	      return !_.contains(rest, value);
	    });
	  };

	  // Zip together multiple lists into a single array -- elements that share
	  // an index go together.
	  _.zip = function() {
	    return _.unzip(arguments);
	  };

	  // Complement of _.zip. Unzip accepts an array of arrays and groups
	  // each array's elements on shared indices
	  _.unzip = function(array) {
	    var length = array && _.max(array, getLength).length || 0;
	    var result = Array(length);

	    for (var index = 0; index < length; index++) {
	      result[index] = _.pluck(array, index);
	    }
	    return result;
	  };

	  // Converts lists into objects. Pass either a single array of `[key, value]`
	  // pairs, or two parallel arrays of the same length -- one of keys, and one of
	  // the corresponding values.
	  _.object = function(list, values) {
	    var result = {};
	    for (var i = 0, length = getLength(list); i < length; i++) {
	      if (values) {
	        result[list[i]] = values[i];
	      } else {
	        result[list[i][0]] = list[i][1];
	      }
	    }
	    return result;
	  };

	  // Generator function to create the findIndex and findLastIndex functions
	  function createPredicateIndexFinder(dir) {
	    return function(array, predicate, context) {
	      predicate = cb(predicate, context);
	      var length = getLength(array);
	      var index = dir > 0 ? 0 : length - 1;
	      for (; index >= 0 && index < length; index += dir) {
	        if (predicate(array[index], index, array)) return index;
	      }
	      return -1;
	    };
	  }

	  // Returns the first index on an array-like that passes a predicate test
	  _.findIndex = createPredicateIndexFinder(1);
	  _.findLastIndex = createPredicateIndexFinder(-1);

	  // Use a comparator function to figure out the smallest index at which
	  // an object should be inserted so as to maintain order. Uses binary search.
	  _.sortedIndex = function(array, obj, iteratee, context) {
	    iteratee = cb(iteratee, context, 1);
	    var value = iteratee(obj);
	    var low = 0, high = getLength(array);
	    while (low < high) {
	      var mid = Math.floor((low + high) / 2);
	      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
	    }
	    return low;
	  };

	  // Generator function to create the indexOf and lastIndexOf functions
	  function createIndexFinder(dir, predicateFind, sortedIndex) {
	    return function(array, item, idx) {
	      var i = 0, length = getLength(array);
	      if (typeof idx == 'number') {
	        if (dir > 0) {
	            i = idx >= 0 ? idx : Math.max(idx + length, i);
	        } else {
	            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
	        }
	      } else if (sortedIndex && idx && length) {
	        idx = sortedIndex(array, item);
	        return array[idx] === item ? idx : -1;
	      }
	      if (item !== item) {
	        idx = predicateFind(slice.call(array, i, length), _.isNaN);
	        return idx >= 0 ? idx + i : -1;
	      }
	      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
	        if (array[idx] === item) return idx;
	      }
	      return -1;
	    };
	  }

	  // Return the position of the first occurrence of an item in an array,
	  // or -1 if the item is not included in the array.
	  // If the array is large and already in sort order, pass `true`
	  // for **isSorted** to use binary search.
	  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
	  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

	  // Generate an integer Array containing an arithmetic progression. A port of
	  // the native Python `range()` function. See
	  // [the Python documentation](http://docs.python.org/library/functions.html#range).
	  _.range = function(start, stop, step) {
	    if (stop == null) {
	      stop = start || 0;
	      start = 0;
	    }
	    step = step || 1;

	    var length = Math.max(Math.ceil((stop - start) / step), 0);
	    var range = Array(length);

	    for (var idx = 0; idx < length; idx++, start += step) {
	      range[idx] = start;
	    }

	    return range;
	  };

	  // Function (ahem) Functions
	  // ------------------

	  // Determines whether to execute a function as a constructor
	  // or a normal function with the provided arguments
	  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
	    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
	    var self = baseCreate(sourceFunc.prototype);
	    var result = sourceFunc.apply(self, args);
	    if (_.isObject(result)) return result;
	    return self;
	  };

	  // Create a function bound to a given object (assigning `this`, and arguments,
	  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
	  // available.
	  _.bind = function(func, context) {
	    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
	    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
	    var args = slice.call(arguments, 2);
	    var bound = function() {
	      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
	    };
	    return bound;
	  };

	  // Partially apply a function by creating a version that has had some of its
	  // arguments pre-filled, without changing its dynamic `this` context. _ acts
	  // as a placeholder, allowing any combination of arguments to be pre-filled.
	  _.partial = function(func) {
	    var boundArgs = slice.call(arguments, 1);
	    var bound = function() {
	      var position = 0, length = boundArgs.length;
	      var args = Array(length);
	      for (var i = 0; i < length; i++) {
	        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
	      }
	      while (position < arguments.length) args.push(arguments[position++]);
	      return executeBound(func, bound, this, this, args);
	    };
	    return bound;
	  };

	  // Bind a number of an object's methods to that object. Remaining arguments
	  // are the method names to be bound. Useful for ensuring that all callbacks
	  // defined on an object belong to it.
	  _.bindAll = function(obj) {
	    var i, length = arguments.length, key;
	    if (length <= 1) throw new Error('bindAll must be passed function names');
	    for (i = 1; i < length; i++) {
	      key = arguments[i];
	      obj[key] = _.bind(obj[key], obj);
	    }
	    return obj;
	  };

	  // Memoize an expensive function by storing its results.
	  _.memoize = function(func, hasher) {
	    var memoize = function(key) {
	      var cache = memoize.cache;
	      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
	      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
	      return cache[address];
	    };
	    memoize.cache = {};
	    return memoize;
	  };

	  // Delays a function for the given number of milliseconds, and then calls
	  // it with the arguments supplied.
	  _.delay = function(func, wait) {
	    var args = slice.call(arguments, 2);
	    return setTimeout(function(){
	      return func.apply(null, args);
	    }, wait);
	  };

	  // Defers a function, scheduling it to run after the current call stack has
	  // cleared.
	  _.defer = _.partial(_.delay, _, 1);

	  // Returns a function, that, when invoked, will only be triggered at most once
	  // during a given window of time. Normally, the throttled function will run
	  // as much as it can, without ever going more than once per `wait` duration;
	  // but if you'd like to disable the execution on the leading edge, pass
	  // `{leading: false}`. To disable execution on the trailing edge, ditto.
	  _.throttle = function(func, wait, options) {
	    var context, args, result;
	    var timeout = null;
	    var previous = 0;
	    if (!options) options = {};
	    var later = function() {
	      previous = options.leading === false ? 0 : _.now();
	      timeout = null;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    };
	    return function() {
	      var now = _.now();
	      if (!previous && options.leading === false) previous = now;
	      var remaining = wait - (now - previous);
	      context = this;
	      args = arguments;
	      if (remaining <= 0 || remaining > wait) {
	        if (timeout) {
	          clearTimeout(timeout);
	          timeout = null;
	        }
	        previous = now;
	        result = func.apply(context, args);
	        if (!timeout) context = args = null;
	      } else if (!timeout && options.trailing !== false) {
	        timeout = setTimeout(later, remaining);
	      }
	      return result;
	    };
	  };

	  // Returns a function, that, as long as it continues to be invoked, will not
	  // be triggered. The function will be called after it stops being called for
	  // N milliseconds. If `immediate` is passed, trigger the function on the
	  // leading edge, instead of the trailing.
	  _.debounce = function(func, wait, immediate) {
	    var timeout, args, context, timestamp, result;

	    var later = function() {
	      var last = _.now() - timestamp;

	      if (last < wait && last >= 0) {
	        timeout = setTimeout(later, wait - last);
	      } else {
	        timeout = null;
	        if (!immediate) {
	          result = func.apply(context, args);
	          if (!timeout) context = args = null;
	        }
	      }
	    };

	    return function() {
	      context = this;
	      args = arguments;
	      timestamp = _.now();
	      var callNow = immediate && !timeout;
	      if (!timeout) timeout = setTimeout(later, wait);
	      if (callNow) {
	        result = func.apply(context, args);
	        context = args = null;
	      }

	      return result;
	    };
	  };

	  // Returns the first function passed as an argument to the second,
	  // allowing you to adjust arguments, run code before and after, and
	  // conditionally execute the original function.
	  _.wrap = function(func, wrapper) {
	    return _.partial(wrapper, func);
	  };

	  // Returns a negated version of the passed-in predicate.
	  _.negate = function(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    };
	  };

	  // Returns a function that is the composition of a list of functions, each
	  // consuming the return value of the function that follows.
	  _.compose = function() {
	    var args = arguments;
	    var start = args.length - 1;
	    return function() {
	      var i = start;
	      var result = args[start].apply(this, arguments);
	      while (i--) result = args[i].call(this, result);
	      return result;
	    };
	  };

	  // Returns a function that will only be executed on and after the Nth call.
	  _.after = function(times, func) {
	    return function() {
	      if (--times < 1) {
	        return func.apply(this, arguments);
	      }
	    };
	  };

	  // Returns a function that will only be executed up to (but not including) the Nth call.
	  _.before = function(times, func) {
	    var memo;
	    return function() {
	      if (--times > 0) {
	        memo = func.apply(this, arguments);
	      }
	      if (times <= 1) func = null;
	      return memo;
	    };
	  };

	  // Returns a function that will be executed at most one time, no matter how
	  // often you call it. Useful for lazy initialization.
	  _.once = _.partial(_.before, 2);

	  // Object Functions
	  // ----------------

	  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
	  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
	  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
	                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

	  function collectNonEnumProps(obj, keys) {
	    var nonEnumIdx = nonEnumerableProps.length;
	    var constructor = obj.constructor;
	    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

	    // Constructor is a special case.
	    var prop = 'constructor';
	    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

	    while (nonEnumIdx--) {
	      prop = nonEnumerableProps[nonEnumIdx];
	      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
	        keys.push(prop);
	      }
	    }
	  }

	  // Retrieve the names of an object's own properties.
	  // Delegates to **ECMAScript 5**'s native `Object.keys`
	  _.keys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    if (nativeKeys) return nativeKeys(obj);
	    var keys = [];
	    for (var key in obj) if (_.has(obj, key)) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };

	  // Retrieve all the property names of an object.
	  _.allKeys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    var keys = [];
	    for (var key in obj) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };

	  // Retrieve the values of an object's properties.
	  _.values = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var values = Array(length);
	    for (var i = 0; i < length; i++) {
	      values[i] = obj[keys[i]];
	    }
	    return values;
	  };

	  // Returns the results of applying the iteratee to each element of the object
	  // In contrast to _.map it returns an object
	  _.mapObject = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys =  _.keys(obj),
	          length = keys.length,
	          results = {},
	          currentKey;
	      for (var index = 0; index < length; index++) {
	        currentKey = keys[index];
	        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
	      }
	      return results;
	  };

	  // Convert an object into a list of `[key, value]` pairs.
	  _.pairs = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var pairs = Array(length);
	    for (var i = 0; i < length; i++) {
	      pairs[i] = [keys[i], obj[keys[i]]];
	    }
	    return pairs;
	  };

	  // Invert the keys and values of an object. The values must be serializable.
	  _.invert = function(obj) {
	    var result = {};
	    var keys = _.keys(obj);
	    for (var i = 0, length = keys.length; i < length; i++) {
	      result[obj[keys[i]]] = keys[i];
	    }
	    return result;
	  };

	  // Return a sorted list of the function names available on the object.
	  // Aliased as `methods`
	  _.functions = _.methods = function(obj) {
	    var names = [];
	    for (var key in obj) {
	      if (_.isFunction(obj[key])) names.push(key);
	    }
	    return names.sort();
	  };

	  // Extend a given object with all the properties in passed-in object(s).
	  _.extend = createAssigner(_.allKeys);

	  // Assigns a given object with all the own properties in the passed-in object(s)
	  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
	  _.extendOwn = _.assign = createAssigner(_.keys);

	  // Returns the first key on an object that passes a predicate test
	  _.findKey = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = _.keys(obj), key;
	    for (var i = 0, length = keys.length; i < length; i++) {
	      key = keys[i];
	      if (predicate(obj[key], key, obj)) return key;
	    }
	  };

	  // Return a copy of the object only containing the whitelisted properties.
	  _.pick = function(object, oiteratee, context) {
	    var result = {}, obj = object, iteratee, keys;
	    if (obj == null) return result;
	    if (_.isFunction(oiteratee)) {
	      keys = _.allKeys(obj);
	      iteratee = optimizeCb(oiteratee, context);
	    } else {
	      keys = flatten(arguments, false, false, 1);
	      iteratee = function(value, key, obj) { return key in obj; };
	      obj = Object(obj);
	    }
	    for (var i = 0, length = keys.length; i < length; i++) {
	      var key = keys[i];
	      var value = obj[key];
	      if (iteratee(value, key, obj)) result[key] = value;
	    }
	    return result;
	  };

	   // Return a copy of the object without the blacklisted properties.
	  _.omit = function(obj, iteratee, context) {
	    if (_.isFunction(iteratee)) {
	      iteratee = _.negate(iteratee);
	    } else {
	      var keys = _.map(flatten(arguments, false, false, 1), String);
	      iteratee = function(value, key) {
	        return !_.contains(keys, key);
	      };
	    }
	    return _.pick(obj, iteratee, context);
	  };

	  // Fill in a given object with default properties.
	  _.defaults = createAssigner(_.allKeys, true);

	  // Creates an object that inherits from the given prototype object.
	  // If additional properties are provided then they will be added to the
	  // created object.
	  _.create = function(prototype, props) {
	    var result = baseCreate(prototype);
	    if (props) _.extendOwn(result, props);
	    return result;
	  };

	  // Create a (shallow-cloned) duplicate of an object.
	  _.clone = function(obj) {
	    if (!_.isObject(obj)) return obj;
	    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
	  };

	  // Invokes interceptor with the obj, and then returns obj.
	  // The primary purpose of this method is to "tap into" a method chain, in
	  // order to perform operations on intermediate results within the chain.
	  _.tap = function(obj, interceptor) {
	    interceptor(obj);
	    return obj;
	  };

	  // Returns whether an object has a given set of `key:value` pairs.
	  _.isMatch = function(object, attrs) {
	    var keys = _.keys(attrs), length = keys.length;
	    if (object == null) return !length;
	    var obj = Object(object);
	    for (var i = 0; i < length; i++) {
	      var key = keys[i];
	      if (attrs[key] !== obj[key] || !(key in obj)) return false;
	    }
	    return true;
	  };


	  // Internal recursive comparison function for `isEqual`.
	  var eq = function(a, b, aStack, bStack) {
	    // Identical objects are equal. `0 === -0`, but they aren't identical.
	    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
	    if (a === b) return a !== 0 || 1 / a === 1 / b;
	    // A strict comparison is necessary because `null == undefined`.
	    if (a == null || b == null) return a === b;
	    // Unwrap any wrapped objects.
	    if (a instanceof _) a = a._wrapped;
	    if (b instanceof _) b = b._wrapped;
	    // Compare `[[Class]]` names.
	    var className = toString.call(a);
	    if (className !== toString.call(b)) return false;
	    switch (className) {
	      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
	      case '[object RegExp]':
	      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
	      case '[object String]':
	        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
	        // equivalent to `new String("5")`.
	        return '' + a === '' + b;
	      case '[object Number]':
	        // `NaN`s are equivalent, but non-reflexive.
	        // Object(NaN) is equivalent to NaN
	        if (+a !== +a) return +b !== +b;
	        // An `egal` comparison is performed for other numeric values.
	        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
	      case '[object Date]':
	      case '[object Boolean]':
	        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
	        // millisecond representations. Note that invalid dates with millisecond representations
	        // of `NaN` are not equivalent.
	        return +a === +b;
	    }

	    var areArrays = className === '[object Array]';
	    if (!areArrays) {
	      if (typeof a != 'object' || typeof b != 'object') return false;

	      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
	      // from different frames are.
	      var aCtor = a.constructor, bCtor = b.constructor;
	      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
	                               _.isFunction(bCtor) && bCtor instanceof bCtor)
	                          && ('constructor' in a && 'constructor' in b)) {
	        return false;
	      }
	    }
	    // Assume equality for cyclic structures. The algorithm for detecting cyclic
	    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

	    // Initializing stack of traversed objects.
	    // It's done here since we only need them for objects and arrays comparison.
	    aStack = aStack || [];
	    bStack = bStack || [];
	    var length = aStack.length;
	    while (length--) {
	      // Linear search. Performance is inversely proportional to the number of
	      // unique nested structures.
	      if (aStack[length] === a) return bStack[length] === b;
	    }

	    // Add the first object to the stack of traversed objects.
	    aStack.push(a);
	    bStack.push(b);

	    // Recursively compare objects and arrays.
	    if (areArrays) {
	      // Compare array lengths to determine if a deep comparison is necessary.
	      length = a.length;
	      if (length !== b.length) return false;
	      // Deep compare the contents, ignoring non-numeric properties.
	      while (length--) {
	        if (!eq(a[length], b[length], aStack, bStack)) return false;
	      }
	    } else {
	      // Deep compare objects.
	      var keys = _.keys(a), key;
	      length = keys.length;
	      // Ensure that both objects contain the same number of properties before comparing deep equality.
	      if (_.keys(b).length !== length) return false;
	      while (length--) {
	        // Deep compare each member
	        key = keys[length];
	        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
	      }
	    }
	    // Remove the first object from the stack of traversed objects.
	    aStack.pop();
	    bStack.pop();
	    return true;
	  };

	  // Perform a deep comparison to check if two objects are equal.
	  _.isEqual = function(a, b) {
	    return eq(a, b);
	  };

	  // Is a given array, string, or object empty?
	  // An "empty" object has no enumerable own-properties.
	  _.isEmpty = function(obj) {
	    if (obj == null) return true;
	    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
	    return _.keys(obj).length === 0;
	  };

	  // Is a given value a DOM element?
	  _.isElement = function(obj) {
	    return !!(obj && obj.nodeType === 1);
	  };

	  // Is a given value an array?
	  // Delegates to ECMA5's native Array.isArray
	  _.isArray = nativeIsArray || function(obj) {
	    return toString.call(obj) === '[object Array]';
	  };

	  // Is a given variable an object?
	  _.isObject = function(obj) {
	    var type = typeof obj;
	    return type === 'function' || type === 'object' && !!obj;
	  };

	  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
	  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
	    _['is' + name] = function(obj) {
	      return toString.call(obj) === '[object ' + name + ']';
	    };
	  });

	  // Define a fallback version of the method in browsers (ahem, IE < 9), where
	  // there isn't any inspectable "Arguments" type.
	  if (!_.isArguments(arguments)) {
	    _.isArguments = function(obj) {
	      return _.has(obj, 'callee');
	    };
	  }

	  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
	  // IE 11 (#1621), and in Safari 8 (#1929).
	  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
	    _.isFunction = function(obj) {
	      return typeof obj == 'function' || false;
	    };
	  }

	  // Is a given object a finite number?
	  _.isFinite = function(obj) {
	    return isFinite(obj) && !isNaN(parseFloat(obj));
	  };

	  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
	  _.isNaN = function(obj) {
	    return _.isNumber(obj) && obj !== +obj;
	  };

	  // Is a given value a boolean?
	  _.isBoolean = function(obj) {
	    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
	  };

	  // Is a given value equal to null?
	  _.isNull = function(obj) {
	    return obj === null;
	  };

	  // Is a given variable undefined?
	  _.isUndefined = function(obj) {
	    return obj === void 0;
	  };

	  // Shortcut function for checking if an object has a given property directly
	  // on itself (in other words, not on a prototype).
	  _.has = function(obj, key) {
	    return obj != null && hasOwnProperty.call(obj, key);
	  };

	  // Utility Functions
	  // -----------------

	  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
	  // previous owner. Returns a reference to the Underscore object.
	  _.noConflict = function() {
	    root._ = previousUnderscore;
	    return this;
	  };

	  // Keep the identity function around for default iteratees.
	  _.identity = function(value) {
	    return value;
	  };

	  // Predicate-generating functions. Often useful outside of Underscore.
	  _.constant = function(value) {
	    return function() {
	      return value;
	    };
	  };

	  _.noop = function(){};

	  _.property = property;

	  // Generates a function for a given object that returns a given property.
	  _.propertyOf = function(obj) {
	    return obj == null ? function(){} : function(key) {
	      return obj[key];
	    };
	  };

	  // Returns a predicate for checking whether an object has a given set of
	  // `key:value` pairs.
	  _.matcher = _.matches = function(attrs) {
	    attrs = _.extendOwn({}, attrs);
	    return function(obj) {
	      return _.isMatch(obj, attrs);
	    };
	  };

	  // Run a function **n** times.
	  _.times = function(n, iteratee, context) {
	    var accum = Array(Math.max(0, n));
	    iteratee = optimizeCb(iteratee, context, 1);
	    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
	    return accum;
	  };

	  // Return a random integer between min and max (inclusive).
	  _.random = function(min, max) {
	    if (max == null) {
	      max = min;
	      min = 0;
	    }
	    return min + Math.floor(Math.random() * (max - min + 1));
	  };

	  // A (possibly faster) way to get the current timestamp as an integer.
	  _.now = Date.now || function() {
	    return new Date().getTime();
	  };

	   // List of HTML entities for escaping.
	  var escapeMap = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#x27;',
	    '`': '&#x60;'
	  };
	  var unescapeMap = _.invert(escapeMap);

	  // Functions for escaping and unescaping strings to/from HTML interpolation.
	  var createEscaper = function(map) {
	    var escaper = function(match) {
	      return map[match];
	    };
	    // Regexes for identifying a key that needs to be escaped
	    var source = '(?:' + _.keys(map).join('|') + ')';
	    var testRegexp = RegExp(source);
	    var replaceRegexp = RegExp(source, 'g');
	    return function(string) {
	      string = string == null ? '' : '' + string;
	      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
	    };
	  };
	  _.escape = createEscaper(escapeMap);
	  _.unescape = createEscaper(unescapeMap);

	  // If the value of the named `property` is a function then invoke it with the
	  // `object` as context; otherwise, return it.
	  _.result = function(object, property, fallback) {
	    var value = object == null ? void 0 : object[property];
	    if (value === void 0) {
	      value = fallback;
	    }
	    return _.isFunction(value) ? value.call(object) : value;
	  };

	  // Generate a unique integer id (unique within the entire client session).
	  // Useful for temporary DOM ids.
	  var idCounter = 0;
	  _.uniqueId = function(prefix) {
	    var id = ++idCounter + '';
	    return prefix ? prefix + id : id;
	  };

	  // By default, Underscore uses ERB-style template delimiters, change the
	  // following template settings to use alternative delimiters.
	  _.templateSettings = {
	    evaluate    : /<%([\s\S]+?)%>/g,
	    interpolate : /<%=([\s\S]+?)%>/g,
	    escape      : /<%-([\s\S]+?)%>/g
	  };

	  // When customizing `templateSettings`, if you don't want to define an
	  // interpolation, evaluation or escaping regex, we need one that is
	  // guaranteed not to match.
	  var noMatch = /(.)^/;

	  // Certain characters need to be escaped so that they can be put into a
	  // string literal.
	  var escapes = {
	    "'":      "'",
	    '\\':     '\\',
	    '\r':     'r',
	    '\n':     'n',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

	  var escapeChar = function(match) {
	    return '\\' + escapes[match];
	  };

	  // JavaScript micro-templating, similar to John Resig's implementation.
	  // Underscore templating handles arbitrary delimiters, preserves whitespace,
	  // and correctly escapes quotes within interpolated code.
	  // NB: `oldSettings` only exists for backwards compatibility.
	  _.template = function(text, settings, oldSettings) {
	    if (!settings && oldSettings) settings = oldSettings;
	    settings = _.defaults({}, settings, _.templateSettings);

	    // Combine delimiters into one regular expression via alternation.
	    var matcher = RegExp([
	      (settings.escape || noMatch).source,
	      (settings.interpolate || noMatch).source,
	      (settings.evaluate || noMatch).source
	    ].join('|') + '|$', 'g');

	    // Compile the template source, escaping string literals appropriately.
	    var index = 0;
	    var source = "__p+='";
	    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	      source += text.slice(index, offset).replace(escaper, escapeChar);
	      index = offset + match.length;

	      if (escape) {
	        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	      } else if (interpolate) {
	        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	      } else if (evaluate) {
	        source += "';\n" + evaluate + "\n__p+='";
	      }

	      // Adobe VMs need the match returned to produce the correct offest.
	      return match;
	    });
	    source += "';\n";

	    // If a variable is not specified, place data values in local scope.
	    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

	    source = "var __t,__p='',__j=Array.prototype.join," +
	      "print=function(){__p+=__j.call(arguments,'');};\n" +
	      source + 'return __p;\n';

	    try {
	      var render = new Function(settings.variable || 'obj', '_', source);
	    } catch (e) {
	      e.source = source;
	      throw e;
	    }

	    var template = function(data) {
	      return render.call(this, data, _);
	    };

	    // Provide the compiled source as a convenience for precompilation.
	    var argument = settings.variable || 'obj';
	    template.source = 'function(' + argument + '){\n' + source + '}';

	    return template;
	  };

	  // Add a "chain" function. Start chaining a wrapped Underscore object.
	  _.chain = function(obj) {
	    var instance = _(obj);
	    instance._chain = true;
	    return instance;
	  };

	  // OOP
	  // ---------------
	  // If Underscore is called as a function, it returns a wrapped object that
	  // can be used OO-style. This wrapper holds altered versions of all the
	  // underscore functions. Wrapped objects may be chained.

	  // Helper function to continue chaining intermediate results.
	  var result = function(instance, obj) {
	    return instance._chain ? _(obj).chain() : obj;
	  };

	  // Add your own custom functions to the Underscore object.
	  _.mixin = function(obj) {
	    _.each(_.functions(obj), function(name) {
	      var func = _[name] = obj[name];
	      _.prototype[name] = function() {
	        var args = [this._wrapped];
	        push.apply(args, arguments);
	        return result(this, func.apply(_, args));
	      };
	    });
	  };

	  // Add all of the Underscore functions to the wrapper object.
	  _.mixin(_);

	  // Add all mutator Array functions to the wrapper.
	  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      var obj = this._wrapped;
	      method.apply(obj, arguments);
	      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
	      return result(this, obj);
	    };
	  });

	  // Add all accessor Array functions to the wrapper.
	  _.each(['concat', 'join', 'slice'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      return result(this, method.apply(this._wrapped, arguments));
	    };
	  });

	  // Extracts the result from a wrapped and chained object.
	  _.prototype.value = function() {
	    return this._wrapped;
	  };

	  // Provide unwrapping proxy for some methods used in engine operations
	  // such as arithmetic and JSON stringification.
	  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

	  _.prototype.toString = function() {
	    return '' + this._wrapped;
	  };

	  // AMD registration happens at the end for compatibility with AMD loaders
	  // that may not enforce next-turn semantics on modules. Even though general
	  // practice for AMD registration is to be anonymous, underscore registers
	  // as a named module because, like jQuery, it is a base library that is
	  // popular enough to be bundled in a third party lib, but not be part of
	  // an AMD load request. Those cases could generate an error when an
	  // anonymous define() is called outside of a loader request.
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	}.call(this));


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	'use strict';

	var emptyFunction = __webpack_require__(93);
	var invariant = __webpack_require__(94);
	var ReactPropTypesSecret = __webpack_require__(92);

	module.exports = function() {
	  function shim(props, propName, componentName, location, propFullName, secret) {
	    if (secret === ReactPropTypesSecret) {
	      // It is still safe when called from React.
	      return;
	    }
	    invariant(
	      false,
	      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	      'Use PropTypes.checkPropTypes() to call them. ' +
	      'Read more at http://fb.me/use-check-prop-types'
	    );
	  };
	  shim.isRequired = shim;
	  function getShim() {
	    return shim;
	  };
	  // Important!
	  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
	  var ReactPropTypes = {
	    array: shim,
	    bool: shim,
	    func: shim,
	    number: shim,
	    object: shim,
	    string: shim,
	    symbol: shim,

	    any: shim,
	    arrayOf: getShim,
	    element: shim,
	    instanceOf: getShim,
	    node: shim,
	    objectOf: getShim,
	    oneOf: getShim,
	    oneOfType: getShim,
	    shape: getShim,
	    exact: getShim
	  };

	  ReactPropTypes.checkPropTypes = emptyFunction;
	  ReactPropTypes.PropTypes = ReactPropTypes;

	  return ReactPropTypes;
	};


/***/ }),
/* 92 */
/***/ (function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	'use strict';

	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

	module.exports = ReactPropTypesSecret;


/***/ }),
/* 93 */
/***/ (function(module, exports) {

	"use strict";

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 * 
	 */

	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}

	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	var emptyFunction = function emptyFunction() {};

	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};

	module.exports = emptyFunction;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */

	'use strict';

	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */

	var validateFormat = function validateFormat(format) {};

	if (false) {
	  validateFormat = function validateFormat(format) {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  };
	}

	function invariant(condition, format, a, b, c, d, e, f) {
	  validateFormat(format);

	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }

	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}

	module.exports = invariant;

/***/ }),
/* 95 */,
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _reselect = __webpack_require__(369);

	var _reactDataGrid = __webpack_require__(7);

	var isEmptyArray = _reactDataGrid.utils.isEmptyArray,
	    isEmptyObject = _reactDataGrid.utils.isEmptyObject;

	var groupRows = __webpack_require__(182);
	var filterRows = __webpack_require__(181);
	var sortRows = __webpack_require__(184);

	var getInputRows = function getInputRows(state) {
	  return state.rows;
	};
	var getFilters = function getFilters(state) {
	  return state.filters;
	};
	var getFilteredRows = (0, _reselect.createSelector)([getFilters, getInputRows], function (filters) {
	  var rows = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

	  if (!filters || isEmptyObject(filters)) {
	    return rows;
	  }
	  return filterRows(filters, rows);
	});

	var getSortColumn = function getSortColumn(state) {
	  return state.sortColumn;
	};
	var getSortDirection = function getSortDirection(state) {
	  return state.sortDirection;
	};
	var getSortedRows = (0, _reselect.createSelector)([getFilteredRows, getSortColumn, getSortDirection], function (rows, sortColumn, sortDirection) {
	  if (!sortDirection && !sortColumn) {
	    return rows;
	  }
	  return sortRows(rows, sortColumn, sortDirection);
	});

	var getGroupedColumns = function getGroupedColumns(state) {
	  return state.groupBy;
	};
	var getExpandedRows = function getExpandedRows(state) {
	  return state.expandedRows;
	};
	var getFlattenedGroupedRows = (0, _reselect.createSelector)([getSortedRows, getGroupedColumns, getExpandedRows], function (rows, groupedColumns) {
	  var expandedRows = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	  if (!groupedColumns || isEmptyObject(groupedColumns) || isEmptyArray(groupedColumns)) {
	    return rows;
	  }
	  return groupRows(rows, groupedColumns, expandedRows);
	});

	var getSelectedKeys = function getSelectedKeys(state) {
	  return state.selectedKeys;
	};
	var getRowKey = function getRowKey(state) {
	  return state.rowKey;
	};
	var getSelectedRowsByKey = (0, _reselect.createSelector)([getRowKey, getSelectedKeys, getInputRows], function (rowKey, selectedKeys) {
	  var rows = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

	  return selectedKeys.map(function (k) {
	    return rows.filter(function (r) {
	      return r[rowKey] === k;
	    })[0];
	  });
	});

	var Selectors = {
	  getRows: getFlattenedGroupedRows,
	  getSelectedRowsByKey: getSelectedRowsByKey
	};
	module.exports = Selectors;

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _reactDnd = __webpack_require__(14);

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _reactDataGrid = __webpack_require__(7);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var DragItemTypes = _reactDataGrid._constants.DragItemTypes;

	var DraggableHeaderCell = function (_Component) {
	  _inherits(DraggableHeaderCell, _Component);

	  function DraggableHeaderCell() {
	    _classCallCheck(this, DraggableHeaderCell);

	    return _possibleConstructorReturn(this, _Component.apply(this, arguments));
	  }

	  DraggableHeaderCell.prototype.componentDidMount = function componentDidMount() {
	    var connectDragPreview = this.props.connectDragPreview;
	    var img = new Image();
	    img.src = './assets/images/drag_column_full.png';
	    img.onload = function () {
	      connectDragPreview(img);
	    };
	  };

	  DraggableHeaderCell.prototype.setScrollLeft = function setScrollLeft(scrollLeft) {
	    var node = ReactDOM.findDOMNode(this);
	    node.style.webkitTransform = 'translate3d(' + scrollLeft + 'px, 0px, 0px)';
	    node.style.transform = 'translate3d(' + scrollLeft + 'px, 0px, 0px)';
	  };

	  DraggableHeaderCell.prototype.render = function render() {
	    var _props = this.props,
	        connectDragSource = _props.connectDragSource,
	        isDragging = _props.isDragging;

	    if (isDragging) {
	      return null;
	    }
	    return connectDragSource(_react2['default'].createElement(
	      'div',
	      { style: { cursor: 'move' } },
	      _react2['default'].createElement(_reactDataGrid.HeaderCell, this.props)
	    ));
	  };

	  return DraggableHeaderCell;
	}(_react.Component);

	DraggableHeaderCell.propTypes = {
	  connectDragSource: _propTypes2['default'].func.isRequired,
	  connectDragPreview: _propTypes2['default'].func.isRequired,
	  isDragging: _propTypes2['default'].bool.isRequired
	};

	function collect(connect, monitor) {
	  return {
	    connectDragSource: connect.dragSource(),
	    isDragging: monitor.isDragging(),
	    connectDragPreview: connect.dragPreview()
	  };
	}

	var headerCellSource = {
	  beginDrag: function beginDrag(props) {
	    return props.column;
	  },
	  endDrag: function endDrag(props) {
	    return props.column;
	  }
	};

	exports['default'] = (0, _reactDnd.DragSource)(DragItemTypes.Column, headerCellSource, collect)(DraggableHeaderCell);

/***/ }),
/* 98 */
/***/ (function(module, exports) {

	'use strict';

	exports.__esModule = true;

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var OWNER_COMPONENT_KEY = 'Owner > component';
	var WASTED_TIME_KEY = 'Wasted time (ms)';
	var WASTED_INSTANCES_KEY = 'Instances';

	var SummaryItemModel = function () {
	  function SummaryItemModel(summary) {
	    _classCallCheck(this, SummaryItemModel);

	    if ((typeof summary === 'undefined' ? 'undefined' : _typeof(summary)) === 'object') {
	      this._createModel(summary);
	    } else {
	      this._createEmptyModel(summary);
	    }
	  }

	  SummaryItemModel.prototype._createModel = function _createModel(summary) {
	    var _getComponentAndOwner2 = this._getComponentAndOwner(summary),
	        owner = _getComponentAndOwner2.owner,
	        component = _getComponentAndOwner2.component;

	    this.owner = owner;
	    this.component = component;
	    this.wastedInstances = summary[WASTED_INSTANCES_KEY];
	    this.wastedTime = summary[WASTED_TIME_KEY];
	  };

	  SummaryItemModel.prototype._createEmptyModel = function _createEmptyModel(componentName) {
	    this.owner = componentName;
	    this.component = componentName;
	    this.wastedInstances = 0;
	    this.wastedTime = 0;
	  };

	  SummaryItemModel.prototype._getComponentAndOwner = function _getComponentAndOwner(summary) {
	    var ownerAndComponent = summary[OWNER_COMPONENT_KEY];
	    var splitOwnerComponent = ownerAndComponent.split('>');

	    return {
	      owner: splitOwnerComponent[0].trim(),
	      component: splitOwnerComponent[1].trim()
	    };
	  };

	  return SummaryItemModel;
	}();

	exports['default'] = SummaryItemModel;

/***/ }),
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = dirtyHandlerIds;
	exports.areDirty = areDirty;

	var _xor = __webpack_require__(340);

	var _xor2 = _interopRequireDefault(_xor);

	var _intersection = __webpack_require__(333);

	var _intersection2 = _interopRequireDefault(_intersection);

	var _dragDrop = __webpack_require__(36);

	var _registry = __webpack_require__(37);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var NONE = [];
	var ALL = [];

	function dirtyHandlerIds() {
		var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : NONE;
		var action = arguments[1];
		var dragOperation = arguments[2];

		switch (action.type) {
			case _dragDrop.HOVER:
				break;
			case _registry.ADD_SOURCE:
			case _registry.ADD_TARGET:
			case _registry.REMOVE_TARGET:
			case _registry.REMOVE_SOURCE:
				return NONE;
			case _dragDrop.BEGIN_DRAG:
			case _dragDrop.PUBLISH_DRAG_SOURCE:
			case _dragDrop.END_DRAG:
			case _dragDrop.DROP:
			default:
				return ALL;
		}

		var targetIds = action.targetIds;
		var prevTargetIds = dragOperation.targetIds;

		var result = (0, _xor2.default)(targetIds, prevTargetIds);

		var didChange = false;
		if (result.length === 0) {
			for (var i = 0; i < targetIds.length; i++) {
				if (targetIds[i] !== prevTargetIds[i]) {
					didChange = true;
					break;
				}
			}
		} else {
			didChange = true;
		}

		if (!didChange) {
			return NONE;
		}

		var prevInnermostTargetId = prevTargetIds[prevTargetIds.length - 1];
		var innermostTargetId = targetIds[targetIds.length - 1];

		if (prevInnermostTargetId !== innermostTargetId) {
			if (prevInnermostTargetId) {
				result.push(prevInnermostTargetId);
			}
			if (innermostTargetId) {
				result.push(innermostTargetId);
			}
		}

		return result;
	}

	function areDirty(state, handlerIds) {
		if (state === NONE) {
			return false;
		}

		if (state === ALL || typeof handlerIds === 'undefined') {
			return true;
		}

		return (0, _intersection2.default)(handlerIds, state).length > 0;
	}

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	exports.default = dragOffset;
	exports.getSourceClientOffset = getSourceClientOffset;
	exports.getDifferenceFromInitialOffset = getDifferenceFromInitialOffset;

	var _dragDrop = __webpack_require__(36);

	var initialState = {
		initialSourceClientOffset: null,
		initialClientOffset: null,
		clientOffset: null
	};

	function areOffsetsEqual(offsetA, offsetB) {
		if (offsetA === offsetB) {
			return true;
		}
		return offsetA && offsetB && offsetA.x === offsetB.x && offsetA.y === offsetB.y;
	}

	function dragOffset() {
		var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
		var action = arguments[1];

		switch (action.type) {
			case _dragDrop.BEGIN_DRAG:
				return {
					initialSourceClientOffset: action.sourceClientOffset,
					initialClientOffset: action.clientOffset,
					clientOffset: action.clientOffset
				};
			case _dragDrop.HOVER:
				if (areOffsetsEqual(state.clientOffset, action.clientOffset)) {
					return state;
				}
				return _extends({}, state, {
					clientOffset: action.clientOffset
				});
			case _dragDrop.END_DRAG:
			case _dragDrop.DROP:
				return initialState;
			default:
				return state;
		}
	}

	function getSourceClientOffset(state) {
		var clientOffset = state.clientOffset,
		    initialClientOffset = state.initialClientOffset,
		    initialSourceClientOffset = state.initialSourceClientOffset;

		if (!clientOffset || !initialClientOffset || !initialSourceClientOffset) {
			return null;
		}
		return {
			x: clientOffset.x + initialSourceClientOffset.x - initialClientOffset.x,
			y: clientOffset.y + initialSourceClientOffset.y - initialClientOffset.y
		};
	}

	function getDifferenceFromInitialOffset(state) {
		var clientOffset = state.clientOffset,
		    initialClientOffset = state.initialClientOffset;

		if (!clientOffset || !initialClientOffset) {
			return null;
		}
		return {
			x: clientOffset.x - initialClientOffset.x,
			y: clientOffset.y - initialClientOffset.y
		};
	}

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = matchesType;

	var _isArray = __webpack_require__(18);

	var _isArray2 = _interopRequireDefault(_isArray);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function matchesType(targetType, draggedItemType) {
		if ((0, _isArray2.default)(targetType)) {
			return targetType.some(function (t) {
				return t === draggedItemType;
			});
		} else {
			return targetType === draggedItemType;
		}
	}

/***/ }),
/* 114 */,
/* 115 */
33,
/* 116 */,
/* 117 */
[1596, 314, 315, 316, 317, 318],
/* 118 */
/***/ (function(module, exports) {

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}

	module.exports = apply;


/***/ }),
/* 119 */
[1628, 123],
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

	var SetCache = __webpack_require__(67),
	    arrayIncludes = __webpack_require__(69),
	    arrayIncludesWith = __webpack_require__(70),
	    arrayMap = __webpack_require__(71),
	    baseUnary = __webpack_require__(72),
	    cacheHas = __webpack_require__(73);

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * The base implementation of methods like `_.difference` without support
	 * for excluding multiple arrays or iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Array} values The values to exclude.
	 * @param {Function} [iteratee] The iteratee invoked per element.
	 * @param {Function} [comparator] The comparator invoked per element.
	 * @returns {Array} Returns the new array of filtered values.
	 */
	function baseDifference(array, values, iteratee, comparator) {
	  var index = -1,
	      includes = arrayIncludes,
	      isCommon = true,
	      length = array.length,
	      result = [],
	      valuesLength = values.length;

	  if (!length) {
	    return result;
	  }
	  if (iteratee) {
	    values = arrayMap(values, baseUnary(iteratee));
	  }
	  if (comparator) {
	    includes = arrayIncludesWith;
	    isCommon = false;
	  }
	  else if (values.length >= LARGE_ARRAY_SIZE) {
	    includes = cacheHas;
	    isCommon = false;
	    values = new SetCache(values);
	  }
	  outer:
	  while (++index < length) {
	    var value = array[index],
	        computed = iteratee == null ? value : iteratee(value);

	    value = (comparator || value !== 0) ? value : 0;
	    if (isCommon && computed === computed) {
	      var valuesIndex = valuesLength;
	      while (valuesIndex--) {
	        if (values[valuesIndex] === computed) {
	          continue outer;
	        }
	      }
	      result.push(value);
	    }
	    else if (!includes(values, computed, comparator)) {
	      result.push(value);
	    }
	  }
	  return result;
	}

	module.exports = baseDifference;


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

	var arrayPush = __webpack_require__(277),
	    isFlattenable = __webpack_require__(304);

	/**
	 * The base implementation of `_.flatten` with support for restricting flattening.
	 *
	 * @private
	 * @param {Array} array The array to flatten.
	 * @param {number} depth The maximum recursion depth.
	 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
	 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
	 * @param {Array} [result=[]] The initial result value.
	 * @returns {Array} Returns the new flattened array.
	 */
	function baseFlatten(array, depth, predicate, isStrict, result) {
	  var index = -1,
	      length = array.length;

	  predicate || (predicate = isFlattenable);
	  result || (result = []);

	  while (++index < length) {
	    var value = array[index];
	    if (depth > 0 && predicate(value)) {
	      if (depth > 1) {
	        // Recursively flatten arrays (susceptible to call stack limits).
	        baseFlatten(value, depth - 1, predicate, isStrict, result);
	      } else {
	        arrayPush(result, value);
	      }
	    } else if (!isStrict) {
	      result[result.length] = value;
	    }
	  }
	  return result;
	}

	module.exports = baseFlatten;


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

	var SetCache = __webpack_require__(67),
	    arrayIncludes = __webpack_require__(69),
	    arrayIncludesWith = __webpack_require__(70),
	    cacheHas = __webpack_require__(73),
	    createSet = __webpack_require__(294),
	    setToArray = __webpack_require__(126);

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} [iteratee] The iteratee invoked per element.
	 * @param {Function} [comparator] The comparator invoked per element.
	 * @returns {Array} Returns the new duplicate free array.
	 */
	function baseUniq(array, iteratee, comparator) {
	  var index = -1,
	      includes = arrayIncludes,
	      length = array.length,
	      isCommon = true,
	      result = [],
	      seen = result;

	  if (comparator) {
	    isCommon = false;
	    includes = arrayIncludesWith;
	  }
	  else if (length >= LARGE_ARRAY_SIZE) {
	    var set = iteratee ? null : createSet(array);
	    if (set) {
	      return setToArray(set);
	    }
	    isCommon = false;
	    includes = cacheHas;
	    seen = new SetCache;
	  }
	  else {
	    seen = iteratee ? [] : result;
	  }
	  outer:
	  while (++index < length) {
	    var value = array[index],
	        computed = iteratee ? iteratee(value) : value;

	    value = (comparator || value !== 0) ? value : 0;
	    if (isCommon && computed === computed) {
	      var seenIndex = seen.length;
	      while (seenIndex--) {
	        if (seen[seenIndex] === computed) {
	          continue outer;
	        }
	      }
	      if (iteratee) {
	        seen.push(computed);
	      }
	      result.push(value);
	    }
	    else if (!includes(seen, computed, comparator)) {
	      if (seen !== result) {
	        seen.push(computed);
	      }
	      result.push(value);
	    }
	  }
	  return result;
	}

	module.exports = baseUniq;


/***/ }),
/* 123 */
[1658, 42],
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof (window) == 'object' && (window) && (window).Object === Object && (window);

	module.exports = freeGlobal;


/***/ }),
/* 125 */
/***/ (function(module, exports) {

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return !!length &&
	    (typeof value == 'number' || reIsUint.test(value)) &&
	    (value > -1 && value % 1 == 0 && value < length);
	}

	module.exports = isIndex;


/***/ }),
/* 126 */
/***/ (function(module, exports) {

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	module.exports = setToArray;


/***/ }),
/* 127 */
/***/ (function(module, exports) {

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}

	module.exports = identity;


/***/ }),
/* 128 */
[1761, 282, 29],
/* 129 */
[1778, 40, 28],
/* 130 */
84,
/* 131 */
/***/ (function(module, exports) {

	/**
	 * This method returns `undefined`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.3.0
	 * @category Util
	 * @example
	 *
	 * _.times(2, _.noop);
	 * // => [undefined, undefined]
	 */
	function noop() {
	  // No operation performed.
	}

	module.exports = noop;


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

	var baseDifference = __webpack_require__(120),
	    baseRest = __webpack_require__(22),
	    isArrayLikeObject = __webpack_require__(45);

	/**
	 * Creates an array excluding all given values using
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * **Note:** Unlike `_.pull`, this method returns a new array.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @param {...*} [values] The values to exclude.
	 * @returns {Array} Returns the new array of filtered values.
	 * @see _.difference, _.xor
	 * @example
	 *
	 * _.without([2, 1, 2, 3], 1, 2);
	 * // => [3]
	 */
	var without = baseRest(function(array, values) {
	  return isArrayLikeObject(array)
	    ? baseDifference(array, values)
	    : [];
	});

	module.exports = without;


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _MenuItem = __webpack_require__(135);

	var _MenuItem2 = _interopRequireDefault(_MenuItem);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var AbstractMenu = function (_Component) {
	    _inherits(AbstractMenu, _Component);

	    function AbstractMenu(props) {
	        _classCallCheck(this, AbstractMenu);

	        var _this = _possibleConstructorReturn(this, (AbstractMenu.__proto__ || Object.getPrototypeOf(AbstractMenu)).call(this, props));

	        _initialiseProps.call(_this);

	        _this.seletedItemRef = null;
	        _this.state = {
	            selectedItem: null,
	            forceSubMenuOpen: false
	        };
	        return _this;
	    }

	    return AbstractMenu;
	}(_react.Component);

	AbstractMenu.propTypes = {
	    children: _propTypes2.default.node.isRequired
	};

	var _initialiseProps = function _initialiseProps() {
	    var _this2 = this;

	    this.handleKeyNavigation = function (e) {
	        // check for isVisible strictly here as it might be undefined when this code executes in the context of SubMenu
	        // but we only need to check when it runs in the ContextMenu context
	        if (_this2.state.isVisible === false) {
	            return;
	        }

	        switch (e.keyCode) {
	            case 37: // left arrow
	            case 27:
	                // escape
	                e.preventDefault();
	                _this2.hideMenu(e);
	                break;
	            case 38:
	                // up arrow
	                e.preventDefault();
	                _this2.selectChildren(true);
	                break;
	            case 40:
	                // down arrow
	                e.preventDefault();
	                _this2.selectChildren(false);
	                break;
	            case 39:
	                // right arrow
	                _this2.tryToOpenSubMenu(e);
	                break;
	            case 13:
	                // enter
	                e.preventDefault();
	                _this2.tryToOpenSubMenu(e);
	                {
	                    // determine the selected item is disabled or not
	                    var disabled = _this2.seletedItemRef && _this2.seletedItemRef.props && _this2.seletedItemRef.props.disabled;

	                    if (_this2.seletedItemRef && _this2.seletedItemRef.ref instanceof HTMLElement && !disabled) {
	                        _this2.seletedItemRef.ref.click();
	                    } else {
	                        _this2.hideMenu(e);
	                    }
	                }
	                break;
	            default:
	            // do nothing
	        }
	    };

	    this.handleForceClose = function () {
	        _this2.setState({ forceSubMenuOpen: false });
	    };

	    this.tryToOpenSubMenu = function (e) {
	        if (_this2.state.selectedItem && _this2.state.selectedItem.type === _this2.getSubMenuType()) {
	            e.preventDefault();
	            _this2.setState({ forceSubMenuOpen: true });
	        }
	    };

	    this.selectChildren = function (forward) {
	        var selectedItem = _this2.state.selectedItem;

	        var children = [];
	        var childCollector = function childCollector(child) {
	            // child can be empty in case you do conditional rendering of components, in which
	            // case it should not be accounted for as a real child
	            if (!child) {
	                return;
	            }

	            if ([_MenuItem2.default, _this2.getSubMenuType()].indexOf(child.type) < 0) {
	                // Maybe the MenuItem or SubMenu is capsuled in a wrapper div or something else
	                _react2.default.Children.forEach(child.props.children, childCollector);
	            } else if (!child.props.divider) {
	                children.push(child);
	            }
	        };
	        _react2.default.Children.forEach(_this2.props.children, childCollector);
	        var currentIndex = children.indexOf(selectedItem);
	        if (currentIndex < 0) {
	            _this2.setState({
	                selectedItem: forward ? children[children.length - 1] : children[0],
	                forceSubMenuOpen: false
	            });
	        } else if (forward) {
	            _this2.setState({
	                selectedItem: children[currentIndex - 1 < 0 ? children.length - 1 : currentIndex - 1],
	                forceSubMenuOpen: false
	            });
	        } else {
	            _this2.setState({
	                selectedItem: children[currentIndex + 1 < children.length ? currentIndex + 1 : 0],
	                forceSubMenuOpen: false
	            });
	        }
	    };

	    this.onChildMouseMove = function (child) {
	        if (_this2.state.selectedItem !== child) {
	            _this2.setState({ selectedItem: child, forceSubMenuOpen: false });
	        }
	    };

	    this.onChildMouseLeave = function () {
	        _this2.setState({ selectedItem: null, forceSubMenuOpen: false });
	    };

	    this.renderChildren = function (children) {
	        return _react2.default.Children.map(children, function (child) {
	            var props = {};
	            if (!_react2.default.isValidElement(child)) return child;
	            if ([_MenuItem2.default, _this2.getSubMenuType()].indexOf(child.type) < 0) {
	                // Maybe the MenuItem or SubMenu is capsuled in a wrapper div or something else
	                props.children = _this2.renderChildren(child.props.children);
	                return _react2.default.cloneElement(child, props);
	            }
	            props.onMouseLeave = _this2.onChildMouseLeave.bind(_this2);
	            if (child.type === _this2.getSubMenuType()) {
	                // special props for SubMenu only
	                props.forceOpen = _this2.state.forceSubMenuOpen && _this2.state.selectedItem === child;
	                props.forceClose = _this2.handleForceClose;
	                props.parentKeyNavigationHandler = _this2.handleKeyNavigation;
	            }
	            if (!child.props.divider && _this2.state.selectedItem === child) {
	                // special props for selected item only
	                props.selected = true;
	                props.ref = function (ref) {
	                    _this2.seletedItemRef = ref;
	                };
	                return _react2.default.cloneElement(child, props);
	            }
	            // onMouseMove is only needed for non selected items
	            props.onMouseMove = function () {
	                return _this2.onChildMouseMove(child);
	            };
	            return _react2.default.cloneElement(child, props);
	        });
	    };
	};

	exports.default = AbstractMenu;

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _classnames = __webpack_require__(46);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _objectAssign = __webpack_require__(30);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	var _actions = __webpack_require__(23);

	var _helpers = __webpack_require__(24);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var ContextMenuTrigger = function (_Component) {
	    _inherits(ContextMenuTrigger, _Component);

	    function ContextMenuTrigger() {
	        var _ref;

	        var _temp, _this, _ret;

	        _classCallCheck(this, ContextMenuTrigger);

	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }

	        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ContextMenuTrigger.__proto__ || Object.getPrototypeOf(ContextMenuTrigger)).call.apply(_ref, [this].concat(args))), _this), _this.touchHandled = false, _this.handleMouseDown = function (event) {
	            if (_this.props.holdToDisplay >= 0 && event.button === 0) {
	                event.persist();
	                event.stopPropagation();

	                _this.mouseDownTimeoutId = setTimeout(function () {
	                    return _this.handleContextClick(event);
	                }, _this.props.holdToDisplay);
	            }
	            (0, _helpers.callIfExists)(_this.props.attributes.onMouseDown, event);
	        }, _this.handleMouseUp = function (event) {
	            if (event.button === 0) {
	                clearTimeout(_this.mouseDownTimeoutId);
	            }
	            (0, _helpers.callIfExists)(_this.props.attributes.onMouseUp, event);
	        }, _this.handleMouseOut = function (event) {
	            if (event.button === 0) {
	                clearTimeout(_this.mouseDownTimeoutId);
	            }
	            (0, _helpers.callIfExists)(_this.props.attributes.onMouseOut, event);
	        }, _this.handleTouchstart = function (event) {
	            _this.touchHandled = false;

	            if (_this.props.holdToDisplay >= 0) {
	                event.persist();
	                event.stopPropagation();

	                _this.touchstartTimeoutId = setTimeout(function () {
	                    _this.handleContextClick(event);
	                    _this.touchHandled = true;
	                }, _this.props.holdToDisplay);
	            }
	            (0, _helpers.callIfExists)(_this.props.attributes.onTouchStart, event);
	        }, _this.handleTouchEnd = function (event) {
	            if (_this.touchHandled) {
	                event.preventDefault();
	            }
	            clearTimeout(_this.touchstartTimeoutId);
	            (0, _helpers.callIfExists)(_this.props.attributes.onTouchEnd, event);
	        }, _this.handleContextMenu = function (event) {
	            _this.handleContextClick(event);
	            (0, _helpers.callIfExists)(_this.props.attributes.onContextMenu, event);
	        }, _this.handleContextClick = function (event) {
	            if (_this.props.disable) return;

	            event.preventDefault();
	            event.stopPropagation();

	            var x = event.clientX || event.touches && event.touches[0].pageX;
	            var y = event.clientY || event.touches && event.touches[0].pageY;

	            (0, _actions.hideMenu)();

	            var data = (0, _helpers.callIfExists)(_this.props.collect, _this.props);
	            var showMenuConfig = {
	                position: { x: x, y: y },
	                target: _this.elem,
	                id: _this.props.id,
	                data: data
	            };
	            if (data && typeof data.then === 'function') {
	                // it's promise
	                data.then(function (resp) {
	                    showMenuConfig.data = resp;
	                    (0, _actions.showMenu)(showMenuConfig);
	                });
	            } else {
	                (0, _actions.showMenu)(showMenuConfig);
	            }
	        }, _this.elemRef = function (c) {
	            _this.elem = c;
	        }, _temp), _possibleConstructorReturn(_this, _ret);
	    }

	    _createClass(ContextMenuTrigger, [{
	        key: 'render',
	        value: function render() {
	            var _props = this.props,
	                renderTag = _props.renderTag,
	                attributes = _props.attributes,
	                children = _props.children;

	            var newAttrs = (0, _objectAssign2.default)({}, attributes, {
	                className: (0, _classnames2.default)(_helpers.cssClasses.menuWrapper, attributes.className),
	                onContextMenu: this.handleContextMenu,
	                onMouseDown: this.handleMouseDown,
	                onMouseUp: this.handleMouseUp,
	                onTouchStart: this.handleTouchstart,
	                onTouchEnd: this.handleTouchEnd,
	                onMouseOut: this.handleMouseOut,
	                ref: this.elemRef
	            });

	            return _react2.default.createElement(renderTag, newAttrs, children);
	        }
	    }]);

	    return ContextMenuTrigger;
	}(_react.Component);

	ContextMenuTrigger.propTypes = {
	    id: _propTypes2.default.string.isRequired,
	    children: _propTypes2.default.node.isRequired,
	    attributes: _propTypes2.default.object,
	    collect: _propTypes2.default.func,
	    disable: _propTypes2.default.bool,
	    holdToDisplay: _propTypes2.default.number,
	    renderTag: _propTypes2.default.oneOfType([_propTypes2.default.node, _propTypes2.default.func])
	};
	ContextMenuTrigger.defaultProps = {
	    attributes: {},
	    collect: function collect() {
	        return null;
	    },

	    disable: false,
	    holdToDisplay: 1000,
	    renderTag: 'div'
	};
	exports.default = ContextMenuTrigger;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _classnames = __webpack_require__(46);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _objectAssign = __webpack_require__(30);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	var _actions = __webpack_require__(23);

	var _helpers = __webpack_require__(24);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var MenuItem = function (_Component) {
	    _inherits(MenuItem, _Component);

	    function MenuItem() {
	        var _ref;

	        var _temp, _this, _ret;

	        _classCallCheck(this, MenuItem);

	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }

	        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = MenuItem.__proto__ || Object.getPrototypeOf(MenuItem)).call.apply(_ref, [this].concat(args))), _this), _this.handleClick = function (event) {
	            event.preventDefault();

	            if (_this.props.disabled || _this.props.divider) return;

	            (0, _helpers.callIfExists)(_this.props.onClick, event, (0, _objectAssign2.default)({}, _this.props.data, _helpers.store.data), _helpers.store.target);

	            if (_this.props.preventClose) return;

	            (0, _actions.hideMenu)();
	        }, _temp), _possibleConstructorReturn(_this, _ret);
	    }

	    _createClass(MenuItem, [{
	        key: 'render',
	        value: function render() {
	            var _cx,
	                _this2 = this;

	            var _props = this.props,
	                disabled = _props.disabled,
	                divider = _props.divider,
	                children = _props.children,
	                attributes = _props.attributes,
	                selected = _props.selected;

	            var menuItemClassNames = (0, _classnames2.default)(_helpers.cssClasses.menuItem, attributes && attributes.className, (_cx = {}, _defineProperty(_cx, _helpers.cssClasses.menuItemDisabled, disabled), _defineProperty(_cx, _helpers.cssClasses.menuItemDivider, divider), _defineProperty(_cx, _helpers.cssClasses.menuItemSelected, selected), _cx));

	            return _react2.default.createElement(
	                'div',
	                _extends({}, attributes, { className: menuItemClassNames,
	                    role: 'menuitem', tabIndex: '-1', 'aria-disabled': disabled ? 'true' : 'false',
	                    'aria-orientation': divider ? 'horizontal' : null,
	                    ref: function ref(_ref2) {
	                        _this2.ref = _ref2;
	                    },
	                    onMouseMove: this.props.onMouseMove, onMouseLeave: this.props.onMouseLeave,
	                    onTouchEnd: this.handleClick, onClick: this.handleClick }),
	                divider ? null : children
	            );
	        }
	    }]);

	    return MenuItem;
	}(_react.Component);

	MenuItem.propTypes = {
	    children: _propTypes2.default.node,
	    attributes: _propTypes2.default.object,
	    data: _propTypes2.default.object,
	    disabled: _propTypes2.default.bool,
	    divider: _propTypes2.default.bool,
	    preventClose: _propTypes2.default.bool,
	    onClick: _propTypes2.default.func,
	    selected: _propTypes2.default.bool,
	    onMouseMove: _propTypes2.default.func,
	    onMouseLeave: _propTypes2.default.func
	};
	MenuItem.defaultProps = {
	    disabled: false,
	    data: {},
	    divider: false,
	    attributes: {},
	    preventClose: false,
	    onClick: function onClick() {
	        return null;
	    },

	    children: null,
	    selected: false,
	    onMouseMove: function onMouseMove() {
	        return null;
	    },
	    onMouseLeave: function onMouseLeave() {
	        return null;
	    }
	};
	exports.default = MenuItem;

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _classnames = __webpack_require__(46);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _objectAssign = __webpack_require__(30);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	var _AbstractMenu2 = __webpack_require__(133);

	var _AbstractMenu3 = _interopRequireDefault(_AbstractMenu2);

	var _actions = __webpack_require__(23);

	var _helpers = __webpack_require__(24);

	var _globalEventListener = __webpack_require__(76);

	var _globalEventListener2 = _interopRequireDefault(_globalEventListener);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SubMenu = function (_AbstractMenu) {
	    _inherits(SubMenu, _AbstractMenu);

	    function SubMenu(props) {
	        _classCallCheck(this, SubMenu);

	        var _this = _possibleConstructorReturn(this, (SubMenu.__proto__ || Object.getPrototypeOf(SubMenu)).call(this, props));

	        _this.getMenuPosition = function () {
	            var _window = window,
	                innerWidth = _window.innerWidth,
	                innerHeight = _window.innerHeight;

	            var rect = _this.subMenu.getBoundingClientRect();
	            var position = {};

	            if (rect.bottom > innerHeight) {
	                position.bottom = 0;
	            } else {
	                position.top = 0;
	            }

	            if (rect.right < innerWidth) {
	                position.left = '100%';
	            } else {
	                position.right = '100%';
	            }

	            return position;
	        };

	        _this.getRTLMenuPosition = function () {
	            var _window2 = window,
	                innerHeight = _window2.innerHeight;

	            var rect = _this.subMenu.getBoundingClientRect();
	            var position = {};

	            if (rect.bottom > innerHeight) {
	                position.bottom = 0;
	            } else {
	                position.top = 0;
	            }

	            if (rect.left < 0) {
	                position.left = '100%';
	            } else {
	                position.right = '100%';
	            }

	            return position;
	        };

	        _this.hideMenu = function () {
	            if (_this.props.forceOpen) {
	                _this.props.forceClose();
	            }
	            _this.setState({ visible: false, selectedItem: null });
	            _this.unregisterHandlers();
	        };

	        _this.handleClick = function (event) {
	            event.preventDefault();

	            if (_this.props.disabled) return;

	            (0, _helpers.callIfExists)(_this.props.onClick, event, (0, _objectAssign2.default)({}, _this.props.data, _helpers.store.data), _helpers.store.target);

	            if (_this.props.preventClose) return;

	            (0, _actions.hideMenu)();
	        };

	        _this.handleMouseEnter = function () {
	            if (_this.closetimer) clearTimeout(_this.closetimer);

	            if (_this.props.disabled || _this.state.visible) return;

	            _this.opentimer = setTimeout(function () {
	                return _this.setState({
	                    visible: true,
	                    selectedItem: null
	                });
	            }, _this.props.hoverDelay);
	        };

	        _this.handleMouseLeave = function () {
	            if (_this.opentimer) clearTimeout(_this.opentimer);

	            if (!_this.state.visible) return;

	            _this.closetimer = setTimeout(function () {
	                return _this.setState({
	                    visible: false,
	                    selectedItem: null
	                });
	            }, _this.props.hoverDelay);
	        };

	        _this.menuRef = function (c) {
	            _this.menu = c;
	        };

	        _this.subMenuRef = function (c) {
	            _this.subMenu = c;
	        };

	        _this.registerHandlers = function () {
	            document.removeEventListener('keydown', _this.props.parentKeyNavigationHandler);
	            document.addEventListener('keydown', _this.handleKeyNavigation);
	        };

	        _this.unregisterHandlers = function () {
	            document.removeEventListener('keydown', _this.handleKeyNavigation);
	            document.addEventListener('keydown', _this.props.parentKeyNavigationHandler);
	        };

	        _this.state = (0, _objectAssign2.default)({}, _this.state, {
	            visible: false
	        });
	        return _this;
	    }

	    _createClass(SubMenu, [{
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            this.listenId = _globalEventListener2.default.register(function () {}, this.hideMenu);
	        }
	    }, {
	        key: 'getSubMenuType',
	        value: function getSubMenuType() {
	            // eslint-disable-line class-methods-use-this
	            return SubMenu;
	        }
	    }, {
	        key: 'shouldComponentUpdate',
	        value: function shouldComponentUpdate(nextProps, nextState) {
	            this.isVisibilityChange = (this.state.visible !== nextState.visible || this.props.forceOpen !== nextProps.forceOpen) && !(this.state.visible && nextProps.forceOpen) && !(this.props.forceOpen && nextState.visible);
	            return true;
	        }
	    }, {
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate() {
	            var _this2 = this;

	            if (!this.isVisibilityChange) return;
	            if (this.props.forceOpen || this.state.visible) {
	                var wrapper = window.requestAnimationFrame || setTimeout;
	                wrapper(function () {
	                    var styles = _this2.props.rtl ? _this2.getRTLMenuPosition() : _this2.getMenuPosition();

	                    _this2.subMenu.style.removeProperty('top');
	                    _this2.subMenu.style.removeProperty('bottom');
	                    _this2.subMenu.style.removeProperty('left');
	                    _this2.subMenu.style.removeProperty('right');

	                    if ((0, _helpers.hasOwnProp)(styles, 'top')) _this2.subMenu.style.top = styles.top;
	                    if ((0, _helpers.hasOwnProp)(styles, 'left')) _this2.subMenu.style.left = styles.left;
	                    if ((0, _helpers.hasOwnProp)(styles, 'bottom')) _this2.subMenu.style.bottom = styles.bottom;
	                    if ((0, _helpers.hasOwnProp)(styles, 'right')) _this2.subMenu.style.right = styles.right;
	                    _this2.subMenu.classList.add(_helpers.cssClasses.menuVisible);

	                    _this2.registerHandlers();
	                    _this2.setState({ selectedItem: null });
	                });
	            } else {
	                var cleanup = function cleanup() {
	                    _this2.subMenu.removeEventListener('transitionend', cleanup);
	                    _this2.subMenu.style.removeProperty('bottom');
	                    _this2.subMenu.style.removeProperty('right');
	                    _this2.subMenu.style.top = 0;
	                    _this2.subMenu.style.left = '100%';
	                    _this2.unregisterHandlers();
	                };
	                this.subMenu.addEventListener('transitionend', cleanup);
	                this.subMenu.classList.remove(_helpers.cssClasses.menuVisible);
	            }
	        }
	    }, {
	        key: 'componentWillUnmount',
	        value: function componentWillUnmount() {
	            if (this.listenId) {
	                _globalEventListener2.default.unregister(this.listenId);
	            }

	            if (this.opentimer) clearTimeout(this.opentimer);

	            if (this.closetimer) clearTimeout(this.closetimer);

	            this.unregisterHandlers();
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _cx;

	            var _props = this.props,
	                children = _props.children,
	                disabled = _props.disabled,
	                title = _props.title,
	                selected = _props.selected;
	            var visible = this.state.visible;

	            var menuProps = {
	                ref: this.menuRef,
	                onMouseEnter: this.handleMouseEnter,
	                onMouseLeave: this.handleMouseLeave,
	                className: (0, _classnames2.default)(_helpers.cssClasses.menuItem, _helpers.cssClasses.subMenu),
	                style: {
	                    position: 'relative'
	                }
	            };
	            var menuItemProps = {
	                className: (0, _classnames2.default)(_helpers.cssClasses.menuItem, (_cx = {}, _defineProperty(_cx, _helpers.cssClasses.menuItemDisabled, disabled), _defineProperty(_cx, _helpers.cssClasses.menuItemActive, visible), _defineProperty(_cx, _helpers.cssClasses.menuItemSelected, selected), _cx)),
	                onMouseMove: this.props.onMouseMove,
	                onMouseOut: this.props.onMouseOut,
	                onClick: this.handleClick
	            };
	            var subMenuProps = {
	                ref: this.subMenuRef,
	                style: {
	                    position: 'absolute',
	                    transition: 'opacity 1ms', // trigger transitionend event
	                    top: 0,
	                    left: '100%'
	                },
	                className: (0, _classnames2.default)(_helpers.cssClasses.menu, this.props.className)
	            };

	            return _react2.default.createElement(
	                'nav',
	                _extends({}, menuProps, { role: 'menuitem', tabIndex: '-1', 'aria-haspopup': 'true' }),
	                _react2.default.createElement(
	                    'div',
	                    menuItemProps,
	                    title
	                ),
	                _react2.default.createElement(
	                    'nav',
	                    _extends({}, subMenuProps, { role: 'menu', tabIndex: '-1' }),
	                    this.renderChildren(children)
	                )
	            );
	        }
	    }]);

	    return SubMenu;
	}(_AbstractMenu3.default);

	SubMenu.propTypes = {
	    children: _propTypes2.default.node.isRequired,
	    title: _propTypes2.default.node.isRequired,
	    className: _propTypes2.default.string,
	    disabled: _propTypes2.default.bool,
	    hoverDelay: _propTypes2.default.number,
	    rtl: _propTypes2.default.bool,
	    selected: _propTypes2.default.bool,
	    onMouseMove: _propTypes2.default.func,
	    onMouseOut: _propTypes2.default.func,
	    forceOpen: _propTypes2.default.bool,
	    forceClose: _propTypes2.default.func,
	    parentKeyNavigationHandler: _propTypes2.default.func
	};
	SubMenu.defaultProps = {
	    disabled: false,
	    hoverDelay: 500,
	    className: '',
	    rtl: false,
	    selected: false,
	    onMouseMove: function onMouseMove() {
	        return null;
	    },
	    onMouseOut: function onMouseOut() {
	        return null;
	    },
	    forceOpen: false,
	    forceClose: function forceClose() {
	        return null;
	    },
	    parentKeyNavigationHandler: function parentKeyNavigationHandler() {
	        return null;
	    }
	};
	exports.default = SubMenu;

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.isSafari = exports.isFirefox = undefined;

	var _memoize = __webpack_require__(337);

	var _memoize2 = _interopRequireDefault(_memoize);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var isFirefox = exports.isFirefox = (0, _memoize2.default)(function () {
	  return (/firefox/i.test(navigator.userAgent)
	  );
	});
	var isSafari = exports.isSafari = (0, _memoize2.default)(function () {
	  return Boolean(window.safari);
	});

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.getEmptyImage = exports.NativeTypes = undefined;
	exports.default = createHTML5Backend;

	var _HTML5Backend = __webpack_require__(345);

	var _HTML5Backend2 = _interopRequireDefault(_HTML5Backend);

	var _getEmptyImage = __webpack_require__(349);

	var _getEmptyImage2 = _interopRequireDefault(_getEmptyImage);

	var _NativeTypes = __webpack_require__(77);

	var NativeTypes = _interopRequireWildcard(_NativeTypes);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.NativeTypes = NativeTypes;
	exports.getEmptyImage = _getEmptyImage2.default;
	function createHTML5Backend(manager) {
		return new _HTML5Backend2.default(manager);
	}

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.unpackBackendForEs5Users = exports.createChildContext = exports.CHILD_CONTEXT_TYPES = undefined;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	exports.default = DragDropContext;

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _dndCore = __webpack_require__(259);

	var _invariant = __webpack_require__(8);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _hoistNonReactStatics = __webpack_require__(66);

	var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

	var _checkDecoratorArguments = __webpack_require__(47);

	var _checkDecoratorArguments2 = _interopRequireDefault(_checkDecoratorArguments);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var CHILD_CONTEXT_TYPES = exports.CHILD_CONTEXT_TYPES = {
		dragDropManager: _propTypes2.default.object.isRequired
	};

	var createChildContext = exports.createChildContext = function createChildContext(backend, context) {
		return {
			dragDropManager: new _dndCore.DragDropManager(backend, context)
		};
	};

	var unpackBackendForEs5Users = exports.unpackBackendForEs5Users = function unpackBackendForEs5Users(backendOrModule) {
		// Auto-detect ES6 default export for people still using ES5
		var backend = backendOrModule;
		if ((typeof backend === 'undefined' ? 'undefined' : _typeof(backend)) === 'object' && typeof backend.default === 'function') {
			backend = backend.default;
		}
		(0, _invariant2.default)(typeof backend === 'function', 'Expected the backend to be a function or an ES6 module exporting a default function. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-drop-context.html');
		return backend;
	};

	function DragDropContext(backendOrModule) {
		_checkDecoratorArguments2.default.apply(undefined, ['DragDropContext', 'backend'].concat(Array.prototype.slice.call(arguments))); // eslint-disable-line prefer-rest-params

		var backend = unpackBackendForEs5Users(backendOrModule);
		var childContext = createChildContext(backend);

		return function decorateContext(DecoratedComponent) {
			var _class, _temp;

			var displayName = DecoratedComponent.displayName || DecoratedComponent.name || 'Component';

			var DragDropContextContainer = (_temp = _class = function (_Component) {
				_inherits(DragDropContextContainer, _Component);

				function DragDropContextContainer() {
					_classCallCheck(this, DragDropContextContainer);

					return _possibleConstructorReturn(this, (DragDropContextContainer.__proto__ || Object.getPrototypeOf(DragDropContextContainer)).apply(this, arguments));
				}

				_createClass(DragDropContextContainer, [{
					key: 'getDecoratedComponentInstance',
					value: function getDecoratedComponentInstance() {
						(0, _invariant2.default)(this.child, 'In order to access an instance of the decorated component it can not be a stateless component.');
						return this.child;
					}
				}, {
					key: 'getManager',
					value: function getManager() {
						return childContext.dragDropManager;
					}
				}, {
					key: 'getChildContext',
					value: function getChildContext() {
						return childContext;
					}
				}, {
					key: 'render',
					value: function render() {
						var _this2 = this;

						return _react2.default.createElement(DecoratedComponent, _extends({}, this.props, {
							ref: function ref(child) {
								_this2.child = child;
							}
						}));
					}
				}]);

				return DragDropContextContainer;
			}(_react.Component), _class.DecoratedComponent = DecoratedComponent, _class.displayName = 'DragDropContext(' + displayName + ')', _class.childContextTypes = CHILD_CONTEXT_TYPES, _temp);


			return (0, _hoistNonReactStatics2.default)(DragDropContextContainer, DecoratedComponent);
		};
	}

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = areOptionsEqual;

	var _shallowEqual = __webpack_require__(78);

	var _shallowEqual2 = _interopRequireDefault(_shallowEqual);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function areOptionsEqual(nextOptions, currentOptions) {
		if (currentOptions === nextOptions) {
			return true;
		}

		return currentOptions !== null && nextOptions !== null && (0, _shallowEqual2.default)(currentOptions, nextOptions);
	}

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	exports.default = decorateHandler;

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _disposables = __webpack_require__(252);

	var _isPlainObject = __webpack_require__(19);

	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

	var _invariant = __webpack_require__(8);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _hoistNonReactStatics = __webpack_require__(66);

	var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

	var _shallowEqual = __webpack_require__(78);

	var _shallowEqual2 = _interopRequireDefault(_shallowEqual);

	var _shallowEqualScalar = __webpack_require__(143);

	var _shallowEqualScalar2 = _interopRequireDefault(_shallowEqualScalar);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var isClassComponent = function isClassComponent(Comp) {
		return Boolean(Comp && Comp.prototype && typeof Comp.prototype.render === 'function');
	};

	function decorateHandler(_ref) {
		var _class, _temp;

		var DecoratedComponent = _ref.DecoratedComponent,
		    createHandler = _ref.createHandler,
		    createMonitor = _ref.createMonitor,
		    createConnector = _ref.createConnector,
		    registerHandler = _ref.registerHandler,
		    containerDisplayName = _ref.containerDisplayName,
		    getType = _ref.getType,
		    collect = _ref.collect,
		    options = _ref.options;
		var _options$arePropsEqua = options.arePropsEqual,
		    arePropsEqual = _options$arePropsEqua === undefined ? _shallowEqualScalar2.default : _options$arePropsEqua;

		var displayName = DecoratedComponent.displayName || DecoratedComponent.name || 'Component';

		var DragDropContainer = (_temp = _class = function (_Component) {
			_inherits(DragDropContainer, _Component);

			_createClass(DragDropContainer, [{
				key: 'getHandlerId',
				value: function getHandlerId() {
					return this.handlerId;
				}
			}, {
				key: 'getDecoratedComponentInstance',
				value: function getDecoratedComponentInstance() {
					return this.decoratedComponentInstance;
				}
			}, {
				key: 'shouldComponentUpdate',
				value: function shouldComponentUpdate(nextProps, nextState) {
					return !arePropsEqual(nextProps, this.props) || !(0, _shallowEqual2.default)(nextState, this.state);
				}
			}]);

			function DragDropContainer(props, context) {
				_classCallCheck(this, DragDropContainer);

				var _this = _possibleConstructorReturn(this, (DragDropContainer.__proto__ || Object.getPrototypeOf(DragDropContainer)).call(this, props, context));

				_this.handleChange = _this.handleChange.bind(_this);
				_this.handleChildRef = _this.handleChildRef.bind(_this);

				(0, _invariant2.default)(_typeof(_this.context.dragDropManager) === 'object', 'Could not find the drag and drop manager in the context of %s. ' + 'Make sure to wrap the top-level component of your app with DragDropContext. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-troubleshooting.html#could-not-find-the-drag-and-drop-manager-in-the-context', displayName, displayName);

				_this.manager = _this.context.dragDropManager;
				_this.handlerMonitor = createMonitor(_this.manager);
				_this.handlerConnector = createConnector(_this.manager.getBackend());
				_this.handler = createHandler(_this.handlerMonitor);

				_this.disposable = new _disposables.SerialDisposable();
				_this.receiveProps(props);
				_this.state = _this.getCurrentState();
				_this.dispose();
				return _this;
			}

			_createClass(DragDropContainer, [{
				key: 'componentDidMount',
				value: function componentDidMount() {
					this.isCurrentlyMounted = true;
					this.disposable = new _disposables.SerialDisposable();
					this.currentType = null;
					this.receiveProps(this.props);
					this.handleChange();
				}
			}, {
				key: 'componentWillReceiveProps',
				value: function componentWillReceiveProps(nextProps) {
					if (!arePropsEqual(nextProps, this.props)) {
						this.receiveProps(nextProps);
						this.handleChange();
					}
				}
			}, {
				key: 'componentWillUnmount',
				value: function componentWillUnmount() {
					this.dispose();
					this.isCurrentlyMounted = false;
				}
			}, {
				key: 'receiveProps',
				value: function receiveProps(props) {
					this.handler.receiveProps(props);
					this.receiveType(getType(props));
				}
			}, {
				key: 'receiveType',
				value: function receiveType(type) {
					if (type === this.currentType) {
						return;
					}

					this.currentType = type;

					var _registerHandler = registerHandler(type, this.handler, this.manager),
					    handlerId = _registerHandler.handlerId,
					    unregister = _registerHandler.unregister;

					this.handlerId = handlerId;
					this.handlerMonitor.receiveHandlerId(handlerId);
					this.handlerConnector.receiveHandlerId(handlerId);

					var globalMonitor = this.manager.getMonitor();
					var unsubscribe = globalMonitor.subscribeToStateChange(this.handleChange, { handlerIds: [handlerId] });

					this.disposable.setDisposable(new _disposables.CompositeDisposable(new _disposables.Disposable(unsubscribe), new _disposables.Disposable(unregister)));
				}
			}, {
				key: 'handleChange',
				value: function handleChange() {
					if (!this.isCurrentlyMounted) {
						return;
					}

					var nextState = this.getCurrentState();
					if (!(0, _shallowEqual2.default)(nextState, this.state)) {
						this.setState(nextState);
					}
				}
			}, {
				key: 'dispose',
				value: function dispose() {
					this.disposable.dispose();
					this.handlerConnector.receiveHandlerId(null);
				}
			}, {
				key: 'handleChildRef',
				value: function handleChildRef(component) {
					this.decoratedComponentInstance = component;
					this.handler.receiveComponent(component);
				}
			}, {
				key: 'getCurrentState',
				value: function getCurrentState() {
					var nextState = collect(this.handlerConnector.hooks, this.handlerMonitor);

					if (false) {
						(0, _invariant2.default)((0, _isPlainObject2.default)(nextState), 'Expected `collect` specified as the second argument to ' + '%s for %s to return a plain object of props to inject. ' + 'Instead, received %s.', containerDisplayName, displayName, nextState);
					}

					return nextState;
				}
			}, {
				key: 'render',
				value: function render() {
					return _react2.default.createElement(DecoratedComponent, _extends({}, this.props, this.state, {
						ref: isClassComponent(DecoratedComponent) ? this.handleChildRef : null
					}));
				}
			}]);

			return DragDropContainer;
		}(_react.Component), _class.DecoratedComponent = DecoratedComponent, _class.displayName = containerDisplayName + '(' + displayName + ')', _class.contextTypes = {
			dragDropManager: _propTypes2.default.object.isRequired
		}, _temp);


		return (0, _hoistNonReactStatics2.default)(DragDropContainer, DecoratedComponent);
	}

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	exports.default = isValidType;

	var _isArray = __webpack_require__(18);

	var _isArray2 = _interopRequireDefault(_isArray);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function isValidType(type, allowArray) {
		return typeof type === 'string' || (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'symbol' || allowArray && (0, _isArray2.default)(type) && type.every(function (t) {
			return isValidType(t, false);
		});
	}

/***/ }),
/* 143 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	exports.default = shallowEqualScalar;
	function shallowEqualScalar(objA, objB) {
		if (objA === objB) {
			return true;
		}

		if ((typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) !== 'object' || objA === null || (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'object' || objB === null) {
			return false;
		}

		var keysA = Object.keys(objA);
		var keysB = Object.keys(objB);

		if (keysA.length !== keysB.length) {
			return false;
		}

		// Test for A's keys different from B.
		var hasOwn = Object.prototype.hasOwnProperty;
		for (var i = 0; i < keysA.length; i += 1) {
			if (!hasOwn.call(objB, keysA[i])) {
				return false;
			}

			var valA = objA[keysA[i]];
			var valB = objB[keysA[i]];

			if (valA !== valB || (typeof valA === 'undefined' ? 'undefined' : _typeof(valA)) === 'object' || (typeof valB === 'undefined' ? 'undefined' : _typeof(valB)) === 'object') {
				return false;
			}
		}

		return true;
	}

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = wrapConnectorHooks;

	var _react = __webpack_require__(2);

	var _cloneWithRef = __webpack_require__(363);

	var _cloneWithRef2 = _interopRequireDefault(_cloneWithRef);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function throwIfCompositeComponentElement(element) {
		// Custom components can no longer be wrapped directly in React DnD 2.0
		// so that we don't need to depend on findDOMNode() from react-dom.
		if (typeof element.type === 'string') {
			return;
		}

		var displayName = element.type.displayName || element.type.name || 'the component';

		throw new Error('Only native element nodes can now be passed to React DnD connectors.' + ('You can either wrap ' + displayName + ' into a <div>, or turn it into a ') + 'drag source or a drop target itself.');
	}

	function wrapHookToRecognizeElement(hook) {
		return function () {
			var elementOrNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
			var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

			// When passed a node, call the hook straight away.
			if (!(0, _react.isValidElement)(elementOrNode)) {
				var node = elementOrNode;
				hook(node, options);
				return undefined;
			}

			// If passed a ReactElement, clone it and attach this function as a ref.
			// This helps us achieve a neat API where user doesn't even know that refs
			// are being used under the hood.
			var element = elementOrNode;
			throwIfCompositeComponentElement(element);

			// When no options are passed, use the hook directly
			var ref = options ? function (node) {
				return hook(node, options);
			} : hook;

			return (0, _cloneWithRef2.default)(element, ref);
		};
	}

	function wrapConnectorHooks(hooks) {
		var wrappedHooks = {};

		Object.keys(hooks).forEach(function (key) {
			var hook = hooks[key];
			var wrappedHook = wrapHookToRecognizeElement(hook);
			wrappedHooks[key] = function () {
				return wrappedHook;
			};
		});

		return wrappedHooks;
	}

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _Select = __webpack_require__(48);

	var _Select2 = _interopRequireDefault(_Select);

	var _stripDiacritics = __webpack_require__(151);

	var _stripDiacritics2 = _interopRequireDefault(_stripDiacritics);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var propTypes = {
		autoload: _propTypes2.default.bool.isRequired, // automatically call the `loadOptions` prop on-mount; defaults to true
		cache: _propTypes2.default.any, // object to use to cache results; set to null/false to disable caching
		children: _propTypes2.default.func.isRequired, // Child function responsible for creating the inner Select component; (props: Object): PropTypes.element
		ignoreAccents: _propTypes2.default.bool, // strip diacritics when filtering; defaults to true
		ignoreCase: _propTypes2.default.bool, // perform case-insensitive filtering; defaults to true
		loadOptions: _propTypes2.default.func.isRequired, // callback to load options asynchronously; (inputValue: string, callback: Function): ?Promise
		loadingPlaceholder: _propTypes2.default.oneOfType([// replaces the placeholder while options are loading
		_propTypes2.default.string, _propTypes2.default.node]),
		multi: _propTypes2.default.bool, // multi-value input
		noResultsText: _propTypes2.default.oneOfType([// field noResultsText, displayed when no options come back from the server
		_propTypes2.default.string, _propTypes2.default.node]),
		onChange: _propTypes2.default.func, // onChange handler: function (newValue) {}
		onInputChange: _propTypes2.default.func, // optional for keeping track of what is being typed
		options: _propTypes2.default.array.isRequired, // array of options
		placeholder: _propTypes2.default.oneOfType([// field placeholder, displayed when there's no value (shared with Select)
		_propTypes2.default.string, _propTypes2.default.node]),
		searchPromptText: _propTypes2.default.oneOfType([// label to prompt for search input
		_propTypes2.default.string, _propTypes2.default.node]),
		value: _propTypes2.default.any // initial field value
	};

	var defaultCache = {};

	var defaultProps = {
		autoload: true,
		cache: defaultCache,
		children: defaultChildren,
		ignoreAccents: true,
		ignoreCase: true,
		loadingPlaceholder: 'Loading...',
		options: [],
		searchPromptText: 'Type to search'
	};

	var Async = function (_Component) {
		_inherits(Async, _Component);

		function Async(props, context) {
			_classCallCheck(this, Async);

			var _this = _possibleConstructorReturn(this, (Async.__proto__ || Object.getPrototypeOf(Async)).call(this, props, context));

			_this._cache = props.cache === defaultCache ? {} : props.cache;

			_this.state = {
				inputValue: '',
				isLoading: false,
				options: props.options
			};

			_this.onInputChange = _this.onInputChange.bind(_this);
			return _this;
		}

		_createClass(Async, [{
			key: 'componentDidMount',
			value: function componentDidMount() {
				var autoload = this.props.autoload;


				if (autoload) {
					this.loadOptions('');
				}
			}
		}, {
			key: 'componentWillReceiveProps',
			value: function componentWillReceiveProps(nextProps) {
				if (nextProps.options !== this.props.options) {
					this.setState({
						options: nextProps.options
					});
				}
			}
		}, {
			key: 'componentWillUnmount',
			value: function componentWillUnmount() {
				this._callback = null;
			}
		}, {
			key: 'loadOptions',
			value: function loadOptions(inputValue) {
				var _this2 = this;

				var loadOptions = this.props.loadOptions;

				var cache = this._cache;

				if (cache && Object.prototype.hasOwnProperty.call(cache, inputValue)) {
					this._callback = null;

					this.setState({
						isLoading: false,
						options: cache[inputValue]
					});

					return;
				}

				var callback = function callback(error, data) {
					var options = data && data.options || [];

					if (cache) {
						cache[inputValue] = options;
					}

					if (callback === _this2._callback) {
						_this2._callback = null;

						_this2.setState({
							isLoading: false,
							options: options
						});
					}
				};

				// Ignore all but the most recent request
				this._callback = callback;

				var promise = loadOptions(inputValue, callback);
				if (promise) {
					promise.then(function (data) {
						return callback(null, data);
					}, function (error) {
						return callback(error);
					});
				}

				if (this._callback && !this.state.isLoading) {
					this.setState({
						isLoading: true
					});
				}
			}
		}, {
			key: 'onInputChange',
			value: function onInputChange(inputValue) {
				var _props = this.props,
				    ignoreAccents = _props.ignoreAccents,
				    ignoreCase = _props.ignoreCase,
				    onInputChange = _props.onInputChange;

				var newInputValue = inputValue;

				if (onInputChange) {
					var value = onInputChange(newInputValue);
					// Note: != used deliberately here to catch undefined and null
					if (value != null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object') {
						newInputValue = '' + value;
					}
				}

				var transformedInputValue = newInputValue;

				if (ignoreAccents) {
					transformedInputValue = (0, _stripDiacritics2.default)(transformedInputValue);
				}

				if (ignoreCase) {
					transformedInputValue = transformedInputValue.toLowerCase();
				}

				this.setState({ inputValue: newInputValue });
				this.loadOptions(transformedInputValue);

				// Return new input value, but without applying toLowerCase() to avoid modifying the user's view case of the input while typing.
				return newInputValue;
			}
		}, {
			key: 'noResultsText',
			value: function noResultsText() {
				var _props2 = this.props,
				    loadingPlaceholder = _props2.loadingPlaceholder,
				    noResultsText = _props2.noResultsText,
				    searchPromptText = _props2.searchPromptText;
				var _state = this.state,
				    inputValue = _state.inputValue,
				    isLoading = _state.isLoading;


				if (isLoading) {
					return loadingPlaceholder;
				}
				if (inputValue && noResultsText) {
					return noResultsText;
				}
				return searchPromptText;
			}
		}, {
			key: 'focus',
			value: function focus() {
				this.select.focus();
			}
		}, {
			key: 'render',
			value: function render() {
				var _this3 = this;

				var _props3 = this.props,
				    children = _props3.children,
				    loadingPlaceholder = _props3.loadingPlaceholder,
				    multi = _props3.multi,
				    onChange = _props3.onChange,
				    placeholder = _props3.placeholder,
				    value = _props3.value;
				var _state2 = this.state,
				    isLoading = _state2.isLoading,
				    options = _state2.options;


				var props = {
					noResultsText: this.noResultsText(),
					placeholder: isLoading ? loadingPlaceholder : placeholder,
					options: isLoading && loadingPlaceholder ? [] : options,
					ref: function ref(_ref) {
						return _this3.select = _ref;
					}
				};

				return children(_extends({}, this.props, props, {
					isLoading: isLoading,
					onInputChange: this.onInputChange
				}));
			}
		}]);

		return Async;
	}(_react.Component);

	exports.default = Async;


	Async.propTypes = propTypes;
	Async.defaultProps = defaultProps;

	function defaultChildren(props) {
		return _react2.default.createElement(_Select2.default, props);
	}

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _Select = __webpack_require__(48);

	var _Select2 = _interopRequireDefault(_Select);

	var _defaultFilterOptions = __webpack_require__(79);

	var _defaultFilterOptions2 = _interopRequireDefault(_defaultFilterOptions);

	var _defaultMenuRenderer = __webpack_require__(80);

	var _defaultMenuRenderer2 = _interopRequireDefault(_defaultMenuRenderer);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var CreatableSelect = function (_React$Component) {
		_inherits(CreatableSelect, _React$Component);

		function CreatableSelect(props, context) {
			_classCallCheck(this, CreatableSelect);

			var _this = _possibleConstructorReturn(this, (CreatableSelect.__proto__ || Object.getPrototypeOf(CreatableSelect)).call(this, props, context));

			_this.filterOptions = _this.filterOptions.bind(_this);
			_this.menuRenderer = _this.menuRenderer.bind(_this);
			_this.onInputKeyDown = _this.onInputKeyDown.bind(_this);
			_this.onInputChange = _this.onInputChange.bind(_this);
			_this.onOptionSelect = _this.onOptionSelect.bind(_this);
			return _this;
		}

		_createClass(CreatableSelect, [{
			key: 'createNewOption',
			value: function createNewOption() {
				var _props = this.props,
				    isValidNewOption = _props.isValidNewOption,
				    newOptionCreator = _props.newOptionCreator,
				    onNewOptionClick = _props.onNewOptionClick,
				    _props$options = _props.options,
				    options = _props$options === undefined ? [] : _props$options,
				    shouldKeyDownEventCreateNewOption = _props.shouldKeyDownEventCreateNewOption;


				if (isValidNewOption({ label: this.inputValue })) {
					var option = newOptionCreator({ label: this.inputValue, labelKey: this.labelKey, valueKey: this.valueKey });
					var _isOptionUnique = this.isOptionUnique({ option: option });

					// Don't add the same option twice.
					if (_isOptionUnique) {
						if (onNewOptionClick) {
							onNewOptionClick(option);
						} else {
							options.unshift(option);

							this.select.selectValue(option);
						}
					}
				}
			}
		}, {
			key: 'filterOptions',
			value: function filterOptions() {
				var _props2 = this.props,
				    filterOptions = _props2.filterOptions,
				    isValidNewOption = _props2.isValidNewOption,
				    promptTextCreator = _props2.promptTextCreator;

				// TRICKY Check currently selected options as well.
				// Don't display a create-prompt for a value that's selected.
				// This covers async edge-cases where a newly-created Option isn't yet in the async-loaded array.

				var excludeOptions = (arguments.length <= 2 ? undefined : arguments[2]) || [];

				var filteredOptions = filterOptions.apply(undefined, arguments) || [];

				if (isValidNewOption({ label: this.inputValue })) {
					var _newOptionCreator = this.props.newOptionCreator;


					var option = _newOptionCreator({
						label: this.inputValue,
						labelKey: this.labelKey,
						valueKey: this.valueKey
					});

					// TRICKY Compare to all options (not just filtered options) in case option has already been selected).
					// For multi-selects, this would remove it from the filtered list.
					var _isOptionUnique2 = this.isOptionUnique({
						option: option,
						options: excludeOptions.concat(filteredOptions)
					});

					if (_isOptionUnique2) {
						var prompt = promptTextCreator(this.inputValue);

						this._createPlaceholderOption = _newOptionCreator({
							label: prompt,
							labelKey: this.labelKey,
							valueKey: this.valueKey
						});

						filteredOptions.unshift(this._createPlaceholderOption);
					}
				}

				return filteredOptions;
			}
		}, {
			key: 'isOptionUnique',
			value: function isOptionUnique(_ref) {
				var option = _ref.option,
				    options = _ref.options;
				var isOptionUnique = this.props.isOptionUnique;


				options = options || this.props.options;

				return isOptionUnique({
					labelKey: this.labelKey,
					option: option,
					options: options,
					valueKey: this.valueKey
				});
			}
		}, {
			key: 'menuRenderer',
			value: function menuRenderer(params) {
				var menuRenderer = this.props.menuRenderer;


				return menuRenderer(_extends({}, params, {
					onSelect: this.onOptionSelect,
					selectValue: this.onOptionSelect
				}));
			}
		}, {
			key: 'onInputChange',
			value: function onInputChange(input) {
				var onInputChange = this.props.onInputChange;

				// This value may be needed in between Select mounts (when this.select is null)

				this.inputValue = input;

				if (onInputChange) {
					this.inputValue = onInputChange(input);
				}

				return this.inputValue;
			}
		}, {
			key: 'onInputKeyDown',
			value: function onInputKeyDown(event) {
				var _props3 = this.props,
				    shouldKeyDownEventCreateNewOption = _props3.shouldKeyDownEventCreateNewOption,
				    onInputKeyDown = _props3.onInputKeyDown;

				var focusedOption = this.select.getFocusedOption();

				if (focusedOption && focusedOption === this._createPlaceholderOption && shouldKeyDownEventCreateNewOption({ keyCode: event.keyCode })) {
					this.createNewOption();

					// Prevent decorated Select from doing anything additional with this keyDown event
					event.preventDefault();
				} else if (onInputKeyDown) {
					onInputKeyDown(event);
				}
			}
		}, {
			key: 'onOptionSelect',
			value: function onOptionSelect(option, event) {
				if (option === this._createPlaceholderOption) {
					this.createNewOption();
				} else {
					this.select.selectValue(option);
				}
			}
		}, {
			key: 'focus',
			value: function focus() {
				this.select.focus();
			}
		}, {
			key: 'render',
			value: function render() {
				var _this2 = this;

				var _props4 = this.props,
				    newOptionCreator = _props4.newOptionCreator,
				    shouldKeyDownEventCreateNewOption = _props4.shouldKeyDownEventCreateNewOption,
				    refProp = _props4.ref,
				    restProps = _objectWithoutProperties(_props4, ['newOptionCreator', 'shouldKeyDownEventCreateNewOption', 'ref']);

				var children = this.props.children;

				// We can't use destructuring default values to set the children,
				// because it won't apply work if `children` is null. A falsy check is
				// more reliable in real world use-cases.

				if (!children) {
					children = defaultChildren;
				}

				var props = _extends({}, restProps, {
					allowCreate: true,
					filterOptions: this.filterOptions,
					menuRenderer: this.menuRenderer,
					onInputChange: this.onInputChange,
					onInputKeyDown: this.onInputKeyDown,
					ref: function ref(_ref2) {
						_this2.select = _ref2;

						// These values may be needed in between Select mounts (when this.select is null)
						if (_ref2) {
							_this2.labelKey = _ref2.props.labelKey;
							_this2.valueKey = _ref2.props.valueKey;
						}
						if (refProp) {
							refProp(_ref2);
						}
					}
				});

				return children(props);
			}
		}]);

		return CreatableSelect;
	}(_react2.default.Component);

	;

	function defaultChildren(props) {
		return _react2.default.createElement(_Select2.default, props);
	};

	function isOptionUnique(_ref3) {
		var option = _ref3.option,
		    options = _ref3.options,
		    labelKey = _ref3.labelKey,
		    valueKey = _ref3.valueKey;

		return options.filter(function (existingOption) {
			return existingOption[labelKey] === option[labelKey] || existingOption[valueKey] === option[valueKey];
		}).length === 0;
	};

	function isValidNewOption(_ref4) {
		var label = _ref4.label;

		return !!label;
	};

	function newOptionCreator(_ref5) {
		var label = _ref5.label,
		    labelKey = _ref5.labelKey,
		    valueKey = _ref5.valueKey;

		var option = {};
		option[valueKey] = label;
		option[labelKey] = label;
		option.className = 'Select-create-option-placeholder';
		return option;
	};

	function promptTextCreator(label) {
		return 'Create option "' + label + '"';
	}

	function shouldKeyDownEventCreateNewOption(_ref6) {
		var keyCode = _ref6.keyCode;

		switch (keyCode) {
			case 9: // TAB
			case 13: // ENTER
			case 188:
				// COMMA
				return true;
			default:
				return false;
		}
	};

	// Default prop methods
	CreatableSelect.isOptionUnique = isOptionUnique;
	CreatableSelect.isValidNewOption = isValidNewOption;
	CreatableSelect.newOptionCreator = newOptionCreator;
	CreatableSelect.promptTextCreator = promptTextCreator;
	CreatableSelect.shouldKeyDownEventCreateNewOption = shouldKeyDownEventCreateNewOption;

	CreatableSelect.defaultProps = {
		filterOptions: _defaultFilterOptions2.default,
		isOptionUnique: isOptionUnique,
		isValidNewOption: isValidNewOption,
		menuRenderer: _defaultMenuRenderer2.default,
		newOptionCreator: newOptionCreator,
		promptTextCreator: promptTextCreator,
		shouldKeyDownEventCreateNewOption: shouldKeyDownEventCreateNewOption
	};

	CreatableSelect.propTypes = {
		// Child function responsible for creating the inner Select component
		// This component can be used to compose HOCs (eg Creatable and Async)
		// (props: Object): PropTypes.element
		children: _propTypes2.default.func,

		// See Select.propTypes.filterOptions
		filterOptions: _propTypes2.default.any,

		// Searches for any matching option within the set of options.
		// This function prevents duplicate options from being created.
		// ({ option: Object, options: Array, labelKey: string, valueKey: string }): boolean
		isOptionUnique: _propTypes2.default.func,

		// Determines if the current input text represents a valid option.
		// ({ label: string }): boolean
		isValidNewOption: _propTypes2.default.func,

		// See Select.propTypes.menuRenderer
		menuRenderer: _propTypes2.default.any,

		// Factory to create new option.
		// ({ label: string, labelKey: string, valueKey: string }): Object
		newOptionCreator: _propTypes2.default.func,

		// input change handler: function (inputValue) {}
		onInputChange: _propTypes2.default.func,

		// input keyDown handler: function (event) {}
		onInputKeyDown: _propTypes2.default.func,

		// new option click handler: function (option) {}
		onNewOptionClick: _propTypes2.default.func,

		// See Select.propTypes.options
		options: _propTypes2.default.array,

		// Creates prompt/placeholder option text.
		// (filterText: string): string
		promptTextCreator: _propTypes2.default.func,

		ref: _propTypes2.default.func,

		// Decides if a keyDown event (eg its `keyCode`) should result in the creation of a new option.
		shouldKeyDownEventCreateNewOption: _propTypes2.default.func
	};

	exports.default = CreatableSelect;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _classnames = __webpack_require__(49);

	var _classnames2 = _interopRequireDefault(_classnames);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Option = function (_React$Component) {
		_inherits(Option, _React$Component);

		function Option(props) {
			_classCallCheck(this, Option);

			var _this = _possibleConstructorReturn(this, (Option.__proto__ || Object.getPrototypeOf(Option)).call(this, props));

			_this.handleMouseDown = _this.handleMouseDown.bind(_this);
			_this.handleMouseEnter = _this.handleMouseEnter.bind(_this);
			_this.handleMouseMove = _this.handleMouseMove.bind(_this);
			_this.handleTouchStart = _this.handleTouchStart.bind(_this);
			_this.handleTouchEnd = _this.handleTouchEnd.bind(_this);
			_this.handleTouchMove = _this.handleTouchMove.bind(_this);
			_this.onFocus = _this.onFocus.bind(_this);
			return _this;
		}

		_createClass(Option, [{
			key: 'blockEvent',
			value: function blockEvent(event) {
				event.preventDefault();
				event.stopPropagation();
				if (event.target.tagName !== 'A' || !('href' in event.target)) {
					return;
				}
				if (event.target.target) {
					window.open(event.target.href, event.target.target);
				} else {
					window.location.href = event.target.href;
				}
			}
		}, {
			key: 'handleMouseDown',
			value: function handleMouseDown(event) {
				event.preventDefault();
				event.stopPropagation();
				this.props.onSelect(this.props.option, event);
			}
		}, {
			key: 'handleMouseEnter',
			value: function handleMouseEnter(event) {
				this.onFocus(event);
			}
		}, {
			key: 'handleMouseMove',
			value: function handleMouseMove(event) {
				this.onFocus(event);
			}
		}, {
			key: 'handleTouchEnd',
			value: function handleTouchEnd(event) {
				// Check if the view is being dragged, In this case
				// we don't want to fire the click event (because the user only wants to scroll)
				if (this.dragging) return;

				this.handleMouseDown(event);
			}
		}, {
			key: 'handleTouchMove',
			value: function handleTouchMove(event) {
				// Set a flag that the view is being dragged
				this.dragging = true;
			}
		}, {
			key: 'handleTouchStart',
			value: function handleTouchStart(event) {
				// Set a flag that the view is not being dragged
				this.dragging = false;
			}
		}, {
			key: 'onFocus',
			value: function onFocus(event) {
				if (!this.props.isFocused) {
					this.props.onFocus(this.props.option, event);
				}
			}
		}, {
			key: 'render',
			value: function render() {
				var _props = this.props,
				    option = _props.option,
				    instancePrefix = _props.instancePrefix,
				    optionIndex = _props.optionIndex;

				var className = (0, _classnames2.default)(this.props.className, option.className);

				return option.disabled ? _react2.default.createElement(
					'div',
					{ className: className,
						onMouseDown: this.blockEvent,
						onClick: this.blockEvent },
					this.props.children
				) : _react2.default.createElement(
					'div',
					{ className: className,
						style: option.style,
						role: 'option',
						'aria-label': option.label,
						onMouseDown: this.handleMouseDown,
						onMouseEnter: this.handleMouseEnter,
						onMouseMove: this.handleMouseMove,
						onTouchStart: this.handleTouchStart,
						onTouchMove: this.handleTouchMove,
						onTouchEnd: this.handleTouchEnd,
						id: instancePrefix + '-option-' + optionIndex,
						title: option.title },
					this.props.children
				);
			}
		}]);

		return Option;
	}(_react2.default.Component);

	;

	Option.propTypes = {
		children: _propTypes2.default.node,
		className: _propTypes2.default.string, // className (based on mouse position)
		instancePrefix: _propTypes2.default.string.isRequired, // unique prefix for the ids (used for aria)
		isDisabled: _propTypes2.default.bool, // the option is disabled
		isFocused: _propTypes2.default.bool, // the option is focused
		isSelected: _propTypes2.default.bool, // the option is selected
		onFocus: _propTypes2.default.func, // method to handle mouseEnter on option element
		onSelect: _propTypes2.default.func, // method to handle click on option element
		onUnfocus: _propTypes2.default.func, // method to handle mouseLeave on option element
		option: _propTypes2.default.object.isRequired, // object that is base for that option
		optionIndex: _propTypes2.default.number // index of the option, used to generate unique ids for aria
	};

	exports.default = Option;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _classnames = __webpack_require__(49);

	var _classnames2 = _interopRequireDefault(_classnames);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Value = function (_React$Component) {
		_inherits(Value, _React$Component);

		function Value(props) {
			_classCallCheck(this, Value);

			var _this = _possibleConstructorReturn(this, (Value.__proto__ || Object.getPrototypeOf(Value)).call(this, props));

			_this.handleMouseDown = _this.handleMouseDown.bind(_this);
			_this.onRemove = _this.onRemove.bind(_this);
			_this.handleTouchEndRemove = _this.handleTouchEndRemove.bind(_this);
			_this.handleTouchMove = _this.handleTouchMove.bind(_this);
			_this.handleTouchStart = _this.handleTouchStart.bind(_this);
			return _this;
		}

		_createClass(Value, [{
			key: 'handleMouseDown',
			value: function handleMouseDown(event) {
				if (event.type === 'mousedown' && event.button !== 0) {
					return;
				}
				if (this.props.onClick) {
					event.stopPropagation();
					this.props.onClick(this.props.value, event);
					return;
				}
				if (this.props.value.href) {
					event.stopPropagation();
				}
			}
		}, {
			key: 'onRemove',
			value: function onRemove(event) {
				event.preventDefault();
				event.stopPropagation();
				this.props.onRemove(this.props.value);
			}
		}, {
			key: 'handleTouchEndRemove',
			value: function handleTouchEndRemove(event) {
				// Check if the view is being dragged, In this case
				// we don't want to fire the click event (because the user only wants to scroll)
				if (this.dragging) return;

				// Fire the mouse events
				this.onRemove(event);
			}
		}, {
			key: 'handleTouchMove',
			value: function handleTouchMove(event) {
				// Set a flag that the view is being dragged
				this.dragging = true;
			}
		}, {
			key: 'handleTouchStart',
			value: function handleTouchStart(event) {
				// Set a flag that the view is not being dragged
				this.dragging = false;
			}
		}, {
			key: 'renderRemoveIcon',
			value: function renderRemoveIcon() {
				if (this.props.disabled || !this.props.onRemove) return;
				return _react2.default.createElement(
					'span',
					{ className: 'Select-value-icon',
						'aria-hidden': 'true',
						onMouseDown: this.onRemove,
						onTouchEnd: this.handleTouchEndRemove,
						onTouchStart: this.handleTouchStart,
						onTouchMove: this.handleTouchMove },
					'\xD7'
				);
			}
		}, {
			key: 'renderLabel',
			value: function renderLabel() {
				var className = 'Select-value-label';
				return this.props.onClick || this.props.value.href ? _react2.default.createElement(
					'a',
					{ className: className, href: this.props.value.href, target: this.props.value.target, onMouseDown: this.handleMouseDown, onTouchEnd: this.handleMouseDown },
					this.props.children
				) : _react2.default.createElement(
					'span',
					{ className: className, role: 'option', 'aria-selected': 'true', id: this.props.id },
					this.props.children
				);
			}
		}, {
			key: 'render',
			value: function render() {
				return _react2.default.createElement(
					'div',
					{ className: (0, _classnames2.default)('Select-value', this.props.value.className),
						style: this.props.value.style,
						title: this.props.value.title
					},
					this.renderRemoveIcon(),
					this.renderLabel()
				);
			}
		}]);

		return Value;
	}(_react2.default.Component);

	;

	Value.propTypes = {
		children: _propTypes2.default.node,
		disabled: _propTypes2.default.bool, // disabled prop passed to ReactSelect
		id: _propTypes2.default.string, // Unique id for the value - used for aria
		onClick: _propTypes2.default.func, // method to handle click on value label
		onRemove: _propTypes2.default.func, // method to handle removal of the value
		value: _propTypes2.default.object.isRequired // the option object for this value
	};

	exports.default = Value;

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = arrowRenderer;

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function arrowRenderer(_ref) {
		var onMouseDown = _ref.onMouseDown;

		return _react2.default.createElement('span', {
			className: 'Select-arrow',
			onMouseDown: onMouseDown
		});
	};

	arrowRenderer.propTypes = {
		onMouseDown: _propTypes2.default.func
	};

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = clearRenderer;

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function clearRenderer() {
		return _react2.default.createElement('span', {
			className: 'Select-clear',
			dangerouslySetInnerHTML: { __html: '&times;' }
		});
	};

/***/ }),
/* 151 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = stripDiacritics;
	var map = [{ 'base': 'A', 'letters': /[\u0041\u24B6\uFF21\u00C0\u00C1\u00C2\u1EA6\u1EA4\u1EAA\u1EA8\u00C3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\u00C4\u01DE\u1EA2\u00C5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F]/g }, { 'base': 'AA', 'letters': /[\uA732]/g }, { 'base': 'AE', 'letters': /[\u00C6\u01FC\u01E2]/g }, { 'base': 'AO', 'letters': /[\uA734]/g }, { 'base': 'AU', 'letters': /[\uA736]/g }, { 'base': 'AV', 'letters': /[\uA738\uA73A]/g }, { 'base': 'AY', 'letters': /[\uA73C]/g }, { 'base': 'B', 'letters': /[\u0042\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181]/g }, { 'base': 'C', 'letters': /[\u0043\u24B8\uFF23\u0106\u0108\u010A\u010C\u00C7\u1E08\u0187\u023B\uA73E]/g }, { 'base': 'D', 'letters': /[\u0044\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779]/g }, { 'base': 'DZ', 'letters': /[\u01F1\u01C4]/g }, { 'base': 'Dz', 'letters': /[\u01F2\u01C5]/g }, { 'base': 'E', 'letters': /[\u0045\u24BA\uFF25\u00C8\u00C9\u00CA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\u00CB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E]/g }, { 'base': 'F', 'letters': /[\u0046\u24BB\uFF26\u1E1E\u0191\uA77B]/g }, { 'base': 'G', 'letters': /[\u0047\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E]/g }, { 'base': 'H', 'letters': /[\u0048\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D]/g }, { 'base': 'I', 'letters': /[\u0049\u24BE\uFF29\u00CC\u00CD\u00CE\u0128\u012A\u012C\u0130\u00CF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197]/g }, { 'base': 'J', 'letters': /[\u004A\u24BF\uFF2A\u0134\u0248]/g }, { 'base': 'K', 'letters': /[\u004B\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2]/g }, { 'base': 'L', 'letters': /[\u004C\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780]/g }, { 'base': 'LJ', 'letters': /[\u01C7]/g }, { 'base': 'Lj', 'letters': /[\u01C8]/g }, { 'base': 'M', 'letters': /[\u004D\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C]/g }, { 'base': 'N', 'letters': /[\u004E\u24C3\uFF2E\u01F8\u0143\u00D1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4]/g }, { 'base': 'NJ', 'letters': /[\u01CA]/g }, { 'base': 'Nj', 'letters': /[\u01CB]/g }, { 'base': 'O', 'letters': /[\u004F\u24C4\uFF2F\u00D2\u00D3\u00D4\u1ED2\u1ED0\u1ED6\u1ED4\u00D5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\u00D6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\u00D8\u01FE\u0186\u019F\uA74A\uA74C]/g }, { 'base': 'OI', 'letters': /[\u01A2]/g }, { 'base': 'OO', 'letters': /[\uA74E]/g }, { 'base': 'OU', 'letters': /[\u0222]/g }, { 'base': 'P', 'letters': /[\u0050\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754]/g }, { 'base': 'Q', 'letters': /[\u0051\u24C6\uFF31\uA756\uA758\u024A]/g }, { 'base': 'R', 'letters': /[\u0052\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782]/g }, { 'base': 'S', 'letters': /[\u0053\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784]/g }, { 'base': 'T', 'letters': /[\u0054\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786]/g }, { 'base': 'TZ', 'letters': /[\uA728]/g }, { 'base': 'U', 'letters': /[\u0055\u24CA\uFF35\u00D9\u00DA\u00DB\u0168\u1E78\u016A\u1E7A\u016C\u00DC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244]/g }, { 'base': 'V', 'letters': /[\u0056\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245]/g }, { 'base': 'VY', 'letters': /[\uA760]/g }, { 'base': 'W', 'letters': /[\u0057\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72]/g }, { 'base': 'X', 'letters': /[\u0058\u24CD\uFF38\u1E8A\u1E8C]/g }, { 'base': 'Y', 'letters': /[\u0059\u24CE\uFF39\u1EF2\u00DD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE]/g }, { 'base': 'Z', 'letters': /[\u005A\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762]/g }, { 'base': 'a', 'letters': /[\u0061\u24D0\uFF41\u1E9A\u00E0\u00E1\u00E2\u1EA7\u1EA5\u1EAB\u1EA9\u00E3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\u00E4\u01DF\u1EA3\u00E5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250]/g }, { 'base': 'aa', 'letters': /[\uA733]/g }, { 'base': 'ae', 'letters': /[\u00E6\u01FD\u01E3]/g }, { 'base': 'ao', 'letters': /[\uA735]/g }, { 'base': 'au', 'letters': /[\uA737]/g }, { 'base': 'av', 'letters': /[\uA739\uA73B]/g }, { 'base': 'ay', 'letters': /[\uA73D]/g }, { 'base': 'b', 'letters': /[\u0062\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253]/g }, { 'base': 'c', 'letters': /[\u0063\u24D2\uFF43\u0107\u0109\u010B\u010D\u00E7\u1E09\u0188\u023C\uA73F\u2184]/g }, { 'base': 'd', 'letters': /[\u0064\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A]/g }, { 'base': 'dz', 'letters': /[\u01F3\u01C6]/g }, { 'base': 'e', 'letters': /[\u0065\u24D4\uFF45\u00E8\u00E9\u00EA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\u00EB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD]/g }, { 'base': 'f', 'letters': /[\u0066\u24D5\uFF46\u1E1F\u0192\uA77C]/g }, { 'base': 'g', 'letters': /[\u0067\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F]/g }, { 'base': 'h', 'letters': /[\u0068\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265]/g }, { 'base': 'hv', 'letters': /[\u0195]/g }, { 'base': 'i', 'letters': /[\u0069\u24D8\uFF49\u00EC\u00ED\u00EE\u0129\u012B\u012D\u00EF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131]/g }, { 'base': 'j', 'letters': /[\u006A\u24D9\uFF4A\u0135\u01F0\u0249]/g }, { 'base': 'k', 'letters': /[\u006B\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3]/g }, { 'base': 'l', 'letters': /[\u006C\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747]/g }, { 'base': 'lj', 'letters': /[\u01C9]/g }, { 'base': 'm', 'letters': /[\u006D\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F]/g }, { 'base': 'n', 'letters': /[\u006E\u24DD\uFF4E\u01F9\u0144\u00F1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5]/g }, { 'base': 'nj', 'letters': /[\u01CC]/g }, { 'base': 'o', 'letters': /[\u006F\u24DE\uFF4F\u00F2\u00F3\u00F4\u1ED3\u1ED1\u1ED7\u1ED5\u00F5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\u00F6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\u00F8\u01FF\u0254\uA74B\uA74D\u0275]/g }, { 'base': 'oi', 'letters': /[\u01A3]/g }, { 'base': 'ou', 'letters': /[\u0223]/g }, { 'base': 'oo', 'letters': /[\uA74F]/g }, { 'base': 'p', 'letters': /[\u0070\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755]/g }, { 'base': 'q', 'letters': /[\u0071\u24E0\uFF51\u024B\uA757\uA759]/g }, { 'base': 'r', 'letters': /[\u0072\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783]/g }, { 'base': 's', 'letters': /[\u0073\u24E2\uFF53\u00DF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B]/g }, { 'base': 't', 'letters': /[\u0074\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787]/g }, { 'base': 'tz', 'letters': /[\uA729]/g }, { 'base': 'u', 'letters': /[\u0075\u24E4\uFF55\u00F9\u00FA\u00FB\u0169\u1E79\u016B\u1E7B\u016D\u00FC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289]/g }, { 'base': 'v', 'letters': /[\u0076\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C]/g }, { 'base': 'vy', 'letters': /[\uA761]/g }, { 'base': 'w', 'letters': /[\u0077\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73]/g }, { 'base': 'x', 'letters': /[\u0078\u24E7\uFF58\u1E8B\u1E8D]/g }, { 'base': 'y', 'letters': /[\u0079\u24E8\uFF59\u1EF3\u00FD\u0177\u1EF9\u0233\u1E8F\u00FF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF]/g }, { 'base': 'z', 'letters': /[\u007A\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763]/g }];

	function stripDiacritics(str) {
		for (var i = 0; i < map.length; i++) {
			str = str.replace(map[i].letters, map[i].base);
		}
		return str;
	};

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

	var ListCache = __webpack_require__(50),
	    stackClear = __webpack_require__(450),
	    stackDelete = __webpack_require__(451),
	    stackGet = __webpack_require__(452),
	    stackHas = __webpack_require__(453),
	    stackSet = __webpack_require__(454);

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  var data = this.__data__ = new ListCache(entries);
	  this.size = data.size;
	}

	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;

	module.exports = Stack;


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

	var castPath = __webpack_require__(155),
	    toKey = __webpack_require__(55);

	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path) {
	  path = castPath(path, object);

	  var index = 0,
	      length = path.length;

	  while (object != null && index < length) {
	    object = object[toKey(path[index++])];
	  }
	  return (index && index == length) ? object : undefined;
	}

	module.exports = baseGet;


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

	var baseIsEqualDeep = __webpack_require__(395),
	    isObjectLike = __webpack_require__(32);

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Unordered comparison
	 *  2 - Partial comparison
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, bitmask, customizer, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	}

	module.exports = baseIsEqual;


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

	var isArray = __webpack_require__(12),
	    isKey = __webpack_require__(83),
	    stringToPath = __webpack_require__(455),
	    toString = __webpack_require__(464);

	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath(value, object) {
	  if (isArray(value)) {
	    return value;
	  }
	  return isKey(value, object) ? [value] : stringToPath(toString(value));
	}

	module.exports = castPath;


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

	var SetCache = __webpack_require__(378),
	    arraySome = __webpack_require__(386),
	    cacheHas = __webpack_require__(408);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      arrLength = array.length,
	      othLength = other.length;

	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(array);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

	  stack.set(array, other);
	  stack.set(other, array);

	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function(othValue, othIndex) {
	            if (!cacheHas(seen, othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	              return seen.push(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, bitmask, customizer, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}

	module.exports = equalArrays;


/***/ }),
/* 157 */
124,
/* 158 */
125,
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(85);

	/**
	 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` if suitable for strict
	 *  equality comparisons, else `false`.
	 */
	function isStrictComparable(value) {
	  return value === value && !isObject(value);
	}

	module.exports = isStrictComparable;


/***/ }),
/* 160 */
/***/ (function(module, exports) {

	/**
	 * A specialized version of `matchesProperty` for source values suitable
	 * for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function matchesStrictComparable(key, srcValue) {
	  return function(object) {
	    if (object == null) {
	      return false;
	    }
	    return object[key] === srcValue &&
	      (srcValue !== undefined || (key in Object(object)));
	  };
	}

	module.exports = matchesStrictComparable;


/***/ }),
/* 161 */
/***/ (function(module, exports) {

	/** Used for built-in method references. */
	var funcProto = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	module.exports = toSource;


/***/ }),
/* 162 */
44,
/* 163 */
[1761, 394, 32],
/* 164 */
[1768, 166, 84],
/* 165 */
[1773, 11, 463],
/* 166 */
[1778, 31, 85],
/* 167 */
[1782, 398, 407, 444],
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	// rawAsap provides everything we need except exception management.
	var rawAsap = __webpack_require__(176);
	// RawTasks are recycled to reduce GC churn.
	var freeTasks = [];
	// We queue errors to ensure they are thrown in right order (FIFO).
	// Array-as-queue is good enough here, since we are just dealing with exceptions.
	var pendingErrors = [];
	var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);

	function throwFirstError() {
	    if (pendingErrors.length) {
	        throw pendingErrors.shift();
	    }
	}

	/**
	 * Calls a task as soon as possible after returning, in its own event, with priority
	 * over other events like animation, reflow, and repaint. An error thrown from an
	 * event will not interrupt, nor even substantially slow down the processing of
	 * other events, but will be rather postponed to a lower priority event.
	 * @param {{call}} task A callable object, typically a function that takes no
	 * arguments.
	 */
	module.exports = asap;
	function asap(task) {
	    var rawTask;
	    if (freeTasks.length) {
	        rawTask = freeTasks.pop();
	    } else {
	        rawTask = new RawTask();
	    }
	    rawTask.task = task;
	    rawAsap(rawTask);
	}

	// We wrap tasks with recyclable task objects.  A task object implements
	// `call`, just like a function.
	function RawTask() {
	    this.task = null;
	}

	// The sole purpose of wrapping the task is to catch the exception and recycle
	// the task object after its single use.
	RawTask.prototype.call = function () {
	    try {
	        this.task.call();
	    } catch (error) {
	        if (asap.onerror) {
	            // This hook exists purely for testing purposes.
	            // Its name will be periodically randomized to break any code that
	            // depends on its existence.
	            asap.onerror(error);
	        } else {
	            // In a web browser, exceptions are not fatal. However, to avoid
	            // slowing down the queue of pending tasks, we rethrow the error in a
	            // lower priority turn.
	            pendingErrors.push(error);
	            requestErrorThrow();
	        }
	    } finally {
	        this.task = null;
	        freeTasks[freeTasks.length] = this;
	    }
	};


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	// Use the fastest means possible to execute a task in its own turn, with
	// priority over other events including IO, animation, reflow, and redraw
	// events in browsers.
	//
	// An exception thrown by a task will permanently interrupt the processing of
	// subsequent tasks. The higher level `asap` function ensures that if an
	// exception is thrown by a task, that the task queue will continue flushing as
	// soon as possible, but if you use `rawAsap` directly, you are responsible to
	// either ensure that no exceptions are thrown from your task, or to manually
	// call `rawAsap.requestFlush` if an exception is thrown.
	module.exports = rawAsap;
	function rawAsap(task) {
	    if (!queue.length) {
	        requestFlush();
	        flushing = true;
	    }
	    // Equivalent to push, but avoids a function call.
	    queue[queue.length] = task;
	}

	var queue = [];
	// Once a flush has been requested, no further calls to `requestFlush` are
	// necessary until the next `flush` completes.
	var flushing = false;
	// `requestFlush` is an implementation-specific method that attempts to kick
	// off a `flush` event as quickly as possible. `flush` will attempt to exhaust
	// the event queue before yielding to the browser's own event loop.
	var requestFlush;
	// The position of the next task to execute in the task queue. This is
	// preserved between calls to `flush` so that it can be resumed if
	// a task throws an exception.
	var index = 0;
	// If a task schedules additional tasks recursively, the task queue can grow
	// unbounded. To prevent memory exhaustion, the task queue will periodically
	// truncate already-completed tasks.
	var capacity = 1024;

	// The flush function processes all tasks that have been scheduled with
	// `rawAsap` unless and until one of those tasks throws an exception.
	// If a task throws an exception, `flush` ensures that its state will remain
	// consistent and will resume where it left off when called again.
	// However, `flush` does not make any arrangements to be called again if an
	// exception is thrown.
	function flush() {
	    while (index < queue.length) {
	        var currentIndex = index;
	        // Advance the index before calling the task. This ensures that we will
	        // begin flushing on the next task the task throws an error.
	        index = index + 1;
	        queue[currentIndex].call();
	        // Prevent leaking memory for long chains of recursive calls to `asap`.
	        // If we call `asap` within tasks scheduled by `asap`, the queue will
	        // grow, but to avoid an O(n) walk for every task we execute, we don't
	        // shift tasks off the queue after they have been executed.
	        // Instead, we periodically shift 1024 tasks off the queue.
	        if (index > capacity) {
	            // Manually shift all values starting at the index back to the
	            // beginning of the queue.
	            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
	                queue[scan] = queue[scan + index];
	            }
	            queue.length -= index;
	            index = 0;
	        }
	    }
	    queue.length = 0;
	    index = 0;
	    flushing = false;
	}

	// `requestFlush` is implemented using a strategy based on data collected from
	// every available SauceLabs Selenium web driver worker at time of writing.
	// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593

	// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that
	// have WebKitMutationObserver but not un-prefixed MutationObserver.
	// Must use `global` or `self` instead of `window` to work in both frames and web
	// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.

	/* globals self */
	var scope = typeof (window) !== "undefined" ? (window) : self;
	var BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;

	// MutationObservers are desirable because they have high priority and work
	// reliably everywhere they are implemented.
	// They are implemented in all modern browsers.
	//
	// - Android 4-4.3
	// - Chrome 26-34
	// - Firefox 14-29
	// - Internet Explorer 11
	// - iPad Safari 6-7.1
	// - iPhone Safari 7-7.1
	// - Safari 6-7
	if (typeof BrowserMutationObserver === "function") {
	    requestFlush = makeRequestCallFromMutationObserver(flush);

	// MessageChannels are desirable because they give direct access to the HTML
	// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
	// 11-12, and in web workers in many engines.
	// Although message channels yield to any queued rendering and IO tasks, they
	// would be better than imposing the 4ms delay of timers.
	// However, they do not work reliably in Internet Explorer or Safari.

	// Internet Explorer 10 is the only browser that has setImmediate but does
	// not have MutationObservers.
	// Although setImmediate yields to the browser's renderer, it would be
	// preferrable to falling back to setTimeout since it does not have
	// the minimum 4ms penalty.
	// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
	// Desktop to a lesser extent) that renders both setImmediate and
	// MessageChannel useless for the purposes of ASAP.
	// https://github.com/kriskowal/q/issues/396

	// Timers are implemented universally.
	// We fall back to timers in workers in most engines, and in foreground
	// contexts in the following browsers.
	// However, note that even this simple case requires nuances to operate in a
	// broad spectrum of browsers.
	//
	// - Firefox 3-13
	// - Internet Explorer 6-9
	// - iPad Safari 4.3
	// - Lynx 2.8.7
	} else {
	    requestFlush = makeRequestCallFromTimer(flush);
	}

	// `requestFlush` requests that the high priority event queue be flushed as
	// soon as possible.
	// This is useful to prevent an error thrown in a task from stalling the event
	// queue if the exception handled by Node.jsâ€™s
	// `process.on("uncaughtException")` or by a domain.
	rawAsap.requestFlush = requestFlush;

	// To request a high priority event, we induce a mutation observer by toggling
	// the text of a text node between "1" and "-1".
	function makeRequestCallFromMutationObserver(callback) {
	    var toggle = 1;
	    var observer = new BrowserMutationObserver(callback);
	    var node = document.createTextNode("");
	    observer.observe(node, {characterData: true});
	    return function requestCall() {
	        toggle = -toggle;
	        node.data = toggle;
	    };
	}

	// The message channel technique was discovered by Malte Ubl and was the
	// original foundation for this library.
	// http://www.nonblocking.io/2011/06/windownexttick.html

	// Safari 6.0.5 (at least) intermittently fails to create message ports on a
	// page's first load. Thankfully, this version of Safari supports
	// MutationObservers, so we don't need to fall back in that case.

	// function makeRequestCallFromMessageChannel(callback) {
	//     var channel = new MessageChannel();
	//     channel.port1.onmessage = callback;
	//     return function requestCall() {
	//         channel.port2.postMessage(0);
	//     };
	// }

	// For reasons explained above, we are also unable to use `setImmediate`
	// under any circumstances.
	// Even if we were, there is another bug in Internet Explorer 10.
	// It is not sufficient to assign `setImmediate` to `requestFlush` because
	// `setImmediate` must be called *by name* and therefore must be wrapped in a
	// closure.
	// Never forget.

	// function makeRequestCallFromSetImmediate(callback) {
	//     return function requestCall() {
	//         setImmediate(callback);
	//     };
	// }

	// Safari 6.0 has a problem where timers will get lost while the user is
	// scrolling. This problem does not impact ASAP because Safari 6.0 supports
	// mutation observers, so that implementation is used instead.
	// However, if we ever elect to use timers in Safari, the prevalent work-around
	// is to add a scroll event listener that calls for a flush.

	// `setTimeout` does not call the passed callback if the delay is less than
	// approximately 7 in web workers in Firefox 8 through 18, and sometimes not
	// even then.

	function makeRequestCallFromTimer(callback) {
	    return function requestCall() {
	        // We dispatch a timeout with a specified delay of 0 for engines that
	        // can reliably accommodate that request. This will usually be snapped
	        // to a 4 milisecond delay, but once we're flushing, there's no delay
	        // between events.
	        var timeoutHandle = setTimeout(handleTimer, 0);
	        // However, since this timer gets frequently dropped in Firefox
	        // workers, we enlist an interval handle that will try to fire
	        // an event 20 times per second until it succeeds.
	        var intervalHandle = setInterval(handleTimer, 50);

	        function handleTimer() {
	            // Whichever timer succeeds will cancel both timers and
	            // execute the callback.
	            clearTimeout(timeoutHandle);
	            clearInterval(intervalHandle);
	            callback();
	        }
	    };
	}

	// This is for `asap.js` only.
	// Its name will be periodically randomized to break any code that depends on
	// its existence.
	rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;

	// ASAP was originally a nextTick shim included in Q. This was factored out
	// into this ASAP package. It was later adapted to RSVP which made further
	// amendments. These decisions, particularly to marginalize MessageChannel and
	// to capture the MutationObserver implementation in a closure, were integrated
	// back into ASAP proper.
	// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _AutoCompleteFilter = __webpack_require__(59);

	var _AutoCompleteFilter2 = _interopRequireDefault(_AutoCompleteFilter);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	exports['default'] = function (props) {
	  return _react2['default'].createElement(_AutoCompleteFilter2['default'], _extends({}, props, { multiSelection: true }));
	};

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _reactDataGrid = __webpack_require__(7);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var ExcelColumn = _reactDataGrid.shapes.ExcelColumn;

	var RuleType = {
	  Number: 1,
	  Range: 2,
	  GreaterThen: 3,
	  LessThen: 4
	};

	var NumericFilter = function (_React$Component) {
	  _inherits(NumericFilter, _React$Component);

	  function NumericFilter(props) {
	    _classCallCheck(this, NumericFilter);

	    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

	    _this.handleChange = _this.handleChange.bind(_this);
	    _this.handleKeyPress = _this.handleKeyPress.bind(_this);
	    _this.getRules = _this.getRules.bind(_this);
	    return _this;
	  }

	  NumericFilter.prototype.filterValues = function filterValues(row, columnFilter, columnKey) {
	    if (columnFilter.filterTerm == null) {
	      return true;
	    }
	    var result = false;
	    // implement default filter logic
	    var value = parseInt(row[columnKey], 10);
	    for (var ruleKey in columnFilter.filterTerm) {
	      if (!columnFilter.filterTerm.hasOwnProperty(ruleKey)) {
	        continue;
	      }

	      var rule = columnFilter.filterTerm[ruleKey];

	      switch (rule.type) {
	        case RuleType.Number:
	          if (rule.value === value) {
	            result = true;
	          }
	          break;
	        case RuleType.GreaterThen:
	          if (rule.value <= value) {
	            result = true;
	          }
	          break;
	        case RuleType.LessThen:
	          if (rule.value >= value) {
	            result = true;
	          }
	          break;
	        case RuleType.Range:
	          if (rule.begin <= value && rule.end >= value) {
	            result = true;
	          }
	          break;
	        default:
	          // do nothing
	          break;
	      }
	    }
	    return result;
	  };

	  NumericFilter.prototype.getRules = function getRules(value) {
	    var rules = [];
	    if (value === '') {
	      return rules;
	    }
	    // check comma
	    var list = value.split(',');
	    if (list.length > 0) {
	      // handle each value with comma
	      for (var key in list) {
	        if (!list.hasOwnProperty(key)) {
	          continue;
	        }

	        var obj = list[key];
	        if (obj.indexOf('-') > 0) {
	          // handle dash
	          var begin = parseInt(obj.split('-')[0], 10);
	          var end = parseInt(obj.split('-')[1], 10);
	          rules.push({ type: RuleType.Range, begin: begin, end: end });
	        } else if (obj.indexOf('>') > -1) {
	          // handle greater then
	          var _begin = parseInt(obj.split('>')[1], 10);
	          rules.push({ type: RuleType.GreaterThen, value: _begin });
	        } else if (obj.indexOf('<') > -1) {
	          // handle less then
	          var _end = parseInt(obj.split('<')[1], 10);
	          rules.push({ type: RuleType.LessThen, value: _end });
	        } else {
	          // handle normal values
	          var numericValue = parseInt(obj, 10);
	          rules.push({ type: RuleType.Number, value: numericValue });
	        }
	      }
	    }
	    return rules;
	  };

	  NumericFilter.prototype.handleKeyPress = function handleKeyPress(e) {
	    // Validate the input
	    var regex = '>|<|-|,|([0-9])';
	    var result = RegExp(regex).test(e.key);
	    if (result === false) {
	      e.preventDefault();
	    }
	  };

	  NumericFilter.prototype.handleChange = function handleChange(e) {
	    var value = e.target.value;
	    var filters = this.getRules(value);
	    this.props.onChange({ filterTerm: filters.length > 0 ? filters : null, column: this.props.column, rawValue: value, filterValues: this.filterValues });
	  };

	  NumericFilter.prototype.render = function render() {
	    var inputKey = 'header-filter-' + this.props.column.key;
	    var columnStyle = {
	      float: 'left',
	      marginRight: 5,
	      maxWidth: '80%'
	    };
	    var badgeStyle = {
	      cursor: 'help'
	    };

	    var tooltipText = 'Input Methods: Range (x-y), Greater Then (>x), Less Then (<y)';

	    return _react2['default'].createElement(
	      'div',
	      null,
	      _react2['default'].createElement(
	        'div',
	        { style: columnStyle },
	        _react2['default'].createElement('input', { key: inputKey, type: 'text', placeholder: 'e.g. 3,10-15,>20', className: 'form-control input-sm', onChange: this.handleChange, onKeyPress: this.handleKeyPress })
	      ),
	      _react2['default'].createElement(
	        'div',
	        { className: 'input-sm' },
	        _react2['default'].createElement(
	          'span',
	          { className: 'badge', style: badgeStyle, title: tooltipText },
	          '?'
	        )
	      )
	    );
	  };

	  return NumericFilter;
	}(_react2['default'].Component);

	NumericFilter.propTypes = {
	  onChange: _propTypes2['default'].func.isRequired,
	  column: _propTypes2['default'].shape(ExcelColumn)
	};
	module.exports = NumericFilter;

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _AutoCompleteFilter = __webpack_require__(59);

	var _AutoCompleteFilter2 = _interopRequireDefault(_AutoCompleteFilter);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	exports['default'] = function (props) {
	  return _react2['default'].createElement(_AutoCompleteFilter2['default'], _extends({}, props, { multiSelection: false }));
	};

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _NumericFilter = __webpack_require__(178);

	var _NumericFilter2 = _interopRequireDefault(_NumericFilter);

	var _AutoCompleteFilter = __webpack_require__(59);

	var _AutoCompleteFilter2 = _interopRequireDefault(_AutoCompleteFilter);

	var _MultiSelectFilter = __webpack_require__(177);

	var _MultiSelectFilter2 = _interopRequireDefault(_MultiSelectFilter);

	var _SingleSelectFilter = __webpack_require__(179);

	var _SingleSelectFilter2 = _interopRequireDefault(_SingleSelectFilter);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var Filters = {
	  NumericFilter: _NumericFilter2['default'],
	  AutoCompleteFilter: _AutoCompleteFilter2['default'],
	  MultiSelectFilter: _MultiSelectFilter2['default'],
	  SingleSelectFilter: _SingleSelectFilter2['default']
	};

	module.exports = Filters;

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _reactDataGrid = __webpack_require__(7);

	var getMixedTypeValueRetriever = _reactDataGrid.utils.getMixedTypeValueRetriever,
	    isImmutableCollection = _reactDataGrid.utils.isImmutableCollection;


	var filterRows = function filterRows(filters) {
	  var rows = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

	  return rows.filter(function (r) {
	    var retriever = getMixedTypeValueRetriever(isImmutableCollection(r));
	    var include = true;
	    for (var columnKey in filters) {
	      if (filters.hasOwnProperty(columnKey)) {
	        var colFilter = filters[columnKey];
	        // check if custom filter function exists
	        if (colFilter.filterValues && typeof colFilter.filterValues === 'function') {
	          include = include & colFilter.filterValues(r, colFilter, columnKey);
	        } else if (typeof colFilter.filterTerm === 'string') {
	          // default filter action
	          var rowValue = retriever.getValue(r, columnKey);
	          if (rowValue !== undefined) {
	            if (rowValue.toString().toLowerCase().indexOf(colFilter.filterTerm.toLowerCase()) === -1) {
	              include = include & false;
	            }
	          } else {
	            include = include & false;
	          }
	        }
	      }
	    }
	    return Boolean(include);
	  });
	};

	module.exports = filterRows;

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _reactDataGrid = __webpack_require__(7);

	var _RowGrouperResolver = __webpack_require__(183);

	var _RowGrouperResolver2 = _interopRequireDefault(_RowGrouperResolver);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var isImmutableCollection = _reactDataGrid.utils.isImmutableCollection;

	var RowGrouper = function () {
	  function RowGrouper(columns, expandedRows) {
	    var isImmutable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	    _classCallCheck(this, RowGrouper);

	    this.columns = columns.slice(0);
	    this.expandedRows = expandedRows;
	    this.resolver = new _RowGrouperResolver2['default'](isImmutable);
	  }

	  RowGrouper.prototype.isRowExpanded = function isRowExpanded(columnName, name) {
	    var isExpanded = true;
	    var expandedRowGroup = this.expandedRows[columnName];
	    if (expandedRowGroup && expandedRowGroup[name]) {
	      isExpanded = expandedRowGroup[name].isExpanded;
	    }
	    return isExpanded;
	  };

	  RowGrouper.prototype.groupRowsByColumn = function groupRowsByColumn(rows) {
	    var columnIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	    var nextColumnIndex = columnIndex;
	    var columnName = this.columns.length > 0 && typeof this.columns[columnIndex] === 'string' ? this.columns[columnIndex] : this.columns[columnIndex].key;
	    var groupedRows = this.resolver.getGroupedRows(rows, columnName);
	    var keys = this.resolver.getGroupKeys(groupedRows);
	    var dataviewRows = this.resolver.initRowsCollection();

	    for (var i = 0; i < keys.length; i++) {
	      var key = keys[i];
	      var isExpanded = this.isRowExpanded(columnName, key);
	      var rowGroupHeader = { name: key, __metaData: { isGroup: true, treeDepth: columnIndex, isExpanded: isExpanded, columnGroupName: columnName } };

	      dataviewRows = this.resolver.addHeaderRow(rowGroupHeader, dataviewRows);

	      if (isExpanded) {
	        nextColumnIndex = columnIndex + 1;
	        if (this.columns.length > nextColumnIndex) {
	          dataviewRows = dataviewRows.concat(this.groupRowsByColumn(this.resolver.getRowObj(groupedRows, key), nextColumnIndex));
	          nextColumnIndex = columnIndex - 1;
	        } else {
	          dataviewRows = dataviewRows.concat(this.resolver.getRowObj(groupedRows, key));
	        }
	      }
	    }
	    return dataviewRows;
	  };

	  return RowGrouper;
	}();

	var groupRows = function groupRows(rows, groupedColumns, expandedRows) {
	  var rowGrouper = new RowGrouper(groupedColumns, expandedRows, isImmutableCollection(rows));
	  return rowGrouper.groupRowsByColumn(rows, 0);
	};

	module.exports = groupRows;

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _immutable = __webpack_require__(21);

	var _groupBy = __webpack_require__(457);

	var _groupBy2 = _interopRequireDefault(_groupBy);

	var _reactDataGrid = __webpack_require__(7);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var getMixedTypeValueRetriever = _reactDataGrid.utils.getMixedTypeValueRetriever,
	    isImmutableMap = _reactDataGrid.utils.isImmutableMap;

	var RowGrouperResolver = function () {
	  function RowGrouperResolver(isImmutable) {
	    _classCallCheck(this, RowGrouperResolver);

	    this.isImmutable = isImmutable;
	    this.getRowObj = getMixedTypeValueRetriever(isImmutable).getValue;
	  }

	  RowGrouperResolver.prototype.initRowsCollection = function initRowsCollection() {
	    return this.isImmutable ? new _immutable.List() : [];
	  };

	  RowGrouperResolver.prototype.getGroupedRows = function getGroupedRows(rows, columnName) {
	    return this.isImmutable ? rows.groupBy(function (x) {
	      return isImmutableMap(x) ? x.get(columnName) : x[columnName];
	    }) : (0, _groupBy2['default'])(rows, columnName);
	  };

	  RowGrouperResolver.prototype.getGroupKeys = function getGroupKeys(groupedRows) {
	    var getKeys = Object.keys;
	    if (this.isImmutable) {
	      getKeys = function getKeys(col) {
	        var keys = [];
	        var iterator = col.keys();
	        var item = iterator.next();

	        while (!item.done) {
	          keys.push(item.value);
	          item = iterator.next();
	        }
	        return keys;
	      };
	    }
	    return getKeys(groupedRows);
	  };

	  RowGrouperResolver.prototype.addHeaderRow = function addHeaderRow(rowGroupHeader, dataviewRows) {
	    var rows = dataviewRows;
	    var dvRows = rows.push(rowGroupHeader);
	    if (this.isImmutable) {
	      return dvRows;
	    }
	    return rows;
	  };

	  return RowGrouperResolver;
	}();

	exports['default'] = RowGrouperResolver;

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _reactDataGrid = __webpack_require__(7);

	var getMixedTypeValueRetriever = _reactDataGrid.utils.getMixedTypeValueRetriever,
	    isImmutableCollection = _reactDataGrid.utils.isImmutableCollection;


	var comparer = function comparer(a, b) {
	  if (a > b) {
	    return 1;
	  } else if (a < b) {
	    return -1;
	  }
	  return 0;
	};

	var sortRows = function sortRows(rows, sortColumn, sortDirection) {
	  var retriever = getMixedTypeValueRetriever(isImmutableCollection(rows));
	  var sortDirectionSign = sortDirection === 'ASC' ? 1 : -1;
	  var rowComparer = function rowComparer(a, b) {
	    return sortDirectionSign * comparer(retriever.getValue(a, sortColumn), retriever.getValue(b, sortColumn));
	  };
	  if (sortDirection === 'NONE') {
	    return rows;
	  }
	  return rows.slice().sort(rowComparer);
	};

	module.exports = sortRows;
	module.exports.comparer = comparer;

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = {
	  Selectors: __webpack_require__(96)
	};

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _reactDnd = __webpack_require__(14);

	var _reactDndHtml5Backend = __webpack_require__(138);

	var _reactDndHtml5Backend2 = _interopRequireDefault(_reactDndHtml5Backend);

	var _DraggableHeaderCell = __webpack_require__(187);

	var _DraggableHeaderCell2 = _interopRequireDefault(_DraggableHeaderCell);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var DraggableContainer = function (_React$Component) {
	  _inherits(DraggableContainer, _React$Component);

	  function DraggableContainer() {
	    _classCallCheck(this, DraggableContainer);

	    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
	  }

	  DraggableContainer.prototype.renderGrid = function renderGrid() {
	    return _react2['default'].Children.map(this.props.children, function (child) {
	      return _react2['default'].cloneElement(child, {
	        draggableHeaderCell: _DraggableHeaderCell2['default']
	      });
	    })[0];
	  };

	  DraggableContainer.prototype.render = function render() {
	    var grid = this.renderGrid();
	    return _react2['default'].createElement(
	      'div',
	      null,
	      _react2['default'].cloneElement(grid, this.props)
	    );
	  };

	  return DraggableContainer;
	}(_react2['default'].Component);

	DraggableContainer.propTypes = {
	  children: _propTypes2['default'].element
	};

	exports['default'] = (0, _reactDnd.DragDropContext)(_reactDndHtml5Backend2['default'])(DraggableContainer);

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _reactDnd = __webpack_require__(14);

	var _reactDataGrid = __webpack_require__(7);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var DraggableHeaderCell = function (_React$Component) {
	  _inherits(DraggableHeaderCell, _React$Component);

	  function DraggableHeaderCell() {
	    _classCallCheck(this, DraggableHeaderCell);

	    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
	  }

	  DraggableHeaderCell.prototype.render = function render() {
	    var _props = this.props,
	        connectDragSource = _props.connectDragSource,
	        connectDropTarget = _props.connectDropTarget,
	        isDragging = _props.isDragging,
	        isOver = _props.isOver,
	        canDrop = _props.canDrop;


	    var opacity = 1;
	    if (isDragging) {
	      opacity = 0.2;
	    }

	    // set drag source and drop target on header cell
	    // width: 0 - otherwise drag clone was wrongly positioned
	    return connectDragSource(connectDropTarget(_react2['default'].createElement(
	      'div',
	      {
	        style: { width: 0, cursor: 'move', opacity: opacity },
	        className: isOver && canDrop ? 'rdg-can-drop' : ''
	      },
	      _react2['default'].createElement(_reactDataGrid.HeaderCell, this.props)
	    )));
	  };

	  return DraggableHeaderCell;
	}(_react2['default'].Component);

	// drop source


	function collect(connect, monitor) {
	  return {
	    connectDragSource: connect.dragSource(),
	    isDragging: monitor.isDragging()
	  };
	}

	var headerCellSource = {
	  beginDrag: function beginDrag(props) {
	    return {
	      // source column
	      key: props.column.key
	    };
	  },
	  endDrag: function endDrag(props, monitor) {
	    // check if drop was made in droppable zone
	    if (monitor.didDrop()) {
	      var source = monitor.getDropResult().source;
	      var _target = monitor.getDropResult().target;
	      return props.onHeaderDrop(source, _target);
	    }
	  }
	};

	// drop target
	var target = {
	  drop: function drop(props, monitor) {
	    var source = monitor.getItem().key;
	    var targetKey = props.column.key;
	    return {
	      source: source,
	      target: targetKey
	    };
	  }
	};

	function targetCollect(connect, monitor) {
	  return {
	    connectDropTarget: connect.dropTarget(),
	    isOver: monitor.isOver(),
	    canDrop: monitor.canDrop(),
	    draggedHeader: monitor.getItem()
	  };
	}

	DraggableHeaderCell.propTypes = {
	  connectDragSource: _propTypes2['default'].func.isRequired,
	  connectDropTarget: _propTypes2['default'].func.isRequired,
	  isDragging: _propTypes2['default'].bool.isRequired,
	  isOver: _propTypes2['default'].bool,
	  canDrop: _propTypes2['default'].bool
	};

	DraggableHeaderCell = (0, _reactDnd.DropTarget)('Column', target, targetCollect)(DraggableHeaderCell);
	DraggableHeaderCell = (0, _reactDnd.DragSource)('Column', headerCellSource, collect)(DraggableHeaderCell);

	exports['default'] = DraggableHeaderCell;

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _DraggableContainer = __webpack_require__(186);

	var _DraggableContainer2 = _interopRequireDefault(_DraggableContainer);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	module.exports = { DraggableContainer: _DraggableContainer2['default'] };

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _reactDndHtml5Backend = __webpack_require__(138);

	var _reactDndHtml5Backend2 = _interopRequireDefault(_reactDndHtml5Backend);

	var _reactDnd = __webpack_require__(14);

	var _DraggableHeaderCell = __webpack_require__(97);

	var _DraggableHeaderCell2 = _interopRequireDefault(_DraggableHeaderCell);

	var _RowDragLayer = __webpack_require__(192);

	var _RowDragLayer2 = _interopRequireDefault(_RowDragLayer);

	var _reactDataGrid = __webpack_require__(7);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var isColumnsImmutable = _reactDataGrid.utils.isColumnsImmutable;

	var DraggableContainer = function (_Component) {
	  _inherits(DraggableContainer, _Component);

	  function DraggableContainer() {
	    _classCallCheck(this, DraggableContainer);

	    return _possibleConstructorReturn(this, _Component.apply(this, arguments));
	  }

	  DraggableContainer.prototype.getRows = function getRows(rowsCount, rowGetter) {
	    var rows = [];
	    for (var j = 0; j < rowsCount; j++) {
	      rows.push(rowGetter(j));
	    }
	    return rows;
	  };

	  DraggableContainer.prototype.renderGrid = function renderGrid() {
	    return _react2['default'].Children.map(this.props.children, function (child) {
	      return _react2['default'].cloneElement(child, { draggableHeaderCell: _DraggableHeaderCell2['default'] });
	    })[0];
	  };

	  DraggableContainer.prototype.render = function render() {
	    var grid = this.renderGrid();
	    var rowGetter = this.props.getDragPreviewRow || grid.props.rowGetter;
	    var rowsCount = grid.props.rowsCount;
	    var columns = grid.props.columns;
	    var rows = this.getRows(rowsCount, rowGetter);
	    return _react2['default'].createElement(
	      'div',
	      null,
	      grid,
	      _react2['default'].createElement(_RowDragLayer2['default'], { rowSelection: grid.props.rowSelection, rows: rows, columns: isColumnsImmutable(columns) ? columns.toArray() : columns })
	    );
	  };

	  return DraggableContainer;
	}(_react.Component);

	DraggableContainer.propTypes = {
	  children: _propTypes2['default'].element.isRequired,
	  getDragPreviewRow: _propTypes2['default'].func
	};

	exports['default'] = (0, _reactDnd.DragDropContext)(_reactDndHtml5Backend2['default'])(DraggableContainer);

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	__webpack_require__(266);

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(6);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	var _reactDnd = __webpack_require__(14);

	var _reactDataGrid = __webpack_require__(7);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var rowDropTarget = function rowDropTarget(Row) {
	  return function (_React$Component) {
	    _inherits(_class, _React$Component);

	    function _class() {
	      _classCallCheck(this, _class);

	      return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
	    }

	    _class.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
	      return (0, _reactDataGrid.RowComparer)(nextProps, this.props);
	    };

	    _class.prototype.moveRow = function moveRow() {
	      _reactDom2['default'].findDOMNode(this).classList.add('slideUp');
	    };

	    _class.prototype.render = function render() {
	      var _this2 = this;

	      var _props = this.props,
	          connectDropTarget = _props.connectDropTarget,
	          isOver = _props.isOver,
	          canDrop = _props.canDrop;

	      var overlayTop = this.props.idx * this.props.height;
	      return connectDropTarget(_react2['default'].createElement(
	        'div',
	        null,
	        _react2['default'].createElement(Row, _extends({ ref: function ref(node) {
	            return _this2.row = node;
	          } }, this.props)),
	        isOver && canDrop && _react2['default'].createElement('div', { style: {
	            position: 'absolute',
	            top: overlayTop,
	            left: 0,
	            height: this.props.height,
	            width: '100%',
	            zIndex: 1,
	            borderBottom: '1px solid black'
	          } })
	      ));
	    };

	    return _class;
	  }(_react2['default'].Component);
	};

	var target = {
	  drop: function drop(props, monitor, component) {
	    // Obtain the dragged item
	    component.moveRow();
	    var rowSource = monitor.getItem();
	    var rowTarget = { idx: props.idx, data: props.row };
	    props.onRowDrop({ rowSource: rowSource, rowTarget: rowTarget });
	  }
	};

	function collect(connect, monitor) {
	  return {
	    connectDropTarget: connect.dropTarget(),
	    isOver: monitor.isOver(),
	    canDrop: monitor.canDrop(),
	    draggedRow: monitor.getItem()
	  };
	}

	exports['default'] = function (Row) {
	  return (0, _reactDnd.DropTarget)('Row', target, collect, { arePropsEqual: function arePropsEqual(nextProps, currentProps) {
	      return !(0, _reactDataGrid.RowComparer)(nextProps, currentProps);
	    } })(rowDropTarget(Row));
	};

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	__webpack_require__(33);

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _reactDnd = __webpack_require__(14);

	var _reactDataGrid = __webpack_require__(7);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var CheckboxEditor = _reactDataGrid.editors.CheckboxEditor;

	var RowActionsCell = function (_React$Component) {
	  _inherits(RowActionsCell, _React$Component);

	  function RowActionsCell() {
	    _classCallCheck(this, RowActionsCell);

	    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
	  }

	  RowActionsCell.prototype.renderRowIndex = function renderRowIndex() {
	    return _react2['default'].createElement(
	      'div',
	      { className: 'rdg-row-index' },
	      this.props.rowIdx + 1
	    );
	  };

	  RowActionsCell.prototype.render = function render() {
	    var _props = this.props,
	        connectDragSource = _props.connectDragSource,
	        rowSelection = _props.rowSelection;

	    var rowHandleStyle = rowSelection != null ? { position: 'absolute', marginTop: '5px' } : {};
	    var isSelected = this.props.value;
	    var editorClass = isSelected ? 'rdg-actions-checkbox selected' : 'rdg-actions-checkbox';

	    return connectDragSource(_react2['default'].createElement(
	      'div',
	      null,
	      _react2['default'].createElement('div', { className: 'rdg-drag-row-handle', style: rowHandleStyle }),
	      !isSelected ? this.renderRowIndex() : null,
	      rowSelection != null && _react2['default'].createElement(
	        'div',
	        { className: editorClass },
	        _react2['default'].createElement(CheckboxEditor, { column: this.props.column, rowIdx: this.props.rowIdx, dependentValues: this.props.dependentValues, value: this.props.value })
	      )
	    ));
	  };

	  return RowActionsCell;
	}(_react2['default'].Component);

	RowActionsCell.propTypes = {
	  rowIdx: _propTypes2['default'].number.isRequired,
	  connectDragSource: _propTypes2['default'].func.isRequired,
	  connectDragPreview: _propTypes2['default'].func.isRequired,
	  isDragging: _propTypes2['default'].bool.isRequired,
	  isRowHovered: _propTypes2['default'].bool,
	  column: _propTypes2['default'].object,
	  dependentValues: _propTypes2['default'].object,
	  value: _propTypes2['default'].bool,
	  rowSelection: _propTypes2['default'].object.isRequired
	};

	RowActionsCell.defaultProps = {
	  rowIdx: 0
	};

	function collect(connect, monitor) {
	  return {
	    connectDragSource: connect.dragSource(),
	    isDragging: monitor.isDragging(),
	    connectDragPreview: connect.dragPreview()
	  };
	}

	var rowIndexSource = {
	  beginDrag: function beginDrag(props) {
	    return { idx: props.rowIdx, data: props.dependentValues };
	  },
	  endDrag: function endDrag(props) {
	    return { idx: props.rowIdx, data: props.dependentValues };
	  }
	};

	exports['default'] = (0, _reactDnd.DragSource)('Row', rowIndexSource, collect)(RowActionsCell);

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _reactDnd = __webpack_require__(14);

	var _Selectors = __webpack_require__(96);

	var _Selectors2 = _interopRequireDefault(_Selectors);

	__webpack_require__(57);

	__webpack_require__(33);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var layerStyles = {
	  cursor: '-webkit-grabbing',
	  position: 'fixed',
	  pointerEvents: 'none',
	  zIndex: 100,
	  left: 0,
	  top: 0,
	  width: '100%',
	  height: '100%'
	};

	function getItemStyles(props) {
	  var currentOffset = props.currentOffset;

	  if (!currentOffset) {
	    return {
	      display: 'none'
	    };
	  }

	  var x = currentOffset.x,
	      y = currentOffset.y;

	  var transform = 'translate(' + x + 'px, ' + y + 'px)';
	  return {
	    transform: transform,
	    WebkitTransform: transform
	  };
	}

	var CustomDragLayer = function (_Component) {
	  _inherits(CustomDragLayer, _Component);

	  function CustomDragLayer() {
	    _classCallCheck(this, CustomDragLayer);

	    return _possibleConstructorReturn(this, _Component.apply(this, arguments));
	  }

	  CustomDragLayer.prototype.isDraggedRowSelected = function isDraggedRowSelected(selectedRows) {
	    var _props = this.props,
	        item = _props.item,
	        rowSelection = _props.rowSelection;

	    if (selectedRows && selectedRows.length > 0) {
	      var key = rowSelection.selectBy.keys.rowKey;
	      return selectedRows.filter(function (r) {
	        return r[key] === item.data[key];
	      }).length > 0;
	    }
	    return false;
	  };

	  CustomDragLayer.prototype.getDraggedRows = function getDraggedRows() {
	    var draggedRows = void 0;
	    var rowSelection = this.props.rowSelection;

	    if (rowSelection && rowSelection.selectBy.keys) {
	      var rows = this.props.rows;
	      var _rowSelection$selectB = rowSelection.selectBy.keys,
	          rowKey = _rowSelection$selectB.rowKey,
	          values = _rowSelection$selectB.values;

	      var selectedRows = _Selectors2['default'].getSelectedRowsByKey({ rowKey: rowKey, selectedKeys: values, rows: rows });
	      draggedRows = this.isDraggedRowSelected(selectedRows) ? selectedRows : [this.props.rows[this.props.item.idx]];
	    } else {
	      draggedRows = [this.props.rows[this.props.item.idx]];
	    }
	    return draggedRows;
	  };

	  CustomDragLayer.prototype.renderDraggedRows = function renderDraggedRows() {
	    var _this2 = this;

	    var columns = this.props.columns;
	    return this.getDraggedRows().map(function (r, i) {
	      return _react2['default'].createElement(
	        'tr',
	        { key: 'dragged-row-' + i },
	        _this2.renderDraggedCells(r, i, columns)
	      );
	    });
	  };

	  CustomDragLayer.prototype.renderDraggedCells = function renderDraggedCells(item, rowIdx, columns) {
	    var cells = [];
	    if (item != null) {
	      columns.forEach(function (c) {
	        if (item.hasOwnProperty(c.key)) {
	          if (c.formatter) {
	            var Formatter = c.formatter;
	            var dependentValues = typeof c.getRowMetaData === 'function' ? c.getRowMetaData(item, c) : {};
	            cells.push(_react2['default'].createElement(
	              'td',
	              { key: 'dragged-cell-' + rowIdx + '-' + c.key, className: 'react-grid-Cell', style: { padding: '5px' } },
	              _react2['default'].createElement(Formatter, { dependentValues: dependentValues, value: item[c.key] })
	            ));
	          } else {
	            cells.push(_react2['default'].createElement(
	              'td',
	              { key: 'dragged-cell-' + rowIdx + '-' + c.key, className: 'react-grid-Cell', style: { padding: '5px' } },
	              item[c.key]
	            ));
	          }
	        }
	      });
	    }
	    return cells;
	  };

	  CustomDragLayer.prototype.render = function render() {
	    var isDragging = this.props.isDragging;

	    if (!isDragging) {
	      return null;
	    }
	    var draggedRows = this.renderDraggedRows();
	    return _react2['default'].createElement(
	      'div',
	      { style: layerStyles, className: 'rdg-dragging' },
	      _react2['default'].createElement(
	        'div',
	        { style: getItemStyles(this.props), className: 'rdg-dragging' },
	        _react2['default'].createElement(
	          'table',
	          null,
	          _react2['default'].createElement(
	            'tbody',
	            null,
	            draggedRows
	          )
	        )
	      )
	    );
	  };

	  return CustomDragLayer;
	}(_react.Component);

	CustomDragLayer.propTypes = {
	  item: _propTypes2['default'].object,
	  itemType: _propTypes2['default'].string,
	  currentOffset: _propTypes2['default'].shape({
	    x: _propTypes2['default'].number.isRequired,
	    y: _propTypes2['default'].number.isRequired
	  }),
	  isDragging: _propTypes2['default'].bool.isRequired,
	  rowSelection: _propTypes2['default'].object,
	  rows: _propTypes2['default'].array.isRequired,
	  columns: _propTypes2['default'].array.isRequired
	};

	function collect(monitor) {
	  return {
	    item: monitor.getItem(),
	    itemType: monitor.getItemType(),
	    currentOffset: monitor.getSourceClientOffset(),
	    isDragging: monitor.isDragging()
	  };
	}

	exports['default'] = (0, _reactDnd.DragLayer)(collect)(CustomDragLayer);

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _DragDropContainer = __webpack_require__(189);

	var _DragDropContainer2 = _interopRequireDefault(_DragDropContainer);

	var _DraggableHeaderCell = __webpack_require__(97);

	var _DraggableHeaderCell2 = _interopRequireDefault(_DraggableHeaderCell);

	var _RowActionsCell = __webpack_require__(191);

	var _RowActionsCell2 = _interopRequireDefault(_RowActionsCell);

	var _DropTargetRowContainer = __webpack_require__(190);

	var _DropTargetRowContainer2 = _interopRequireDefault(_DropTargetRowContainer);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	module.exports = { Container: _DragDropContainer2['default'], DraggableHeaderCell: _DraggableHeaderCell2['default'], RowActionsCell: _RowActionsCell2['default'], DropTargetRowContainer: _DropTargetRowContainer2['default'] };

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);
	var ReactDOM = __webpack_require__(6);
	var ReactAutocomplete = __webpack_require__(370);

	var _require = __webpack_require__(7),
	    ExcelColumn = _require.shapes.ExcelColumn;

	__webpack_require__(268);


	var optionPropType = _propTypes2['default'].shape({
	  id: _propTypes2['default'].required,
	  title: _propTypes2['default'].string
	});

	var AutoCompleteEditor = function (_React$Component) {
	  _inherits(AutoCompleteEditor, _React$Component);

	  function AutoCompleteEditor() {
	    var _temp, _this, _ret;

	    _classCallCheck(this, AutoCompleteEditor);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.handleChange = function () {
	      _this.props.onCommit();
	    }, _this.getValue = function () {
	      var value = void 0;
	      var updated = {};
	      if (_this.hasResults() && _this.isFocusedOnSuggestion()) {
	        value = _this.getLabel(_this.autoComplete.state.focusedValue);
	        if (_this.props.valueParams) {
	          value = _this.constuctValueFromParams(_this.autoComplete.state.focusedValue, _this.props.valueParams);
	        }
	      } else {
	        value = _this.autoComplete.state.searchTerm;
	      }

	      updated[_this.props.column.key] = value;
	      return updated;
	    }, _this.getEditorDisplayValue = function () {
	      var displayValue = { title: '' };
	      var _this$props = _this.props,
	          column = _this$props.column,
	          value = _this$props.value,
	          editorDisplayValue = _this$props.editorDisplayValue;

	      if (editorDisplayValue && typeof editorDisplayValue === 'function') {
	        displayValue.title = editorDisplayValue(column, value);
	      } else {
	        displayValue.title = value;
	      }
	      return displayValue;
	    }, _this.getInputNode = function () {
	      return ReactDOM.findDOMNode(_this).getElementsByTagName('input')[0];
	    }, _this.getLabel = function (item) {
	      var label = _this.props.label != null ? _this.props.label : 'title';
	      if (typeof label === 'function') {
	        return label(item);
	      } else if (typeof label === 'string') {
	        return item[label];
	      }
	    }, _this.hasResults = function () {
	      return _this.autoComplete.state.results.length > 0;
	    }, _this.isFocusedOnSuggestion = function () {
	      var autoComplete = _this.autoComplete;
	      return autoComplete.state.focusedValue != null;
	    }, _this.constuctValueFromParams = function (obj, props) {
	      if (!props) {
	        return '';
	      }

	      var ret = [];
	      for (var i = 0, ii = props.length; i < ii; i++) {
	        ret.push(obj[props[i]]);
	      }
	      return ret.join('|');
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  AutoCompleteEditor.prototype.render = function render() {
	    var _this2 = this;

	    var label = this.props.label != null ? this.props.label : 'title';
	    return React.createElement(
	      'div',
	      { height: this.props.height, onKeyDown: this.props.onKeyDown },
	      React.createElement(ReactAutocomplete, { search: this.props.search, ref: function ref(node) {
	          return _this2.autoComplete = node;
	        }, label: label, onChange: this.handleChange, onFocus: this.props.onFocus, resultIdentifier: this.props.resultIdentifier, options: this.props.options, value: this.getEditorDisplayValue() })
	    );
	  };

	  return AutoCompleteEditor;
	}(React.Component);

	AutoCompleteEditor.propTypes = {
	  onCommit: _propTypes2['default'].func,
	  options: _propTypes2['default'].arrayOf(optionPropType),
	  label: _propTypes2['default'].any,
	  value: _propTypes2['default'].any,
	  height: _propTypes2['default'].number,
	  valueParams: _propTypes2['default'].arrayOf(_propTypes2['default'].string),
	  column: _propTypes2['default'].shape(ExcelColumn),
	  resultIdentifier: _propTypes2['default'].string,
	  search: _propTypes2['default'].string,
	  onKeyDown: _propTypes2['default'].func,
	  onFocus: _propTypes2['default'].func,
	  editorDisplayValue: _propTypes2['default'].func
	};
	AutoCompleteEditor.defaultProps = {
	  resultIdentifier: 'id'
	};


	module.exports = AutoCompleteEditor;

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	// Wrapper HOC used when having an editor which is a redux container.
	// Required since react-data-grid requires access to getInputNode, getValue,
	// howvever when doing this.getEditor() in react-data-grid we get a react
	// componenet wrapped by the redux connect function and thus wont have access
	// to the required methods.
	module.exports = function (ContainerEditor) {
	  return function (_Component) {
	    _inherits(ContainerEditorWrapper, _Component);

	    function ContainerEditorWrapper() {
	      _classCallCheck(this, ContainerEditorWrapper);

	      return _possibleConstructorReturn(this, _Component.apply(this, arguments));
	    }

	    ContainerEditorWrapper.prototype.getInputNode = function getInputNode() {
	      return this.editorRef.getInputNode();
	    };

	    ContainerEditorWrapper.prototype.getValue = function getValue() {
	      return this.editorRef.getValue();
	    };

	    ContainerEditorWrapper.prototype.render = function render() {
	      var _this2 = this;

	      return _react2['default'].createElement(ContainerEditor, _extends({ refCallback: function refCallback(ref) {
	          _this2.editorRef = ref;
	        } }, this.props));
	    };

	    return ContainerEditorWrapper;
	  }(_react.Component);
	};

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _reactDom = __webpack_require__(6);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);

	var _require = __webpack_require__(7),
	    EditorBase = _require.editors.EditorBase;

	var DropDownEditor = function (_EditorBase) {
	  _inherits(DropDownEditor, _EditorBase);

	  function DropDownEditor() {
	    _classCallCheck(this, DropDownEditor);

	    return _possibleConstructorReturn(this, _EditorBase.apply(this, arguments));
	  }

	  DropDownEditor.prototype.getInputNode = function getInputNode() {
	    return _reactDom2['default'].findDOMNode(this);
	  };

	  DropDownEditor.prototype.onClick = function onClick() {
	    this.getInputNode().focus();
	  };

	  DropDownEditor.prototype.onDoubleClick = function onDoubleClick() {
	    this.getInputNode().focus();
	  };

	  DropDownEditor.prototype.render = function render() {
	    return React.createElement(
	      'select',
	      { style: this.getStyle(), defaultValue: this.props.value, onBlur: this.props.onBlur, onChange: this.onChange },
	      this.renderOptions()
	    );
	  };

	  DropDownEditor.prototype.renderOptions = function renderOptions() {
	    var options = [];
	    this.props.options.forEach(function (name) {
	      if (typeof name === 'string') {
	        options.push(React.createElement(
	          'option',
	          { key: name, value: name },
	          name
	        ));
	      } else {
	        options.push(React.createElement(
	          'option',
	          { key: name.id, value: name.value, title: name.title },
	          name.text || name.value
	        ));
	      }
	    }, this);
	    return options;
	  };

	  return DropDownEditor;
	}(EditorBase);

	DropDownEditor.propTypes = {
	  options: _propTypes2['default'].arrayOf(_propTypes2['default'].oneOfType([_propTypes2['default'].string, _propTypes2['default'].shape({
	    id: _propTypes2['default'].string,
	    title: _propTypes2['default'].string,
	    value: _propTypes2['default'].string,
	    text: _propTypes2['default'].string
	  })])).isRequired
	};

	module.exports = DropDownEditor;

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _require = __webpack_require__(7),
	    _require$editors = _require.editors,
	    SimpleTextEditor = _require$editors.SimpleTextEditor,
	    CheckboxEditor = _require$editors.CheckboxEditor;

	var Editors = {
	  AutoComplete: __webpack_require__(194),
	  DropDownEditor: __webpack_require__(196),
	  ContainerEditorWrapper: __webpack_require__(195),
	  SimpleTextEditor: SimpleTextEditor,
	  CheckboxEditor: CheckboxEditor
	};

	module.exports = Editors;

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	// Used for displaying the value of a dropdown (using DropDownEditor) when not editing it.
	// Accepts the same parameters as the DropDownEditor.
	var React = __webpack_require__(2);

	var DropDownFormatter = function (_React$Component) {
	  _inherits(DropDownFormatter, _React$Component);

	  function DropDownFormatter() {
	    _classCallCheck(this, DropDownFormatter);

	    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
	  }

	  DropDownFormatter.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
	    return nextProps.value !== this.props.value;
	  };

	  DropDownFormatter.prototype.render = function render() {
	    var value = this.props.value;
	    var option = this.props.options.filter(function (v) {
	      return v === value || v.value === value;
	    })[0];
	    if (!option) {
	      option = value;
	    }
	    var title = option.title || option.value || option;
	    var text = option.text || option.value || option;
	    return React.createElement(
	      'div',
	      { title: title },
	      text
	    );
	  };

	  return DropDownFormatter;
	}(React.Component);

	DropDownFormatter.propTypes = {
	  options: _propTypes2['default'].arrayOf(_propTypes2['default'].oneOfType([_propTypes2['default'].string, _propTypes2['default'].shape({
	    id: _propTypes2['default'].string,
	    title: _propTypes2['default'].string,
	    value: _propTypes2['default'].string,
	    text: _propTypes2['default'].string
	  })])).isRequired,
	  value: _propTypes2['default'].string.isRequired
	};


	module.exports = DropDownFormatter;

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);

	__webpack_require__(267);

	var PendingPool = {};
	var ReadyPool = {};

	var ImageFormatter = function (_React$Component) {
	  _inherits(ImageFormatter, _React$Component);

	  function ImageFormatter() {
	    var _temp, _this, _ret;

	    _classCallCheck(this, ImageFormatter);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
	      ready: false
	    }, _this._load = function (src) {
	      var imageSrc = src;
	      if (ReadyPool[imageSrc]) {
	        _this.setState({ value: imageSrc });
	        return;
	      }

	      if (PendingPool[imageSrc]) {
	        PendingPool[imageSrc].push(_this._onLoad);
	        return;
	      }

	      PendingPool[imageSrc] = [_this._onLoad];

	      var img = new Image();
	      img.onload = function () {
	        PendingPool[imageSrc].forEach(function (callback) {
	          callback(imageSrc);
	        });
	        delete PendingPool[imageSrc];
	        img.onload = null;
	        imageSrc = undefined;
	      };
	      img.src = imageSrc;
	    }, _this._onLoad = function (src) {
	      if (_this._isMounted && src === _this.props.value) {
	        _this.setState({
	          value: src
	        });
	      }
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  ImageFormatter.prototype.componentWillMount = function componentWillMount() {
	    this._load(this.props.value);
	  };

	  ImageFormatter.prototype.componentDidMount = function componentDidMount() {
	    this._isMounted = true;
	  };

	  ImageFormatter.prototype.componentWillUnmount = function componentWillUnmount() {
	    this._isMounted = false;
	  };

	  ImageFormatter.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	    if (nextProps.value !== this.props.value) {
	      this.setState({ value: null });
	      this._load(nextProps.value);
	    }
	  };

	  ImageFormatter.prototype.render = function render() {
	    var style = this.state.value ? { backgroundImage: 'url(' + this.state.value + ')' } : undefined;

	    return React.createElement('div', { className: 'react-grid-image', style: style });
	  };

	  return ImageFormatter;
	}(React.Component);

	ImageFormatter.propTypes = {
	  value: _propTypes2['default'].string.isRequired
	};


	module.exports = ImageFormatter;

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	// not including this
	// it currently requires the whole of moment, which we dont want to take as a dependency
	var ImageFormatter = __webpack_require__(199);
	var DropDownFormatter = __webpack_require__(198);

	var Formatters = {
	  ImageFormatter: ImageFormatter,
	  DropDownFormatter: DropDownFormatter
	};

	module.exports = Formatters;

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var Editors = __webpack_require__(197);
	var Formatters = __webpack_require__(200);
	var Toolbar = __webpack_require__(210);
	var ToolsPanel = __webpack_require__(211);
	var Data = __webpack_require__(185);
	var Menu = __webpack_require__(203);
	var Draggable = __webpack_require__(193);
	var DraggableHeader = __webpack_require__(188);
	var Filters = __webpack_require__(180);

	var _require = __webpack_require__(7),
	    rowComparer = _require.RowComparer;

	var performance = __webpack_require__(205);
	var Utils = { rowComparer: rowComparer, performance: performance };

	window.ReactDataGridPlugins = { Editors: Editors, Formatters: Formatters, Toolbar: Toolbar, Menu: Menu, Data: Data, ToolsPanel: ToolsPanel, Draggable: Draggable, DraggableHeader: DraggableHeader, Filters: Filters, Utils: Utils };
	module.exports = { Editors: Editors, Formatters: Formatters, Toolbar: Toolbar, Menu: Menu, Data: Data, ToolsPanel: ToolsPanel, Draggable: Draggable, DraggableHeader: DraggableHeader, Filters: Filters, Utils: Utils };

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var MenuHeader = function (_React$Component) {
	  _inherits(MenuHeader, _React$Component);

	  function MenuHeader() {
	    _classCallCheck(this, MenuHeader);

	    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
	  }

	  MenuHeader.prototype.render = function render() {
	    return _react2['default'].createElement(
	      'div',
	      { className: 'react-context-menu-header' },
	      this.props.children
	    );
	  };

	  return MenuHeader;
	}(_react2['default'].Component);

	MenuHeader.propTypes = {
	  children: _propTypes2['default'].any
	};

	exports['default'] = MenuHeader;

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.ContextMenuTrigger = exports.connect = exports.SubMenu = exports.monitor = exports.MenuItem = exports.MenuHeader = exports.ContextMenu = undefined;

	var _reactContextmenu = __webpack_require__(343);

	var _MenuHeader = __webpack_require__(202);

	var _MenuHeader2 = _interopRequireDefault(_MenuHeader);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	exports.ContextMenu = _reactContextmenu.ContextMenu;
	exports.MenuHeader = _MenuHeader2['default'];
	exports.MenuItem = _reactContextmenu.MenuItem;
	exports.monitor = _reactContextmenu.monitor;
	exports.SubMenu = _reactContextmenu.SubMenu;
	exports.connect = _reactContextmenu.connect;
	exports.ContextMenuTrigger = _reactContextmenu.ContextMenuTrigger;

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _SummaryItemModel = __webpack_require__(98);

	var _SummaryItemModel2 = _interopRequireDefault(_SummaryItemModel);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var SummaryParser = function () {
	  function SummaryParser(summary) {
	    _classCallCheck(this, SummaryParser);

	    this._summary = this._parseSummary(summary);
	    this.getByOwner = this.getByOwner.bind(this);
	    this.getSumByOwner = this.getSumByOwner.bind(this);
	    this.getByComponent = this.getByComponent.bind(this);
	  }

	  SummaryParser.prototype._parseSummary = function _parseSummary(summary) {
	    return summary.map(function (s) {
	      return new _SummaryItemModel2['default'](s);
	    });
	  };

	  SummaryParser.prototype.getByOwner = function getByOwner(ownerName) {
	    return this._summary.filter(function (s) {
	      return s.owner === ownerName;
	    });
	  };

	  SummaryParser.prototype.getSumByOwner = function getSumByOwner(ownerName) {
	    var summaryItemsByOwner = this.getByOwner(ownerName);
	    var summaryItem = new _SummaryItemModel2['default'](ownerName);

	    summaryItemsByOwner.forEach(function (s) {
	      var wastedTime = summaryItem.wastedTime,
	          wastedInstances = summaryItem.wastedInstances;

	      summaryItem.wastedTime = wastedTime + s.wastedTime;
	      summaryItem.wastedInstances = wastedInstances + s.wastedInstances;
	    });

	    return summaryItem;
	  };

	  SummaryParser.prototype.getByComponent = function getByComponent(component) {
	    var componentSummaryItem = this._summary.filter(function (s) {
	      return s.component === component;
	    });

	    if (componentSummaryItem.length > 1) {
	      throw new Error('More then 1 result retrived for ' + component);
	    }

	    if (componentSummaryItem.length === 0) {
	      var emptySummary = new _SummaryItemModel2['default'](component);
	      componentSummaryItem = [emptySummary];
	    }

	    return componentSummaryItem[0];
	  };

	  return SummaryParser;
	}();

	exports['default'] = SummaryParser;

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _SummaryParser = __webpack_require__(204);

	var _SummaryParser2 = _interopRequireDefault(_SummaryParser);

	var _SummaryItemModel = __webpack_require__(98);

	var _SummaryItemModel2 = _interopRequireDefault(_SummaryItemModel);

	var _whyDidYouUpdate = __webpack_require__(206);

	var _whyDidYouUpdate2 = _interopRequireDefault(_whyDidYouUpdate);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	exports['default'] = {
	  SummaryParser: _SummaryParser2['default'],
	  SummaryItemModel: _SummaryItemModel2['default'],
	  whyDidYouUpdate: _whyDidYouUpdate2['default']
	};

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.NOTIFY_LEVELS = undefined;

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _underscore = __webpack_require__(90);

	var _underscore2 = _interopRequireDefault(_underscore);

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint-disable no-console */


	var isRequiredUpdateObject = function isRequiredUpdateObject(o) {
	  return Array.isArray(o) || o && o.constructor === Object.prototype.constructor;
	};
	var NOTIFY_LEVELS = { DEBUG: 0, WARNING: 1, NONE: 2 };
	var isLogEnabled = function isLogEnabled(lvl) {
	  return lvl !== NOTIFY_LEVELS.NONE;
	};
	var isStatusTypeLoggable = function isStatusTypeLoggable(s, lvl) {
	  return s <= lvl;
	};

	var deepDiff = function deepDiff(o1, o2, p, notifyLevel) {
	  var notify = function notify(status, statusType) {
	    if (isStatusTypeLoggable(statusType, notifyLevel)) {
	      console.warn('Update %s', status);
	      console.log('%cbefore', 'font-weight: bold', o1);
	      console.log('%cafter ', 'font-weight: bold', o2);
	    }
	  };

	  if (!_underscore2['default'].isEqual(o1, o2)) {
	    console.group(p);
	    if ([o1, o2].every(_underscore2['default'].isFunction)) {
	      notify('avoidable?', NOTIFY_LEVELS.WARNING);
	    } else if (![o1, o2].every(isRequiredUpdateObject)) {
	      notify('required.', NOTIFY_LEVELS.DEBUG);
	    } else {
	      var keys = _underscore2['default'].union(_underscore2['default'].keys(o1), _underscore2['default'].keys(o2));
	      for (var _iterator = keys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	        var _ref;

	        if (_isArray) {
	          if (_i >= _iterator.length) break;
	          _ref = _iterator[_i++];
	        } else {
	          _i = _iterator.next();
	          if (_i.done) break;
	          _ref = _i.value;
	        }

	        var key = _ref;

	        deepDiff(o1[key], o2[key], key);
	      }
	    }

	    console.groupEnd();
	  } else if (o1 !== o2) {
	    console.group(p);
	    notify('avoidable!', NOTIFY_LEVELS.WARNING);
	    if (_underscore2['default'].isObject(o1) && _underscore2['default'].isObject(o2)) {
	      var _keys = _underscore2['default'].union(_underscore2['default'].keys(o1), _underscore2['default'].keys(o2));
	      for (var _iterator2 = _keys, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
	        var _ref2;

	        if (_isArray2) {
	          if (_i2 >= _iterator2.length) break;
	          _ref2 = _iterator2[_i2++];
	        } else {
	          _i2 = _iterator2.next();
	          if (_i2.done) break;
	          _ref2 = _i2.value;
	        }

	        var _key = _ref2;

	        deepDiff(o1[_key], o2[_key], _key);
	      }
	    }
	    console.groupEnd();
	  }
	};

	var whyDidYouUpdate = function whyDidYouUpdate(WrappedComponent) {
	  var notifyLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : NOTIFY_LEVELS.NONE;

	  return function (_Component) {
	    _inherits(WhyDidYouUpdateComponentWrapper, _Component);

	    function WhyDidYouUpdateComponentWrapper() {
	      _classCallCheck(this, WhyDidYouUpdateComponentWrapper);

	      return _possibleConstructorReturn(this, _Component.apply(this, arguments));
	    }

	    WhyDidYouUpdateComponentWrapper.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
	      if (!isLogEnabled(notifyLevel)) {
	        return;
	      }

	      deepDiff({ props: prevProps, state: prevState }, { props: this.props, state: this.state }, WrappedComponent.displayName, notifyLevel);
	    };

	    WhyDidYouUpdateComponentWrapper.prototype.render = function render() {
	      return _react2['default'].createElement(WrappedComponent, _extends({}, this.props, this.state));
	    };

	    return WhyDidYouUpdateComponentWrapper;
	  }(_react.Component);
	};

	exports['default'] = whyDidYouUpdate;
	exports.NOTIFY_LEVELS = NOTIFY_LEVELS;

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	__webpack_require__(115);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var propTypes = {
	  children: _propTypes2['default'].array
	};

	var defaultProps = {
	  enableAddRow: true
	};

	var AdvancedToolbar = function (_Component) {
	  _inherits(AdvancedToolbar, _Component);

	  function AdvancedToolbar() {
	    _classCallCheck(this, AdvancedToolbar);

	    return _possibleConstructorReturn(this, _Component.apply(this, arguments));
	  }

	  AdvancedToolbar.prototype.render = function render() {
	    return _react2['default'].createElement(
	      'div',
	      { className: 'react-grid-Toolbar' },
	      this.props.children,
	      _react2['default'].createElement('div', { className: 'tools' })
	    );
	  };

	  return AdvancedToolbar;
	}(_react.Component);

	AdvancedToolbar.defaultProps = defaultProps;
	AdvancedToolbar.propTypes = propTypes;

	exports['default'] = AdvancedToolbar;

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var GroupedColumnButton = function (_Component) {
	  _inherits(GroupedColumnButton, _Component);

	  function GroupedColumnButton() {
	    _classCallCheck(this, GroupedColumnButton);

	    return _possibleConstructorReturn(this, _Component.apply(this, arguments));
	  }

	  GroupedColumnButton.prototype.render = function render() {
	    var style = {
	      width: '80px',
	      overflow: 'hidden',
	      textOverflow: 'ellipsis',
	      whiteSpace: 'nowrap'
	    };
	    return _react2['default'].createElement(
	      'button',
	      { className: 'btn grouped-col-btn btn-sm' },
	      _react2['default'].createElement(
	        'span',
	        { style: style },
	        this.props.name
	      ),
	      _react2['default'].createElement('span', {
	        className: 'glyphicon glyphicon-trash',
	        style: { float: 'right', paddingLeft: '5px' },
	        onClick: this.props.onColumnGroupDeleted.bind(null, this.props.columnKey) })
	    );
	  };

	  return GroupedColumnButton;
	}(_react.Component);

	exports['default'] = GroupedColumnButton;


	GroupedColumnButton.propTypes = {
	  name: _propTypes2['default'].string.isRequired,
	  onColumnGroupDeleted: _propTypes2['default'].func,
	  columnKey: _propTypes2['default'].string.isRequired
	};

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _reactDnd = __webpack_require__(14);

	var _GroupedColumnButton = __webpack_require__(208);

	var _GroupedColumnButton2 = _interopRequireDefault(_GroupedColumnButton);

	var _reactDataGrid = __webpack_require__(7);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var DragItemTypes = _reactDataGrid._constants.DragItemTypes;


	var propTypes = {
	  isOver: _propTypes2['default'].bool.isRequired,
	  connectDropTarget: _propTypes2['default'].func,
	  canDrop: _propTypes2['default'].bool.isRequired,
	  groupBy: _propTypes2['default'].array,
	  noColumnsSelectedMessage: _propTypes2['default'].string,
	  panelDescription: _propTypes2['default'].string,
	  onColumnGroupDeleted: _propTypes2['default'].func
	};

	var defaultProps = {
	  noColumnsSelectedMessage: 'Drag a column header here to group by that column',
	  panelDescription: 'Drag a column header here to group by that column'
	};

	var GroupedColumnsPanel = function (_Component) {
	  _inherits(GroupedColumnsPanel, _Component);

	  function GroupedColumnsPanel() {
	    _classCallCheck(this, GroupedColumnsPanel);

	    return _possibleConstructorReturn(this, _Component.call(this));
	  }

	  GroupedColumnsPanel.prototype.getPanelInstructionMessage = function getPanelInstructionMessage() {
	    var groupBy = this.props.groupBy;

	    return groupBy && groupBy.length > 0 ? this.props.panelDescription : this.props.noColumnsSelectedMessage;
	  };

	  GroupedColumnsPanel.prototype.renderGroupedColumns = function renderGroupedColumns() {
	    var _this2 = this;

	    return this.props.groupBy.map(function (c) {
	      var groupedColumnButtonProps = {
	        columnKey: typeof c === 'string' ? c : c.key,
	        name: typeof c === 'string' ? c : c.name,
	        onColumnGroupDeleted: _this2.props.onColumnGroupDeleted,
	        key: typeof c === 'string' ? c : c.key
	      };
	      return _react2['default'].createElement(_GroupedColumnButton2['default'], groupedColumnButtonProps);
	    });
	  };

	  GroupedColumnsPanel.prototype.renderOverlay = function renderOverlay(color) {
	    return _react2['default'].createElement('div', { style: {
	        position: 'absolute',
	        top: 0,
	        left: 0,
	        height: '100%',
	        width: '100%',
	        zIndex: 1,
	        opacity: 0.5,
	        backgroundColor: color
	      } });
	  };

	  GroupedColumnsPanel.prototype.render = function render() {
	    var _props = this.props,
	        connectDropTarget = _props.connectDropTarget,
	        isOver = _props.isOver,
	        canDrop = _props.canDrop;

	    return connectDropTarget(_react2['default'].createElement(
	      'div',
	      { style: { padding: '2px', position: 'relative', margin: '-10px', display: 'inline-block', border: '1px solid #eee' } },
	      this.renderGroupedColumns(),
	      ' ',
	      _react2['default'].createElement(
	        'span',
	        null,
	        this.getPanelInstructionMessage()
	      ),
	      isOver && canDrop && this.renderOverlay('yellow'),
	      !isOver && canDrop && this.renderOverlay('#DBECFA')
	    ));
	  };

	  return GroupedColumnsPanel;
	}(_react.Component);

	GroupedColumnsPanel.defaultProps = defaultProps;
	GroupedColumnsPanel.propTypes = propTypes;

	var columnTarget = {
	  drop: function drop(props, monitor) {
	    // Obtain the dragged item
	    var item = monitor.getItem();
	    if (typeof props.onColumnGroupAdded === 'function') {
	      props.onColumnGroupAdded(item.key);
	    }
	  }
	};

	function collect(connect, monitor) {
	  return {
	    connectDropTarget: connect.dropTarget(),
	    isOver: monitor.isOver(),
	    canDrop: monitor.canDrop(),
	    draggedolumn: monitor.getItem()
	  };
	}

	exports['default'] = (0, _reactDnd.DropTarget)(DragItemTypes.Column, columnTarget, collect)(GroupedColumnsPanel);

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var React = __webpack_require__(2);
	__webpack_require__(115);

	var Toolbar = function (_React$Component) {
	  _inherits(Toolbar, _React$Component);

	  function Toolbar() {
	    var _temp, _this, _ret;

	    _classCallCheck(this, Toolbar);

	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.onAddRow = function () {
	      if (_this.props.onAddRow !== null && _this.props.onAddRow instanceof Function) {
	        _this.props.onAddRow({ newRowIndex: _this.props.numberOfRows });
	      }
	    }, _this.renderAddRowButton = function () {
	      if (_this.props.onAddRow) {
	        return React.createElement(
	          'button',
	          { type: 'button', className: 'btn', onClick: _this.onAddRow },
	          _this.props.addRowButtonText
	        );
	      }
	    }, _this.renderToggleFilterButton = function () {
	      if (_this.props.enableFilter) {
	        return React.createElement(
	          'button',
	          { type: 'button', className: 'btn', onClick: _this.props.onToggleFilter },
	          _this.props.filterRowsButtonText
	        );
	      }
	    }, _temp), _possibleConstructorReturn(_this, _ret);
	  }

	  Toolbar.prototype.render = function render() {
	    return React.createElement(
	      'div',
	      { className: 'react-grid-Toolbar' },
	      React.createElement(
	        'div',
	        { className: 'tools' },
	        this.renderAddRowButton(),
	        this.renderToggleFilterButton(),
	        this.props.children
	      )
	    );
	  };

	  return Toolbar;
	}(React.Component);

	Toolbar.propTypes = {
	  onAddRow: _propTypes2['default'].func,
	  onToggleFilter: _propTypes2['default'].func,
	  enableFilter: _propTypes2['default'].bool,
	  numberOfRows: _propTypes2['default'].number,
	  addRowButtonText: _propTypes2['default'].string,
	  filterRowsButtonText: _propTypes2['default'].string,
	  children: _propTypes2['default'].any
	};
	Toolbar.defaultProps = {
	  enableAddRow: true,
	  addRowButtonText: 'Add Row',
	  filterRowsButtonText: 'Filter Rows'
	};


	module.exports = Toolbar;

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _AdvancedToolbar = __webpack_require__(207);

	var _AdvancedToolbar2 = _interopRequireDefault(_AdvancedToolbar);

	var _GroupedColumnsPanel = __webpack_require__(209);

	var _GroupedColumnsPanel2 = _interopRequireDefault(_GroupedColumnsPanel);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	module.exports = { AdvancedToolbar: _AdvancedToolbar2['default'], GroupedColumnsPanel: _GroupedColumnsPanel2['default'] };

/***/ }),
/* 212 */,
/* 213 */,
/* 214 */,
/* 215 */,
/* 216 */,
/* 217 */,
/* 218 */,
/* 219 */,
/* 220 */,
/* 221 */,
/* 222 */,
/* 223 */,
/* 224 */,
/* 225 */,
/* 226 */,
/* 227 */,
/* 228 */,
/* 229 */,
/* 230 */,
/* 231 */,
/* 232 */,
/* 233 */,
/* 234 */,
/* 235 */,
/* 236 */,
/* 237 */,
/* 238 */,
/* 239 */,
/* 240 */,
/* 241 */,
/* 242 */,
/* 243 */,
/* 244 */,
/* 245 */,
/* 246 */,
/* 247 */,
/* 248 */,
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

	exports.__esModule = true;

	var _isDisposable = __webpack_require__(65);

	var _isDisposable2 = _interopRequireWildcard(_isDisposable);

	/**
	 * Represents a group of disposable resources that are disposed together.
	 */

	var CompositeDisposable = (function () {
	  function CompositeDisposable() {
	    for (var _len = arguments.length, disposables = Array(_len), _key = 0; _key < _len; _key++) {
	      disposables[_key] = arguments[_key];
	    }

	    _classCallCheck(this, CompositeDisposable);

	    if (Array.isArray(disposables[0]) && disposables.length === 1) {
	      disposables = disposables[0];
	    }

	    for (var i = 0; i < disposables.length; i++) {
	      if (!_isDisposable2['default'](disposables[i])) {
	        throw new Error('Expected a disposable');
	      }
	    }

	    this.disposables = disposables;
	    this.isDisposed = false;
	  }

	  /**
	   * Adds a disposable to the CompositeDisposable or disposes the disposable if the CompositeDisposable is disposed.
	   * @param {Disposable} item Disposable to add.
	   */

	  CompositeDisposable.prototype.add = function add(item) {
	    if (this.isDisposed) {
	      item.dispose();
	    } else {
	      this.disposables.push(item);
	    }
	  };

	  /**
	   * Removes and disposes the first occurrence of a disposable from the CompositeDisposable.
	   * @param {Disposable} item Disposable to remove.
	   * @returns {Boolean} true if found; false otherwise.
	   */

	  CompositeDisposable.prototype.remove = function remove(item) {
	    if (this.isDisposed) {
	      return false;
	    }

	    var index = this.disposables.indexOf(item);
	    if (index === -1) {
	      return false;
	    }

	    this.disposables.splice(index, 1);
	    item.dispose();
	    return true;
	  };

	  /**
	   * Disposes all disposables in the group and removes them from the group.
	   */

	  CompositeDisposable.prototype.dispose = function dispose() {
	    if (this.isDisposed) {
	      return;
	    }

	    var len = this.disposables.length;
	    var currentDisposables = new Array(len);
	    for (var i = 0; i < len; i++) {
	      currentDisposables[i] = this.disposables[i];
	    }

	    this.isDisposed = true;
	    this.disposables = [];
	    this.length = 0;

	    for (var i = 0; i < len; i++) {
	      currentDisposables[i].dispose();
	    }
	  };

	  return CompositeDisposable;
	})();

	exports['default'] = CompositeDisposable;
	module.exports = exports['default'];

/***/ }),
/* 250 */
/***/ (function(module, exports) {

	"use strict";

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	exports.__esModule = true;
	var noop = function noop() {};

	/**
	 * The basic disposable.
	 */

	var Disposable = (function () {
	  function Disposable(action) {
	    _classCallCheck(this, Disposable);

	    this.isDisposed = false;
	    this.action = action || noop;
	  }

	  Disposable.prototype.dispose = function dispose() {
	    if (!this.isDisposed) {
	      this.action.call(null);
	      this.isDisposed = true;
	    }
	  };

	  _createClass(Disposable, null, [{
	    key: "empty",
	    enumerable: true,
	    value: { dispose: noop }
	  }]);

	  return Disposable;
	})();

	exports["default"] = Disposable;
	module.exports = exports["default"];

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

	var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

	exports.__esModule = true;

	var _isDisposable = __webpack_require__(65);

	var _isDisposable2 = _interopRequireWildcard(_isDisposable);

	var SerialDisposable = (function () {
	  function SerialDisposable() {
	    _classCallCheck(this, SerialDisposable);

	    this.isDisposed = false;
	    this.current = null;
	  }

	  /**
	   * Gets the underlying disposable.
	   * @return The underlying disposable.
	   */

	  SerialDisposable.prototype.getDisposable = function getDisposable() {
	    return this.current;
	  };

	  /**
	   * Sets the underlying disposable.
	   * @param {Disposable} value The new underlying disposable.
	   */

	  SerialDisposable.prototype.setDisposable = function setDisposable() {
	    var value = arguments[0] === undefined ? null : arguments[0];

	    if (value != null && !_isDisposable2['default'](value)) {
	      throw new Error('Expected either an empty value or a valid disposable');
	    }

	    var isDisposed = this.isDisposed;
	    var previous = undefined;

	    if (!isDisposed) {
	      previous = this.current;
	      this.current = value;
	    }

	    if (previous) {
	      previous.dispose();
	    }

	    if (isDisposed && value) {
	      value.dispose();
	    }
	  };

	  /**
	   * Disposes the underlying disposable as well as all future replacements.
	   */

	  SerialDisposable.prototype.dispose = function dispose() {
	    if (this.isDisposed) {
	      return;
	    }

	    this.isDisposed = true;
	    var previous = this.current;
	    this.current = null;

	    if (previous) {
	      previous.dispose();
	    }
	  };

	  return SerialDisposable;
	})();

	exports['default'] = SerialDisposable;
	module.exports = exports['default'];

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

	exports.__esModule = true;

	var _isDisposable2 = __webpack_require__(65);

	var _isDisposable3 = _interopRequireWildcard(_isDisposable2);

	exports.isDisposable = _isDisposable3['default'];

	var _Disposable2 = __webpack_require__(250);

	var _Disposable3 = _interopRequireWildcard(_Disposable2);

	exports.Disposable = _Disposable3['default'];

	var _CompositeDisposable2 = __webpack_require__(249);

	var _CompositeDisposable3 = _interopRequireWildcard(_CompositeDisposable2);

	exports.CompositeDisposable = _CompositeDisposable3['default'];

	var _SerialDisposable2 = __webpack_require__(251);

	var _SerialDisposable3 = _interopRequireWildcard(_SerialDisposable2);

	exports.SerialDisposable = _SerialDisposable3['default'];

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _createStore = __webpack_require__(368);

	var _createStore2 = _interopRequireDefault(_createStore);

	var _reducers = __webpack_require__(261);

	var _reducers2 = _interopRequireDefault(_reducers);

	var _dragDrop = __webpack_require__(36);

	var dragDropActions = _interopRequireWildcard(_dragDrop);

	var _DragDropMonitor = __webpack_require__(254);

	var _DragDropMonitor2 = _interopRequireDefault(_DragDropMonitor);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var DragDropManager = function () {
		function DragDropManager(createBackend) {
			var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

			_classCallCheck(this, DragDropManager);

			var store = (0, _createStore2.default)(_reducers2.default);
			this.context = context;
			this.store = store;
			this.monitor = new _DragDropMonitor2.default(store);
			this.registry = this.monitor.registry;
			this.backend = createBackend(this);

			store.subscribe(this.handleRefCountChange.bind(this));
		}

		_createClass(DragDropManager, [{
			key: 'handleRefCountChange',
			value: function handleRefCountChange() {
				var shouldSetUp = this.store.getState().refCount > 0;
				if (shouldSetUp && !this.isSetUp) {
					this.backend.setup();
					this.isSetUp = true;
				} else if (!shouldSetUp && this.isSetUp) {
					this.backend.teardown();
					this.isSetUp = false;
				}
			}
		}, {
			key: 'getContext',
			value: function getContext() {
				return this.context;
			}
		}, {
			key: 'getMonitor',
			value: function getMonitor() {
				return this.monitor;
			}
		}, {
			key: 'getBackend',
			value: function getBackend() {
				return this.backend;
			}
		}, {
			key: 'getRegistry',
			value: function getRegistry() {
				return this.registry;
			}
		}, {
			key: 'getActions',
			value: function getActions() {
				var manager = this;
				var dispatch = this.store.dispatch;


				function bindActionCreator(actionCreator) {
					return function () {
						for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
							args[_key] = arguments[_key];
						}

						var action = actionCreator.apply(manager, args);
						if (typeof action !== 'undefined') {
							dispatch(action);
						}
					};
				}

				return Object.keys(dragDropActions).filter(function (key) {
					return typeof dragDropActions[key] === 'function';
				}).reduce(function (boundActions, key) {
					var action = dragDropActions[key];
					boundActions[key] = bindActionCreator(action); // eslint-disable-line no-param-reassign
					return boundActions;
				}, {});
			}
		}]);

		return DragDropManager;
	}();

	exports.default = DragDropManager;

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _invariant = __webpack_require__(8);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _isArray = __webpack_require__(18);

	var _isArray2 = _interopRequireDefault(_isArray);

	var _matchesType = __webpack_require__(113);

	var _matchesType2 = _interopRequireDefault(_matchesType);

	var _HandlerRegistry = __webpack_require__(257);

	var _HandlerRegistry2 = _interopRequireDefault(_HandlerRegistry);

	var _dragOffset = __webpack_require__(112);

	var _dirtyHandlerIds = __webpack_require__(111);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var DragDropMonitor = function () {
		function DragDropMonitor(store) {
			_classCallCheck(this, DragDropMonitor);

			this.store = store;
			this.registry = new _HandlerRegistry2.default(store);
		}

		_createClass(DragDropMonitor, [{
			key: 'subscribeToStateChange',
			value: function subscribeToStateChange(listener) {
				var _this = this;

				var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
				var handlerIds = options.handlerIds;

				(0, _invariant2.default)(typeof listener === 'function', 'listener must be a function.');
				(0, _invariant2.default)(typeof handlerIds === 'undefined' || (0, _isArray2.default)(handlerIds), 'handlerIds, when specified, must be an array of strings.');

				var prevStateId = this.store.getState().stateId;
				var handleChange = function handleChange() {
					var state = _this.store.getState();
					var currentStateId = state.stateId;
					try {
						var canSkipListener = currentStateId === prevStateId || currentStateId === prevStateId + 1 && !(0, _dirtyHandlerIds.areDirty)(state.dirtyHandlerIds, handlerIds);

						if (!canSkipListener) {
							listener();
						}
					} finally {
						prevStateId = currentStateId;
					}
				};

				return this.store.subscribe(handleChange);
			}
		}, {
			key: 'subscribeToOffsetChange',
			value: function subscribeToOffsetChange(listener) {
				var _this2 = this;

				(0, _invariant2.default)(typeof listener === 'function', 'listener must be a function.');

				var previousState = this.store.getState().dragOffset;
				var handleChange = function handleChange() {
					var nextState = _this2.store.getState().dragOffset;
					if (nextState === previousState) {
						return;
					}

					previousState = nextState;
					listener();
				};

				return this.store.subscribe(handleChange);
			}
		}, {
			key: 'canDragSource',
			value: function canDragSource(sourceId) {
				var source = this.registry.getSource(sourceId);
				(0, _invariant2.default)(source, 'Expected to find a valid source.');

				if (this.isDragging()) {
					return false;
				}

				return source.canDrag(this, sourceId);
			}
		}, {
			key: 'canDropOnTarget',
			value: function canDropOnTarget(targetId) {
				var target = this.registry.getTarget(targetId);
				(0, _invariant2.default)(target, 'Expected to find a valid target.');

				if (!this.isDragging() || this.didDrop()) {
					return false;
				}

				var targetType = this.registry.getTargetType(targetId);
				var draggedItemType = this.getItemType();
				return (0, _matchesType2.default)(targetType, draggedItemType) && target.canDrop(this, targetId);
			}
		}, {
			key: 'isDragging',
			value: function isDragging() {
				return Boolean(this.getItemType());
			}
		}, {
			key: 'isDraggingSource',
			value: function isDraggingSource(sourceId) {
				var source = this.registry.getSource(sourceId, true);
				(0, _invariant2.default)(source, 'Expected to find a valid source.');

				if (!this.isDragging() || !this.isSourcePublic()) {
					return false;
				}

				var sourceType = this.registry.getSourceType(sourceId);
				var draggedItemType = this.getItemType();
				if (sourceType !== draggedItemType) {
					return false;
				}

				return source.isDragging(this, sourceId);
			}
		}, {
			key: 'isOverTarget',
			value: function isOverTarget(targetId) {
				var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { shallow: false };
				var shallow = options.shallow;

				if (!this.isDragging()) {
					return false;
				}

				var targetType = this.registry.getTargetType(targetId);
				var draggedItemType = this.getItemType();
				if (!(0, _matchesType2.default)(targetType, draggedItemType)) {
					return false;
				}

				var targetIds = this.getTargetIds();
				if (!targetIds.length) {
					return false;
				}

				var index = targetIds.indexOf(targetId);
				if (shallow) {
					return index === targetIds.length - 1;
				} else {
					return index > -1;
				}
			}
		}, {
			key: 'getItemType',
			value: function getItemType() {
				return this.store.getState().dragOperation.itemType;
			}
		}, {
			key: 'getItem',
			value: function getItem() {
				return this.store.getState().dragOperation.item;
			}
		}, {
			key: 'getSourceId',
			value: function getSourceId() {
				return this.store.getState().dragOperation.sourceId;
			}
		}, {
			key: 'getTargetIds',
			value: function getTargetIds() {
				return this.store.getState().dragOperation.targetIds;
			}
		}, {
			key: 'getDropResult',
			value: function getDropResult() {
				return this.store.getState().dragOperation.dropResult;
			}
		}, {
			key: 'didDrop',
			value: function didDrop() {
				return this.store.getState().dragOperation.didDrop;
			}
		}, {
			key: 'isSourcePublic',
			value: function isSourcePublic() {
				return this.store.getState().dragOperation.isSourcePublic;
			}
		}, {
			key: 'getInitialClientOffset',
			value: function getInitialClientOffset() {
				return this.store.getState().dragOffset.initialClientOffset;
			}
		}, {
			key: 'getInitialSourceClientOffset',
			value: function getInitialSourceClientOffset() {
				return this.store.getState().dragOffset.initialSourceClientOffset;
			}
		}, {
			key: 'getClientOffset',
			value: function getClientOffset() {
				return this.store.getState().dragOffset.clientOffset;
			}
		}, {
			key: 'getSourceClientOffset',
			value: function getSourceClientOffset() {
				return (0, _dragOffset.getSourceClientOffset)(this.store.getState().dragOffset);
			}
		}, {
			key: 'getDifferenceFromInitialOffset',
			value: function getDifferenceFromInitialOffset() {
				return (0, _dragOffset.getDifferenceFromInitialOffset)(this.store.getState().dragOffset);
			}
		}]);

		return DragDropMonitor;
	}();

	exports.default = DragDropMonitor;

/***/ }),
/* 255 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var DragSource = function () {
		function DragSource() {
			_classCallCheck(this, DragSource);
		}

		_createClass(DragSource, [{
			key: "canDrag",
			value: function canDrag() {
				return true;
			}
		}, {
			key: "isDragging",
			value: function isDragging(monitor, handle) {
				return handle === monitor.getSourceId();
			}
		}, {
			key: "endDrag",
			value: function endDrag() {}
		}]);

		return DragSource;
	}();

	exports.default = DragSource;

/***/ }),
/* 256 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var DropTarget = function () {
		function DropTarget() {
			_classCallCheck(this, DropTarget);
		}

		_createClass(DropTarget, [{
			key: "canDrop",
			value: function canDrop() {
				return true;
			}
		}, {
			key: "hover",
			value: function hover() {}
		}, {
			key: "drop",
			value: function drop() {}
		}]);

		return DropTarget;
	}();

	exports.default = DropTarget;

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _invariant = __webpack_require__(8);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _isArray = __webpack_require__(18);

	var _isArray2 = _interopRequireDefault(_isArray);

	var _asap = __webpack_require__(175);

	var _asap2 = _interopRequireDefault(_asap);

	var _registry = __webpack_require__(37);

	var _getNextUniqueId = __webpack_require__(264);

	var _getNextUniqueId2 = _interopRequireDefault(_getNextUniqueId);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var HandlerRoles = {
		SOURCE: 'SOURCE',
		TARGET: 'TARGET'
	};

	function validateSourceContract(source) {
		(0, _invariant2.default)(typeof source.canDrag === 'function', 'Expected canDrag to be a function.');
		(0, _invariant2.default)(typeof source.beginDrag === 'function', 'Expected beginDrag to be a function.');
		(0, _invariant2.default)(typeof source.endDrag === 'function', 'Expected endDrag to be a function.');
	}

	function validateTargetContract(target) {
		(0, _invariant2.default)(typeof target.canDrop === 'function', 'Expected canDrop to be a function.');
		(0, _invariant2.default)(typeof target.hover === 'function', 'Expected hover to be a function.');
		(0, _invariant2.default)(typeof target.drop === 'function', 'Expected beginDrag to be a function.');
	}

	function validateType(type, allowArray) {
		if (allowArray && (0, _isArray2.default)(type)) {
			type.forEach(function (t) {
				return validateType(t, false);
			});
			return;
		}

		(0, _invariant2.default)(typeof type === 'string' || (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'symbol', allowArray ? 'Type can only be a string, a symbol, or an array of either.' : 'Type can only be a string or a symbol.');
	}

	function getNextHandlerId(role) {
		var id = (0, _getNextUniqueId2.default)().toString();
		switch (role) {
			case HandlerRoles.SOURCE:
				return 'S' + id;
			case HandlerRoles.TARGET:
				return 'T' + id;
			default:
				(0, _invariant2.default)(false, 'Unknown role: ' + role);
		}
	}

	function parseRoleFromHandlerId(handlerId) {
		switch (handlerId[0]) {
			case 'S':
				return HandlerRoles.SOURCE;
			case 'T':
				return HandlerRoles.TARGET;
			default:
				(0, _invariant2.default)(false, 'Cannot parse handler ID: ' + handlerId);
		}
	}

	var HandlerRegistry = function () {
		function HandlerRegistry(store) {
			_classCallCheck(this, HandlerRegistry);

			this.store = store;

			this.types = {};
			this.handlers = {};

			this.pinnedSourceId = null;
			this.pinnedSource = null;
		}

		_createClass(HandlerRegistry, [{
			key: 'addSource',
			value: function addSource(type, source) {
				validateType(type);
				validateSourceContract(source);

				var sourceId = this.addHandler(HandlerRoles.SOURCE, type, source);
				this.store.dispatch((0, _registry.addSource)(sourceId));
				return sourceId;
			}
		}, {
			key: 'addTarget',
			value: function addTarget(type, target) {
				validateType(type, true);
				validateTargetContract(target);

				var targetId = this.addHandler(HandlerRoles.TARGET, type, target);
				this.store.dispatch((0, _registry.addTarget)(targetId));
				return targetId;
			}
		}, {
			key: 'addHandler',
			value: function addHandler(role, type, handler) {
				var id = getNextHandlerId(role);
				this.types[id] = type;
				this.handlers[id] = handler;

				return id;
			}
		}, {
			key: 'containsHandler',
			value: function containsHandler(handler) {
				var _this = this;

				return Object.keys(this.handlers).some(function (key) {
					return _this.handlers[key] === handler;
				});
			}
		}, {
			key: 'getSource',
			value: function getSource(sourceId, includePinned) {
				(0, _invariant2.default)(this.isSourceId(sourceId), 'Expected a valid source ID.');

				var isPinned = includePinned && sourceId === this.pinnedSourceId;
				var source = isPinned ? this.pinnedSource : this.handlers[sourceId];

				return source;
			}
		}, {
			key: 'getTarget',
			value: function getTarget(targetId) {
				(0, _invariant2.default)(this.isTargetId(targetId), 'Expected a valid target ID.');
				return this.handlers[targetId];
			}
		}, {
			key: 'getSourceType',
			value: function getSourceType(sourceId) {
				(0, _invariant2.default)(this.isSourceId(sourceId), 'Expected a valid source ID.');
				return this.types[sourceId];
			}
		}, {
			key: 'getTargetType',
			value: function getTargetType(targetId) {
				(0, _invariant2.default)(this.isTargetId(targetId), 'Expected a valid target ID.');
				return this.types[targetId];
			}
		}, {
			key: 'isSourceId',
			value: function isSourceId(handlerId) {
				var role = parseRoleFromHandlerId(handlerId);
				return role === HandlerRoles.SOURCE;
			}
		}, {
			key: 'isTargetId',
			value: function isTargetId(handlerId) {
				var role = parseRoleFromHandlerId(handlerId);
				return role === HandlerRoles.TARGET;
			}
		}, {
			key: 'removeSource',
			value: function removeSource(sourceId) {
				var _this2 = this;

				(0, _invariant2.default)(this.getSource(sourceId), 'Expected an existing source.');
				this.store.dispatch((0, _registry.removeSource)(sourceId));

				(0, _asap2.default)(function () {
					delete _this2.handlers[sourceId];
					delete _this2.types[sourceId];
				});
			}
		}, {
			key: 'removeTarget',
			value: function removeTarget(targetId) {
				var _this3 = this;

				(0, _invariant2.default)(this.getTarget(targetId), 'Expected an existing target.');
				this.store.dispatch((0, _registry.removeTarget)(targetId));

				(0, _asap2.default)(function () {
					delete _this3.handlers[targetId];
					delete _this3.types[targetId];
				});
			}
		}, {
			key: 'pinSource',
			value: function pinSource(sourceId) {
				var source = this.getSource(sourceId);
				(0, _invariant2.default)(source, 'Expected an existing source.');

				this.pinnedSourceId = sourceId;
				this.pinnedSource = source;
			}
		}, {
			key: 'unpinSource',
			value: function unpinSource() {
				(0, _invariant2.default)(this.pinnedSource, 'No source is pinned at the time.');

				this.pinnedSourceId = null;
				this.pinnedSource = null;
			}
		}]);

		return HandlerRegistry;
	}();

	exports.default = HandlerRegistry;

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	exports.default = createBackend;

	var _noop = __webpack_require__(131);

	var _noop2 = _interopRequireDefault(_noop);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var TestBackend = function () {
		function TestBackend(manager) {
			_classCallCheck(this, TestBackend);

			this.actions = manager.getActions();
		}

		_createClass(TestBackend, [{
			key: 'setup',
			value: function setup() {
				this.didCallSetup = true;
			}
		}, {
			key: 'teardown',
			value: function teardown() {
				this.didCallTeardown = true;
			}
		}, {
			key: 'connectDragSource',
			value: function connectDragSource() {
				return _noop2.default;
			}
		}, {
			key: 'connectDragPreview',
			value: function connectDragPreview() {
				return _noop2.default;
			}
		}, {
			key: 'connectDropTarget',
			value: function connectDropTarget() {
				return _noop2.default;
			}
		}, {
			key: 'simulateBeginDrag',
			value: function simulateBeginDrag(sourceIds, options) {
				this.actions.beginDrag(sourceIds, options);
			}
		}, {
			key: 'simulatePublishDragSource',
			value: function simulatePublishDragSource() {
				this.actions.publishDragSource();
			}
		}, {
			key: 'simulateHover',
			value: function simulateHover(targetIds, options) {
				this.actions.hover(targetIds, options);
			}
		}, {
			key: 'simulateDrop',
			value: function simulateDrop() {
				this.actions.drop();
			}
		}, {
			key: 'simulateEndDrag',
			value: function simulateEndDrag() {
				this.actions.endDrag();
			}
		}]);

		return TestBackend;
	}();

	function createBackend(manager) {
		return new TestBackend(manager);
	}

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _DragDropManager = __webpack_require__(253);

	Object.defineProperty(exports, 'DragDropManager', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_DragDropManager).default;
	  }
	});

	var _DragSource = __webpack_require__(255);

	Object.defineProperty(exports, 'DragSource', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_DragSource).default;
	  }
	});

	var _DropTarget = __webpack_require__(256);

	Object.defineProperty(exports, 'DropTarget', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_DropTarget).default;
	  }
	});

	var _createTestBackend = __webpack_require__(258);

	Object.defineProperty(exports, 'createTestBackend', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_createTestBackend).default;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	exports.default = dragOperation;

	var _without = __webpack_require__(132);

	var _without2 = _interopRequireDefault(_without);

	var _dragDrop = __webpack_require__(36);

	var _registry = __webpack_require__(37);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var initialState = {
		itemType: null,
		item: null,
		sourceId: null,
		targetIds: [],
		dropResult: null,
		didDrop: false,
		isSourcePublic: null
	};

	function dragOperation() {
		var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
		var action = arguments[1];

		switch (action.type) {
			case _dragDrop.BEGIN_DRAG:
				return _extends({}, state, {
					itemType: action.itemType,
					item: action.item,
					sourceId: action.sourceId,
					isSourcePublic: action.isSourcePublic,
					dropResult: null,
					didDrop: false
				});
			case _dragDrop.PUBLISH_DRAG_SOURCE:
				return _extends({}, state, {
					isSourcePublic: true
				});
			case _dragDrop.HOVER:
				return _extends({}, state, {
					targetIds: action.targetIds
				});
			case _registry.REMOVE_TARGET:
				if (state.targetIds.indexOf(action.targetId) === -1) {
					return state;
				}
				return _extends({}, state, {
					targetIds: (0, _without2.default)(state.targetIds, action.targetId)
				});
			case _dragDrop.DROP:
				return _extends({}, state, {
					dropResult: action.dropResult,
					didDrop: true,
					targetIds: []
				});
			case _dragDrop.END_DRAG:
				return _extends({}, state, {
					itemType: null,
					item: null,
					sourceId: null,
					dropResult: null,
					didDrop: false,
					isSourcePublic: null,
					targetIds: []
				});
			default:
				return state;
		}
	}

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = reduce;

	var _dragOffset = __webpack_require__(112);

	var _dragOffset2 = _interopRequireDefault(_dragOffset);

	var _dragOperation = __webpack_require__(260);

	var _dragOperation2 = _interopRequireDefault(_dragOperation);

	var _refCount = __webpack_require__(262);

	var _refCount2 = _interopRequireDefault(_refCount);

	var _dirtyHandlerIds = __webpack_require__(111);

	var _dirtyHandlerIds2 = _interopRequireDefault(_dirtyHandlerIds);

	var _stateId = __webpack_require__(263);

	var _stateId2 = _interopRequireDefault(_stateId);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function reduce() {
		var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
		var action = arguments[1];

		return {
			dirtyHandlerIds: (0, _dirtyHandlerIds2.default)(state.dirtyHandlerIds, action, state.dragOperation),
			dragOffset: (0, _dragOffset2.default)(state.dragOffset, action),
			refCount: (0, _refCount2.default)(state.refCount, action),
			dragOperation: (0, _dragOperation2.default)(state.dragOperation, action),
			stateId: (0, _stateId2.default)(state.stateId)
		};
	}

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = refCount;

	var _registry = __webpack_require__(37);

	function refCount() {
		var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
		var action = arguments[1];

		switch (action.type) {
			case _registry.ADD_SOURCE:
			case _registry.ADD_TARGET:
				return state + 1;
			case _registry.REMOVE_SOURCE:
			case _registry.REMOVE_TARGET:
				return state - 1;
			default:
				return state;
		}
	}

/***/ }),
/* 263 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = stateId;
	function stateId() {
		var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

		return state + 1;
	}

/***/ }),
/* 264 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = getNextUniqueId;
	var nextUniqueId = 0;

	function getNextUniqueId() {
		return nextUniqueId++;
	}

/***/ }),
/* 265 */
33,
/* 266 */
33,
/* 267 */
33,
/* 268 */
33,
/* 269 */,
/* 270 */,
/* 271 */
[1582, 299, 300, 301, 302, 303],
/* 272 */
[1588, 309, 310, 311, 312, 313],
/* 273 */
[1590, 42, 27],
/* 274 */
[1602, 42, 27],
/* 275 */
/***/ (function(module, exports) {

	/**
	 * A specialized version of `_.filter` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function arrayFilter(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	module.exports = arrayFilter;


/***/ }),
/* 276 */
[1616, 288, 128, 18, 334, 125, 335],
/* 277 */
/***/ (function(module, exports) {

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	module.exports = arrayPush;


/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

	var baseAssignValue = __webpack_require__(119),
	    eq = __webpack_require__(44);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue(object, key, value);
	  }
	}

	module.exports = assignValue;


/***/ }),
/* 279 */
/***/ (function(module, exports) {

	/**
	 * The base implementation of `_.findIndex` and `_.findLastIndex` without
	 * support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} predicate The function invoked per iteration.
	 * @param {number} fromIndex The index to search from.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseFindIndex(array, predicate, fromIndex, fromRight) {
	  var length = array.length,
	      index = fromIndex + (fromRight ? 1 : -1);

	  while ((fromRight ? index-- : ++index < length)) {
	    if (predicate(array[index], index, array)) {
	      return index;
	    }
	  }
	  return -1;
	}

	module.exports = baseFindIndex;


/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

	var baseFindIndex = __webpack_require__(279),
	    baseIsNaN = __webpack_require__(283),
	    strictIndexOf = __webpack_require__(328);

	/**
	 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseIndexOf(array, value, fromIndex) {
	  return value === value
	    ? strictIndexOf(array, value, fromIndex)
	    : baseFindIndex(array, baseIsNaN, fromIndex);
	}

	module.exports = baseIndexOf;


/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

	var SetCache = __webpack_require__(67),
	    arrayIncludes = __webpack_require__(69),
	    arrayIncludesWith = __webpack_require__(70),
	    arrayMap = __webpack_require__(71),
	    baseUnary = __webpack_require__(72),
	    cacheHas = __webpack_require__(73);

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMin = Math.min;

	/**
	 * The base implementation of methods like `_.intersection`, without support
	 * for iteratee shorthands, that accepts an array of arrays to inspect.
	 *
	 * @private
	 * @param {Array} arrays The arrays to inspect.
	 * @param {Function} [iteratee] The iteratee invoked per element.
	 * @param {Function} [comparator] The comparator invoked per element.
	 * @returns {Array} Returns the new array of shared values.
	 */
	function baseIntersection(arrays, iteratee, comparator) {
	  var includes = comparator ? arrayIncludesWith : arrayIncludes,
	      length = arrays[0].length,
	      othLength = arrays.length,
	      othIndex = othLength,
	      caches = Array(othLength),
	      maxLength = Infinity,
	      result = [];

	  while (othIndex--) {
	    var array = arrays[othIndex];
	    if (othIndex && iteratee) {
	      array = arrayMap(array, baseUnary(iteratee));
	    }
	    maxLength = nativeMin(array.length, maxLength);
	    caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
	      ? new SetCache(othIndex && array)
	      : undefined;
	  }
	  array = arrays[0];

	  var index = -1,
	      seen = caches[0];

	  outer:
	  while (++index < length && result.length < maxLength) {
	    var value = array[index],
	        computed = iteratee ? iteratee(value) : value;

	    value = (comparator || value !== 0) ? value : 0;
	    if (!(seen
	          ? cacheHas(seen, computed)
	          : includes(result, computed, comparator)
	        )) {
	      othIndex = othLength;
	      while (--othIndex) {
	        var cache = caches[othIndex];
	        if (!(cache
	              ? cacheHas(cache, computed)
	              : includes(arrays[othIndex], computed, comparator))
	            ) {
	          continue outer;
	        }
	      }
	      if (seen) {
	        seen.push(computed);
	      }
	      result.push(value);
	    }
	  }
	  return result;
	}

	module.exports = baseIntersection;


/***/ }),
/* 282 */
[1639, 40, 29],
/* 283 */
/***/ (function(module, exports) {

	/**
	 * The base implementation of `_.isNaN` without support for number objects.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	 */
	function baseIsNaN(value) {
	  return value !== value;
	}

	module.exports = baseIsNaN;


/***/ }),
/* 284 */
[1641, 129, 307, 28, 329],
/* 285 */
[1649, 40, 130, 29],
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(28),
	    isPrototype = __webpack_require__(308),
	    nativeKeysIn = __webpack_require__(319);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeysIn(object) {
	  if (!isObject(object)) {
	    return nativeKeysIn(object);
	  }
	  var isProto = isPrototype(object),
	      result = [];

	  for (var key in object) {
	    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = baseKeysIn;


/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

	var constant = __webpack_require__(331),
	    defineProperty = __webpack_require__(123),
	    identity = __webpack_require__(127);

	/**
	 * The base implementation of `setToString` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetToString = !defineProperty ? identity : function(func, string) {
	  return defineProperty(func, 'toString', {
	    'configurable': true,
	    'enumerable': false,
	    'value': constant(string),
	    'writable': true
	  });
	};

	module.exports = baseSetToString;


/***/ }),
/* 288 */
/***/ (function(module, exports) {

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	module.exports = baseTimes;


/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

	var baseDifference = __webpack_require__(120),
	    baseFlatten = __webpack_require__(121),
	    baseUniq = __webpack_require__(122);

	/**
	 * The base implementation of methods like `_.xor`, without support for
	 * iteratee shorthands, that accepts an array of arrays to inspect.
	 *
	 * @private
	 * @param {Array} arrays The arrays to inspect.
	 * @param {Function} [iteratee] The iteratee invoked per element.
	 * @param {Function} [comparator] The comparator invoked per element.
	 * @returns {Array} Returns the new array of values.
	 */
	function baseXor(arrays, iteratee, comparator) {
	  var length = arrays.length;
	  if (length < 2) {
	    return length ? baseUniq(arrays[0]) : [];
	  }
	  var index = -1,
	      result = Array(length);

	  while (++index < length) {
	    var array = arrays[index],
	        othIndex = -1;

	    while (++othIndex < length) {
	      if (othIndex != index) {
	        result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
	      }
	    }
	  }
	  return baseUniq(baseFlatten(result, 1), iteratee, comparator);
	}

	module.exports = baseXor;


/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

	var isArrayLikeObject = __webpack_require__(45);

	/**
	 * Casts `value` to an empty array if it's not an array like object.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {Array|Object} Returns the cast array-like object.
	 */
	function castArrayLikeObject(value) {
	  return isArrayLikeObject(value) ? value : [];
	}

	module.exports = castArrayLikeObject;


/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

	var assignValue = __webpack_require__(278),
	    baseAssignValue = __webpack_require__(119);

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject(source, props, object, customizer) {
	  var isNew = !object;
	  object || (object = {});

	  var index = -1,
	      length = props.length;

	  while (++index < length) {
	    var key = props[index];

	    var newValue = customizer
	      ? customizer(object[key], source[key], key, object, source)
	      : undefined;

	    if (newValue === undefined) {
	      newValue = source[key];
	    }
	    if (isNew) {
	      baseAssignValue(object, key, newValue);
	    } else {
	      assignValue(object, key, newValue);
	    }
	  }
	  return object;
	}

	module.exports = copyObject;


/***/ }),
/* 292 */
[1652, 27],
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

	var baseRest = __webpack_require__(22),
	    isIterateeCall = __webpack_require__(305);

	/**
	 * Creates a function like `_.assign`.
	 *
	 * @private
	 * @param {Function} assigner The function to assign values.
	 * @returns {Function} Returns the new assigner function.
	 */
	function createAssigner(assigner) {
	  return baseRest(function(object, sources) {
	    var index = -1,
	        length = sources.length,
	        customizer = length > 1 ? sources[length - 1] : undefined,
	        guard = length > 2 ? sources[2] : undefined;

	    customizer = (assigner.length > 3 && typeof customizer == 'function')
	      ? (length--, customizer)
	      : undefined;

	    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	      customizer = length < 3 ? undefined : customizer;
	      length = 1;
	    }
	    object = Object(object);
	    while (++index < length) {
	      var source = sources[index];
	      if (source) {
	        assigner(object, source, index, customizer);
	      }
	    }
	    return object;
	  });
	}

	module.exports = createAssigner;


/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

	var Set = __webpack_require__(274),
	    noop = __webpack_require__(131),
	    setToArray = __webpack_require__(126);

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/**
	 * Creates a set object of `values`.
	 *
	 * @private
	 * @param {Array} values The values to add to the set.
	 * @returns {Object} Returns the new set.
	 */
	var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
	  return new Set(values);
	};

	module.exports = createSet;


/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

	var eq = __webpack_require__(44);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
	 * of source objects to the destination object for all destination properties
	 * that resolve to `undefined`.
	 *
	 * @private
	 * @param {*} objValue The destination value.
	 * @param {*} srcValue The source value.
	 * @param {string} key The key of the property to assign.
	 * @param {Object} object The parent object of `objValue`.
	 * @returns {*} Returns the value to assign.
	 */
	function customDefaultsAssignIn(objValue, srcValue, key, object) {
	  if (objValue === undefined ||
	      (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
	    return srcValue;
	  }
	  return objValue;
	}

	module.exports = customDefaultsAssignIn;


/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

	var overArg = __webpack_require__(322);

	/** Built-in value references. */
	var getPrototype = overArg(Object.getPrototypeOf, Object);

	module.exports = getPrototype;


/***/ }),
/* 297 */
[1672, 68],
/* 298 */
/***/ (function(module, exports) {

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	module.exports = getValue;


/***/ }),
/* 299 */
[1675, 43],
/* 300 */
/***/ (function(module, exports) {

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	module.exports = hashDelete;


/***/ }),
/* 301 */
[1683, 43],
/* 302 */
[1685, 43],
/* 303 */
[1692, 43],
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(68),
	    isArguments = __webpack_require__(128),
	    isArray = __webpack_require__(18);

	/** Built-in value references. */
	var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

	/**
	 * Checks if `value` is a flattenable `arguments` object or array.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
	 */
	function isFlattenable(value) {
	  return isArray(value) || isArguments(value) ||
	    !!(spreadableSymbol && value && value[spreadableSymbol]);
	}

	module.exports = isFlattenable;


/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

	var eq = __webpack_require__(44),
	    isArrayLike = __webpack_require__(74),
	    isIndex = __webpack_require__(125),
	    isObject = __webpack_require__(28);

	/**
	 * Checks if the given arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	 *  else `false`.
	 */
	function isIterateeCall(value, index, object) {
	  if (!isObject(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	        ? (isArrayLike(object) && isIndex(index, object.length))
	        : (type == 'string' && index in object)
	      ) {
	    return eq(object[index], value);
	  }
	  return false;
	}

	module.exports = isIterateeCall;


/***/ }),
/* 306 */
/***/ (function(module, exports) {

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	module.exports = isKeyable;


/***/ }),
/* 307 */
[1696, 292],
/* 308 */
/***/ (function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	  return value === proto;
	}

	module.exports = isPrototype;


/***/ }),
/* 309 */
/***/ (function(module, exports) {

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	module.exports = listCacheClear;


/***/ }),
/* 310 */
[1704, 39],
/* 311 */
[1709, 39],
/* 312 */
[1712, 39],
/* 313 */
[1719, 39],
/* 314 */
[1722, 271, 272, 273],
/* 315 */
[1729, 41],
/* 316 */
[1730, 41],
/* 317 */
[1739, 41],
/* 318 */
[1741, 41],
/* 319 */
/***/ (function(module, exports) {

	/**
	 * This function is like
	 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * except that it includes inherited enumerable properties.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function nativeKeysIn(object) {
	  var result = [];
	  if (object != null) {
	    for (var key in Object(object)) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = nativeKeysIn;


/***/ }),
/* 320 */
[1750, 124],
/* 321 */
/***/ (function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}

	module.exports = objectToString;


/***/ }),
/* 322 */
/***/ (function(module, exports) {

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	module.exports = overArg;


/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

	var apply = __webpack_require__(118);

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */
	function overRest(func, start, transform) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);

	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = transform(array);
	    return apply(func, this, otherArgs);
	  };
	}

	module.exports = overRest;


/***/ }),
/* 324 */
/***/ (function(module, exports) {

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}

	module.exports = setCacheAdd;


/***/ }),
/* 325 */
/***/ (function(module, exports) {

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	module.exports = setCacheHas;


/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

	var baseSetToString = __webpack_require__(287),
	    shortOut = __webpack_require__(327);

	/**
	 * Sets the `toString` method of `func` to return `string`.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var setToString = shortOut(baseSetToString);

	module.exports = setToString;


/***/ }),
/* 327 */
/***/ (function(module, exports) {

	/** Used to detect hot functions by number of calls within a span of milliseconds. */
	var HOT_COUNT = 800,
	    HOT_SPAN = 16;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeNow = Date.now;

	/**
	 * Creates a function that'll short out and invoke `identity` instead
	 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	 * milliseconds.
	 *
	 * @private
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new shortable function.
	 */
	function shortOut(func) {
	  var count = 0,
	      lastCalled = 0;

	  return function() {
	    var stamp = nativeNow(),
	        remaining = HOT_SPAN - (stamp - lastCalled);

	    lastCalled = stamp;
	    if (remaining > 0) {
	      if (++count >= HOT_COUNT) {
	        return arguments[0];
	      }
	    } else {
	      count = 0;
	    }
	    return func.apply(undefined, arguments);
	  };
	}

	module.exports = shortOut;


/***/ }),
/* 328 */
/***/ (function(module, exports) {

	/**
	 * A specialized version of `_.indexOf` which performs strict equality
	 * comparisons of values, i.e. `===`.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function strictIndexOf(array, value, fromIndex) {
	  var index = fromIndex - 1,
	      length = array.length;

	  while (++index < length) {
	    if (array[index] === value) {
	      return index;
	    }
	  }
	  return -1;
	}

	module.exports = strictIndexOf;


/***/ }),
/* 329 */
161,
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

	var copyObject = __webpack_require__(291),
	    createAssigner = __webpack_require__(293),
	    keysIn = __webpack_require__(336);

	/**
	 * This method is like `_.assignIn` except that it accepts `customizer`
	 * which is invoked to produce the assigned values. If `customizer` returns
	 * `undefined`, assignment is handled by the method instead. The `customizer`
	 * is invoked with five arguments: (objValue, srcValue, key, object, source).
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @alias extendWith
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} sources The source objects.
	 * @param {Function} [customizer] The function to customize assigned values.
	 * @returns {Object} Returns `object`.
	 * @see _.assignWith
	 * @example
	 *
	 * function customizer(objValue, srcValue) {
	 *   return _.isUndefined(objValue) ? srcValue : objValue;
	 * }
	 *
	 * var defaults = _.partialRight(_.assignInWith, customizer);
	 *
	 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	 * // => { 'a': 1, 'b': 2 }
	 */
	var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
	  copyObject(source, keysIn(source), object, customizer);
	});

	module.exports = assignInWith;


/***/ }),
/* 331 */
/***/ (function(module, exports) {

	/**
	 * Creates a function that returns `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {*} value The value to return from the new function.
	 * @returns {Function} Returns the new constant function.
	 * @example
	 *
	 * var objects = _.times(2, _.constant({ 'a': 1 }));
	 *
	 * console.log(objects);
	 * // => [{ 'a': 1 }, { 'a': 1 }]
	 *
	 * console.log(objects[0] === objects[1]);
	 * // => true
	 */
	function constant(value) {
	  return function() {
	    return value;
	  };
	}

	module.exports = constant;


/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

	var apply = __webpack_require__(118),
	    assignInWith = __webpack_require__(330),
	    baseRest = __webpack_require__(22),
	    customDefaultsAssignIn = __webpack_require__(295);

	/**
	 * Assigns own and inherited enumerable string keyed properties of source
	 * objects to the destination object for all destination properties that
	 * resolve to `undefined`. Source objects are applied from left to right.
	 * Once a property is set, additional values of the same property are ignored.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @see _.defaultsDeep
	 * @example
	 *
	 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	 * // => { 'a': 1, 'b': 2 }
	 */
	var defaults = baseRest(function(args) {
	  args.push(undefined, customDefaultsAssignIn);
	  return apply(assignInWith, undefined, args);
	});

	module.exports = defaults;


/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

	var arrayMap = __webpack_require__(71),
	    baseIntersection = __webpack_require__(281),
	    baseRest = __webpack_require__(22),
	    castArrayLikeObject = __webpack_require__(290);

	/**
	 * Creates an array of unique values that are included in all given arrays
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons. The order and references of result values are
	 * determined by the first array.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {...Array} [arrays] The arrays to inspect.
	 * @returns {Array} Returns the new array of intersecting values.
	 * @example
	 *
	 * _.intersection([2, 1], [2, 3]);
	 * // => [2]
	 */
	var intersection = baseRest(function(arrays) {
	  var mapped = arrayMap(arrays, castArrayLikeObject);
	  return (mapped.length && mapped[0] === arrays[0])
	    ? baseIntersection(mapped)
	    : [];
	});

	module.exports = intersection;


/***/ }),
/* 334 */
[1773, 27, 338],
/* 335 */
[1782, 285, 72, 320],
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

	var arrayLikeKeys = __webpack_require__(276),
	    baseKeysIn = __webpack_require__(286),
	    isArrayLike = __webpack_require__(74);

	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	}

	module.exports = keysIn;


/***/ }),
/* 337 */
[1785, 117],
/* 338 */
/***/ (function(module, exports) {

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}

	module.exports = stubFalse;


/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

	var baseFlatten = __webpack_require__(121),
	    baseRest = __webpack_require__(22),
	    baseUniq = __webpack_require__(122),
	    isArrayLikeObject = __webpack_require__(45);

	/**
	 * Creates an array of unique values, in order, from all given arrays using
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {...Array} [arrays] The arrays to inspect.
	 * @returns {Array} Returns the new array of combined values.
	 * @example
	 *
	 * _.union([2], [1, 2]);
	 * // => [2, 1]
	 */
	var union = baseRest(function(arrays) {
	  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
	});

	module.exports = union;


/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

	var arrayFilter = __webpack_require__(275),
	    baseRest = __webpack_require__(22),
	    baseXor = __webpack_require__(289),
	    isArrayLikeObject = __webpack_require__(45);

	/**
	 * Creates an array of unique values that is the
	 * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
	 * of the given arrays. The order of result values is determined by the order
	 * they occur in the arrays.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Array
	 * @param {...Array} [arrays] The arrays to inspect.
	 * @returns {Array} Returns the new array of filtered values.
	 * @see _.difference, _.without
	 * @example
	 *
	 * _.xor([2, 1], [2, 3]);
	 * // => [1, 3]
	 */
	var xor = baseRest(function(arrays) {
	  return baseXor(arrayFilter(arrays, isArrayLikeObject));
	});

	module.exports = xor;


/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _classnames = __webpack_require__(46);

	var _classnames2 = _interopRequireDefault(_classnames);

	var _objectAssign = __webpack_require__(30);

	var _objectAssign2 = _interopRequireDefault(_objectAssign);

	var _globalEventListener = __webpack_require__(76);

	var _globalEventListener2 = _interopRequireDefault(_globalEventListener);

	var _AbstractMenu2 = __webpack_require__(133);

	var _AbstractMenu3 = _interopRequireDefault(_AbstractMenu2);

	var _SubMenu = __webpack_require__(136);

	var _SubMenu2 = _interopRequireDefault(_SubMenu);

	var _actions = __webpack_require__(23);

	var _helpers = __webpack_require__(24);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var ContextMenu = function (_AbstractMenu) {
	    _inherits(ContextMenu, _AbstractMenu);

	    function ContextMenu(props) {
	        _classCallCheck(this, ContextMenu);

	        var _this = _possibleConstructorReturn(this, (ContextMenu.__proto__ || Object.getPrototypeOf(ContextMenu)).call(this, props));

	        _this.registerHandlers = function () {
	            document.addEventListener('mousedown', _this.handleOutsideClick);
	            document.addEventListener('ontouchstart', _this.handleOutsideClick);
	            document.addEventListener('scroll', _this.handleHide);
	            document.addEventListener('contextmenu', _this.handleHide);
	            document.addEventListener('keydown', _this.handleKeyNavigation);
	            window.addEventListener('resize', _this.handleHide);
	        };

	        _this.unregisterHandlers = function () {
	            document.removeEventListener('mousedown', _this.handleOutsideClick);
	            document.removeEventListener('ontouchstart', _this.handleOutsideClick);
	            document.removeEventListener('scroll', _this.handleHide);
	            document.removeEventListener('contextmenu', _this.handleHide);
	            document.removeEventListener('keydown', _this.handleKeyNavigation);
	            window.removeEventListener('resize', _this.handleHide);
	        };

	        _this.handleShow = function (e) {
	            if (e.detail.id !== _this.props.id || _this.state.isVisible) return;

	            var _e$detail$position = e.detail.position,
	                x = _e$detail$position.x,
	                y = _e$detail$position.y;


	            _this.setState({ isVisible: true, x: x, y: y });
	            _this.registerHandlers();
	            (0, _helpers.callIfExists)(_this.props.onShow, e);
	        };

	        _this.handleHide = function (e) {
	            if (_this.state.isVisible && (!e.detail || !e.detail.id || e.detail.id === _this.props.id)) {
	                _this.unregisterHandlers();
	                _this.setState({ isVisible: false, selectedItem: null, forceSubMenuOpen: false });
	                (0, _helpers.callIfExists)(_this.props.onHide, e);
	            }
	        };

	        _this.handleOutsideClick = function (e) {
	            if (!_this.menu.contains(e.target)) (0, _actions.hideMenu)();
	        };

	        _this.handleMouseLeave = function (event) {
	            event.preventDefault();

	            (0, _helpers.callIfExists)(_this.props.onMouseLeave, event, (0, _objectAssign2.default)({}, _this.props.data, _helpers.store.data), _helpers.store.target);

	            if (_this.props.hideOnLeave) (0, _actions.hideMenu)();
	        };

	        _this.handleContextMenu = function (e) {
	            if (true) {
	                e.preventDefault();
	            }
	            _this.handleHide(e);
	        };

	        _this.hideMenu = function (e) {
	            if (e.keyCode === 27 || e.keyCode === 13) {
	                // ECS or enter
	                (0, _actions.hideMenu)();
	            }
	        };

	        _this.getMenuPosition = function () {
	            var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	            var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	            var menuStyles = {
	                top: y,
	                left: x
	            };

	            if (!_this.menu) return menuStyles;

	            var _window = window,
	                innerWidth = _window.innerWidth,
	                innerHeight = _window.innerHeight;

	            var rect = _this.menu.getBoundingClientRect();

	            if (y + rect.height > innerHeight) {
	                menuStyles.top -= rect.height;
	            }

	            if (x + rect.width > innerWidth) {
	                menuStyles.left -= rect.width;
	            }

	            if (menuStyles.top < 0) {
	                menuStyles.top = rect.height < innerHeight ? (innerHeight - rect.height) / 2 : 0;
	            }

	            if (menuStyles.left < 0) {
	                menuStyles.left = rect.width < innerWidth ? (innerWidth - rect.width) / 2 : 0;
	            }

	            return menuStyles;
	        };

	        _this.menuRef = function (c) {
	            _this.menu = c;
	        };

	        _this.state = (0, _objectAssign2.default)({}, _this.state, {
	            x: 0,
	            y: 0,
	            isVisible: false
	        });
	        return _this;
	    }

	    _createClass(ContextMenu, [{
	        key: 'getSubMenuType',
	        value: function getSubMenuType() {
	            // eslint-disable-line class-methods-use-this
	            return _SubMenu2.default;
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            this.listenId = _globalEventListener2.default.register(this.handleShow, this.handleHide);
	        }
	    }, {
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate() {
	            var _this2 = this;

	            if (this.state.isVisible) {
	                var wrapper = window.requestAnimationFrame || setTimeout;

	                wrapper(function () {
	                    var _state = _this2.state,
	                        x = _state.x,
	                        y = _state.y;

	                    var _getMenuPosition = _this2.getMenuPosition(x, y),
	                        top = _getMenuPosition.top,
	                        left = _getMenuPosition.left;

	                    wrapper(function () {
	                        if (!_this2.menu) return;
	                        _this2.menu.style.top = top + 'px';
	                        _this2.menu.style.left = left + 'px';
	                        _this2.menu.style.opacity = 1;
	                        _this2.menu.style.pointerEvents = 'auto';
	                    });
	                });
	            } else {
	                if (!this.menu) return;
	                this.menu.style.opacity = 0;
	                this.menu.style.pointerEvents = 'none';
	            }
	        }
	    }, {
	        key: 'componentWillUnmount',
	        value: function componentWillUnmount() {
	            if (this.listenId) {
	                _globalEventListener2.default.unregister(this.listenId);
	            }

	            this.unregisterHandlers();
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _props = this.props,
	                children = _props.children,
	                className = _props.className,
	                style = _props.style;
	            var isVisible = this.state.isVisible;

	            var inlineStyle = (0, _objectAssign2.default)({}, style, { position: 'fixed', opacity: 0, pointerEvents: 'none' });
	            var menuClassnames = (0, _classnames2.default)(_helpers.cssClasses.menu, className, _defineProperty({}, _helpers.cssClasses.menuVisible, isVisible));

	            return _react2.default.createElement(
	                'nav',
	                {
	                    role: 'menu', tabIndex: '-1', ref: this.menuRef, style: inlineStyle, className: menuClassnames,
	                    onContextMenu: this.handleContextMenu, onMouseLeave: this.handleMouseLeave },
	                this.renderChildren(children)
	            );
	        }
	    }]);

	    return ContextMenu;
	}(_AbstractMenu3.default);

	ContextMenu.propTypes = {
	    id: _propTypes2.default.string.isRequired,
	    children: _propTypes2.default.node.isRequired,
	    data: _propTypes2.default.object,
	    className: _propTypes2.default.string,
	    hideOnLeave: _propTypes2.default.bool,
	    onHide: _propTypes2.default.func,
	    onMouseLeave: _propTypes2.default.func,
	    onShow: _propTypes2.default.func,
	    style: _propTypes2.default.object
	};
	ContextMenu.defaultProps = {
	    className: '',
	    data: {},
	    hideOnLeave: false,
	    onHide: function onHide() {
	        return null;
	    },
	    onMouseLeave: function onMouseLeave() {
	        return null;
	    },
	    onShow: function onShow() {
	        return null;
	    },

	    style: {}
	};
	exports.default = ContextMenu;

/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	exports.default = function (menuId) {
	    // expect menu component to connect as inner parameter
	    // <Child/> is presumably a wrapper of <ContextMenu/>
	    return function (Child) {
	        // return wrapper for <Child/> that forwards the ContextMenuTrigger's additional props
	        return function (_Component) {
	            _inherits(ConnectMenu, _Component);

	            function ConnectMenu(props) {
	                _classCallCheck(this, ConnectMenu);

	                var _this = _possibleConstructorReturn(this, (ConnectMenu.__proto__ || Object.getPrototypeOf(ConnectMenu)).call(this, props));

	                _this.handleShow = function (e) {
	                    if (e.detail.id !== menuId) return;

	                    // the onShow event's detail.data object holds all ContextMenuTrigger props
	                    var data = e.detail.data;

	                    var filteredData = {};

	                    for (var key in data) {
	                        // exclude props the ContextMenuTrigger is expecting itself
	                        if (!ignoredTriggerProps.includes(key)) {
	                            filteredData[key] = data[key];
	                        }
	                    }
	                    _this.setState({ trigger: filteredData });
	                };

	                _this.handleHide = function () {
	                    _this.setState({ trigger: null });
	                };

	                _this.state = { trigger: null };
	                return _this;
	            }

	            _createClass(ConnectMenu, [{
	                key: 'componentDidMount',
	                value: function componentDidMount() {
	                    this.listenId = _globalEventListener2.default.register(this.handleShow, this.handleHide);
	                }
	            }, {
	                key: 'componentWillUnmount',
	                value: function componentWillUnmount() {
	                    if (this.listenId) {
	                        _globalEventListener2.default.unregister(this.listenId);
	                    }
	                }
	            }, {
	                key: 'render',
	                value: function render() {
	                    return _react2.default.createElement(Child, _extends({}, this.props, { id: menuId, trigger: this.state.trigger }));
	                }
	            }]);

	            return ConnectMenu;
	        }(_react.Component);
	    };
	};

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _ContextMenuTrigger = __webpack_require__(134);

	var _ContextMenuTrigger2 = _interopRequireDefault(_ContextMenuTrigger);

	var _globalEventListener = __webpack_require__(76);

	var _globalEventListener2 = _interopRequireDefault(_globalEventListener);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	// collect ContextMenuTrigger's expected props to NOT pass them on as part of the context
	var ignoredTriggerProps = [].concat(_toConsumableArray(Object.keys(_ContextMenuTrigger2.default.propTypes)), ['children']);

	// expect the id of the menu to be responsible for as outer parameter

/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _ContextMenu = __webpack_require__(341);

	Object.defineProperty(exports, 'ContextMenu', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_ContextMenu).default;
	  }
	});

	var _ContextMenuTrigger = __webpack_require__(134);

	Object.defineProperty(exports, 'ContextMenuTrigger', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_ContextMenuTrigger).default;
	  }
	});

	var _MenuItem = __webpack_require__(135);

	Object.defineProperty(exports, 'MenuItem', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_MenuItem).default;
	  }
	});

	var _SubMenu = __webpack_require__(136);

	Object.defineProperty(exports, 'SubMenu', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_SubMenu).default;
	  }
	});

	var _connectMenu = __webpack_require__(342);

	Object.defineProperty(exports, 'connectMenu', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_connectMenu).default;
	  }
	});

	var _actions = __webpack_require__(23);

	Object.defineProperty(exports, 'hideMenu', {
	  enumerable: true,
	  get: function get() {
	    return _actions.hideMenu;
	  }
	});
	Object.defineProperty(exports, 'showMenu', {
	  enumerable: true,
	  get: function get() {
	    return _actions.showMenu;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 344 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _union = __webpack_require__(339);

	var _union2 = _interopRequireDefault(_union);

	var _without = __webpack_require__(132);

	var _without2 = _interopRequireDefault(_without);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var EnterLeaveCounter = function () {
		function EnterLeaveCounter() {
			_classCallCheck(this, EnterLeaveCounter);

			this.entered = [];
		}

		_createClass(EnterLeaveCounter, [{
			key: 'enter',
			value: function enter(enteringNode) {
				var previousLength = this.entered.length;

				var isNodeEntered = function isNodeEntered(node) {
					return document.documentElement.contains(node) && (!node.contains || node.contains(enteringNode));
				};

				this.entered = (0, _union2.default)(this.entered.filter(isNodeEntered), [enteringNode]);

				return previousLength === 0 && this.entered.length > 0;
			}
		}, {
			key: 'leave',
			value: function leave(leavingNode) {
				var previousLength = this.entered.length;

				this.entered = (0, _without2.default)(this.entered.filter(function (node) {
					return document.documentElement.contains(node);
				}), leavingNode);

				return previousLength > 0 && this.entered.length === 0;
			}
		}, {
			key: 'reset',
			value: function reset() {
				this.entered = [];
			}
		}]);

		return EnterLeaveCounter;
	}();

	exports.default = EnterLeaveCounter;

/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint-disable no-underscore-dangle */


	var _defaults = __webpack_require__(332);

	var _defaults2 = _interopRequireDefault(_defaults);

	var _shallowEqual = __webpack_require__(350);

	var _shallowEqual2 = _interopRequireDefault(_shallowEqual);

	var _EnterLeaveCounter = __webpack_require__(344);

	var _EnterLeaveCounter2 = _interopRequireDefault(_EnterLeaveCounter);

	var _BrowserDetector = __webpack_require__(137);

	var _OffsetUtils = __webpack_require__(348);

	var _NativeDragSources = __webpack_require__(347);

	var _NativeTypes = __webpack_require__(77);

	var NativeTypes = _interopRequireWildcard(_NativeTypes);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var HTML5Backend = function () {
		function HTML5Backend(manager) {
			_classCallCheck(this, HTML5Backend);

			this.actions = manager.getActions();
			this.monitor = manager.getMonitor();
			this.registry = manager.getRegistry();
			this.context = manager.getContext();

			this.sourcePreviewNodes = {};
			this.sourcePreviewNodeOptions = {};
			this.sourceNodes = {};
			this.sourceNodeOptions = {};
			this.enterLeaveCounter = new _EnterLeaveCounter2.default();

			this.dragStartSourceIds = [];
			this.dropTargetIds = [];
			this.dragEnterTargetIds = [];
			this.currentNativeSource = null;
			this.currentNativeHandle = null;
			this.currentDragSourceNode = null;
			this.currentDragSourceNodeOffset = null;
			this.currentDragSourceNodeOffsetChanged = false;
			this.altKeyPressed = false;

			this.getSourceClientOffset = this.getSourceClientOffset.bind(this);
			this.handleTopDragStart = this.handleTopDragStart.bind(this);
			this.handleTopDragStartCapture = this.handleTopDragStartCapture.bind(this);
			this.handleTopDragEndCapture = this.handleTopDragEndCapture.bind(this);
			this.handleTopDragEnter = this.handleTopDragEnter.bind(this);
			this.handleTopDragEnterCapture = this.handleTopDragEnterCapture.bind(this);
			this.handleTopDragLeaveCapture = this.handleTopDragLeaveCapture.bind(this);
			this.handleTopDragOver = this.handleTopDragOver.bind(this);
			this.handleTopDragOverCapture = this.handleTopDragOverCapture.bind(this);
			this.handleTopDrop = this.handleTopDrop.bind(this);
			this.handleTopDropCapture = this.handleTopDropCapture.bind(this);
			this.handleSelectStart = this.handleSelectStart.bind(this);
			this.endDragIfSourceWasRemovedFromDOM = this.endDragIfSourceWasRemovedFromDOM.bind(this);
			this.endDragNativeItem = this.endDragNativeItem.bind(this);
			this.asyncEndDragNativeItem = this.asyncEndDragNativeItem.bind(this);
			this.isNodeInDocument = this.isNodeInDocument.bind(this);
		}

		_createClass(HTML5Backend, [{
			key: 'setup',
			value: function setup() {
				if (this.window === undefined) {
					return;
				}

				if (this.window.__isReactDndBackendSetUp) {
					throw new Error('Cannot have two HTML5 backends at the same time.');
				}
				this.window.__isReactDndBackendSetUp = true;
				this.addEventListeners(this.window);
			}
		}, {
			key: 'teardown',
			value: function teardown() {
				if (this.window === undefined) {
					return;
				}

				this.window.__isReactDndBackendSetUp = false;
				this.removeEventListeners(this.window);
				this.clearCurrentDragSourceNode();
				if (this.asyncEndDragFrameId) {
					this.window.cancelAnimationFrame(this.asyncEndDragFrameId);
				}
			}
		}, {
			key: 'addEventListeners',
			value: function addEventListeners(target) {
				// SSR Fix (https://github.com/react-dnd/react-dnd/pull/813
				if (!target.addEventListener) {
					return;
				}
				target.addEventListener('dragstart', this.handleTopDragStart);
				target.addEventListener('dragstart', this.handleTopDragStartCapture, true);
				target.addEventListener('dragend', this.handleTopDragEndCapture, true);
				target.addEventListener('dragenter', this.handleTopDragEnter);
				target.addEventListener('dragenter', this.handleTopDragEnterCapture, true);
				target.addEventListener('dragleave', this.handleTopDragLeaveCapture, true);
				target.addEventListener('dragover', this.handleTopDragOver);
				target.addEventListener('dragover', this.handleTopDragOverCapture, true);
				target.addEventListener('drop', this.handleTopDrop);
				target.addEventListener('drop', this.handleTopDropCapture, true);
			}
		}, {
			key: 'removeEventListeners',
			value: function removeEventListeners(target) {
				// SSR Fix (https://github.com/react-dnd/react-dnd/pull/813
				if (!target.removeEventListener) {
					return;
				}
				target.removeEventListener('dragstart', this.handleTopDragStart);
				target.removeEventListener('dragstart', this.handleTopDragStartCapture, true);
				target.removeEventListener('dragend', this.handleTopDragEndCapture, true);
				target.removeEventListener('dragenter', this.handleTopDragEnter);
				target.removeEventListener('dragenter', this.handleTopDragEnterCapture, true);
				target.removeEventListener('dragleave', this.handleTopDragLeaveCapture, true);
				target.removeEventListener('dragover', this.handleTopDragOver);
				target.removeEventListener('dragover', this.handleTopDragOverCapture, true);
				target.removeEventListener('drop', this.handleTopDrop);
				target.removeEventListener('drop', this.handleTopDropCapture, true);
			}
		}, {
			key: 'connectDragPreview',
			value: function connectDragPreview(sourceId, node, options) {
				var _this = this;

				this.sourcePreviewNodeOptions[sourceId] = options;
				this.sourcePreviewNodes[sourceId] = node;

				return function () {
					delete _this.sourcePreviewNodes[sourceId];
					delete _this.sourcePreviewNodeOptions[sourceId];
				};
			}
		}, {
			key: 'connectDragSource',
			value: function connectDragSource(sourceId, node, options) {
				var _this2 = this;

				this.sourceNodes[sourceId] = node;
				this.sourceNodeOptions[sourceId] = options;

				var handleDragStart = function handleDragStart(e) {
					return _this2.handleDragStart(e, sourceId);
				};
				var handleSelectStart = function handleSelectStart(e) {
					return _this2.handleSelectStart(e, sourceId);
				};

				node.setAttribute('draggable', true);
				node.addEventListener('dragstart', handleDragStart);
				node.addEventListener('selectstart', handleSelectStart);

				return function () {
					delete _this2.sourceNodes[sourceId];
					delete _this2.sourceNodeOptions[sourceId];

					node.removeEventListener('dragstart', handleDragStart);
					node.removeEventListener('selectstart', handleSelectStart);
					node.setAttribute('draggable', false);
				};
			}
		}, {
			key: 'connectDropTarget',
			value: function connectDropTarget(targetId, node) {
				var _this3 = this;

				var handleDragEnter = function handleDragEnter(e) {
					return _this3.handleDragEnter(e, targetId);
				};
				var handleDragOver = function handleDragOver(e) {
					return _this3.handleDragOver(e, targetId);
				};
				var handleDrop = function handleDrop(e) {
					return _this3.handleDrop(e, targetId);
				};

				node.addEventListener('dragenter', handleDragEnter);
				node.addEventListener('dragover', handleDragOver);
				node.addEventListener('drop', handleDrop);

				return function () {
					node.removeEventListener('dragenter', handleDragEnter);
					node.removeEventListener('dragover', handleDragOver);
					node.removeEventListener('drop', handleDrop);
				};
			}
		}, {
			key: 'getCurrentSourceNodeOptions',
			value: function getCurrentSourceNodeOptions() {
				var sourceId = this.monitor.getSourceId();
				var sourceNodeOptions = this.sourceNodeOptions[sourceId];

				return (0, _defaults2.default)(sourceNodeOptions || {}, {
					dropEffect: this.altKeyPressed ? 'copy' : 'move'
				});
			}
		}, {
			key: 'getCurrentDropEffect',
			value: function getCurrentDropEffect() {
				if (this.isDraggingNativeItem()) {
					// It makes more sense to default to 'copy' for native resources
					return 'copy';
				}

				return this.getCurrentSourceNodeOptions().dropEffect;
			}
		}, {
			key: 'getCurrentSourcePreviewNodeOptions',
			value: function getCurrentSourcePreviewNodeOptions() {
				var sourceId = this.monitor.getSourceId();
				var sourcePreviewNodeOptions = this.sourcePreviewNodeOptions[sourceId];

				return (0, _defaults2.default)(sourcePreviewNodeOptions || {}, {
					anchorX: 0.5,
					anchorY: 0.5,
					captureDraggingState: false
				});
			}
		}, {
			key: 'getSourceClientOffset',
			value: function getSourceClientOffset(sourceId) {
				return (0, _OffsetUtils.getNodeClientOffset)(this.sourceNodes[sourceId]);
			}
		}, {
			key: 'isDraggingNativeItem',
			value: function isDraggingNativeItem() {
				var itemType = this.monitor.getItemType();
				return Object.keys(NativeTypes).some(function (key) {
					return NativeTypes[key] === itemType;
				});
			}
		}, {
			key: 'beginDragNativeItem',
			value: function beginDragNativeItem(type) {
				this.clearCurrentDragSourceNode();

				var SourceType = (0, _NativeDragSources.createNativeDragSource)(type);
				this.currentNativeSource = new SourceType();
				this.currentNativeHandle = this.registry.addSource(type, this.currentNativeSource);
				this.actions.beginDrag([this.currentNativeHandle]);

				// On Firefox, if mouseover fires, the drag is over but browser failed to tell us.
				// See https://bugzilla.mozilla.org/show_bug.cgi?id=656164
				// This is not true for other browsers.
				if ((0, _BrowserDetector.isFirefox)()) {
					this.window.addEventListener('mouseover', this.asyncEndDragNativeItem, true);
				}
			}
		}, {
			key: 'asyncEndDragNativeItem',
			value: function asyncEndDragNativeItem() {
				this.asyncEndDragFrameId = this.window.requestAnimationFrame(this.endDragNativeItem);
				if ((0, _BrowserDetector.isFirefox)()) {
					this.window.removeEventListener('mouseover', this.asyncEndDragNativeItem, true);
					this.enterLeaveCounter.reset();
				}
			}
		}, {
			key: 'endDragNativeItem',
			value: function endDragNativeItem() {
				if (!this.isDraggingNativeItem()) {
					return;
				}

				this.actions.endDrag();
				this.registry.removeSource(this.currentNativeHandle);
				this.currentNativeHandle = null;
				this.currentNativeSource = null;
			}
		}, {
			key: 'isNodeInDocument',
			value: function isNodeInDocument(node) {
				// Check the node either in the main document or in the current context
				return document.body.contains(node) || this.window ? this.window.document.body.contains(node) : false;
			}
		}, {
			key: 'endDragIfSourceWasRemovedFromDOM',
			value: function endDragIfSourceWasRemovedFromDOM() {
				var node = this.currentDragSourceNode;
				if (this.isNodeInDocument(node)) {
					return;
				}

				if (this.clearCurrentDragSourceNode()) {
					this.actions.endDrag();
				}
			}
		}, {
			key: 'setCurrentDragSourceNode',
			value: function setCurrentDragSourceNode(node) {
				this.clearCurrentDragSourceNode();
				this.currentDragSourceNode = node;
				this.currentDragSourceNodeOffset = (0, _OffsetUtils.getNodeClientOffset)(node);
				this.currentDragSourceNodeOffsetChanged = false;

				// Receiving a mouse event in the middle of a dragging operation
				// means it has ended and the drag source node disappeared from DOM,
				// so the browser didn't dispatch the dragend event.
				this.window.addEventListener('mousemove', this.endDragIfSourceWasRemovedFromDOM, true);
			}
		}, {
			key: 'clearCurrentDragSourceNode',
			value: function clearCurrentDragSourceNode() {
				if (this.currentDragSourceNode) {
					this.currentDragSourceNode = null;
					this.currentDragSourceNodeOffset = null;
					this.currentDragSourceNodeOffsetChanged = false;
					this.window.removeEventListener('mousemove', this.endDragIfSourceWasRemovedFromDOM, true);
					return true;
				}

				return false;
			}
		}, {
			key: 'checkIfCurrentDragSourceRectChanged',
			value: function checkIfCurrentDragSourceRectChanged() {
				var node = this.currentDragSourceNode;
				if (!node) {
					return false;
				}

				if (this.currentDragSourceNodeOffsetChanged) {
					return true;
				}

				this.currentDragSourceNodeOffsetChanged = !(0, _shallowEqual2.default)((0, _OffsetUtils.getNodeClientOffset)(node), this.currentDragSourceNodeOffset);

				return this.currentDragSourceNodeOffsetChanged;
			}
		}, {
			key: 'handleTopDragStartCapture',
			value: function handleTopDragStartCapture() {
				this.clearCurrentDragSourceNode();
				this.dragStartSourceIds = [];
			}
		}, {
			key: 'handleDragStart',
			value: function handleDragStart(e, sourceId) {
				this.dragStartSourceIds.unshift(sourceId);
			}
		}, {
			key: 'handleTopDragStart',
			value: function handleTopDragStart(e) {
				var _this4 = this;

				var dragStartSourceIds = this.dragStartSourceIds;

				this.dragStartSourceIds = null;

				var clientOffset = (0, _OffsetUtils.getEventClientOffset)(e);

				// Avoid crashing if we missed a drop event or our previous drag died
				if (this.monitor.isDragging()) {
					this.actions.endDrag();
				}

				// Don't publish the source just yet (see why below)
				this.actions.beginDrag(dragStartSourceIds, {
					publishSource: false,
					getSourceClientOffset: this.getSourceClientOffset,
					clientOffset: clientOffset
				});

				var dataTransfer = e.dataTransfer;

				var nativeType = (0, _NativeDragSources.matchNativeItemType)(dataTransfer);

				if (this.monitor.isDragging()) {
					if (typeof dataTransfer.setDragImage === 'function') {
						// Use custom drag image if user specifies it.
						// If child drag source refuses drag but parent agrees,
						// use parent's node as drag image. Neither works in IE though.
						var sourceId = this.monitor.getSourceId();
						var sourceNode = this.sourceNodes[sourceId];
						var dragPreview = this.sourcePreviewNodes[sourceId] || sourceNode;

						var _getCurrentSourcePrev = this.getCurrentSourcePreviewNodeOptions(),
						    anchorX = _getCurrentSourcePrev.anchorX,
						    anchorY = _getCurrentSourcePrev.anchorY,
						    offsetX = _getCurrentSourcePrev.offsetX,
						    offsetY = _getCurrentSourcePrev.offsetY;

						var anchorPoint = { anchorX: anchorX, anchorY: anchorY };
						var offsetPoint = { offsetX: offsetX, offsetY: offsetY };
						var dragPreviewOffset = (0, _OffsetUtils.getDragPreviewOffset)(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint);

						dataTransfer.setDragImage(dragPreview, dragPreviewOffset.x, dragPreviewOffset.y);
					}

					try {
						// Firefox won't drag without setting data
						dataTransfer.setData('application/json', {});
					} catch (err) {}
					// IE doesn't support MIME types in setData


					// Store drag source node so we can check whether
					// it is removed from DOM and trigger endDrag manually.
					this.setCurrentDragSourceNode(e.target);

					// Now we are ready to publish the drag source.. or are we not?

					var _getCurrentSourcePrev2 = this.getCurrentSourcePreviewNodeOptions(),
					    captureDraggingState = _getCurrentSourcePrev2.captureDraggingState;

					if (!captureDraggingState) {
						// Usually we want to publish it in the next tick so that browser
						// is able to screenshot the current (not yet dragging) state.
						//
						// It also neatly avoids a situation where render() returns null
						// in the same tick for the source element, and browser freaks out.
						setTimeout(function () {
							return _this4.actions.publishDragSource();
						});
					} else {
						// In some cases the user may want to override this behavior, e.g.
						// to work around IE not supporting custom drag previews.
						//
						// When using a custom drag layer, the only way to prevent
						// the default drag preview from drawing in IE is to screenshot
						// the dragging state in which the node itself has zero opacity
						// and height. In this case, though, returning null from render()
						// will abruptly end the dragging, which is not obvious.
						//
						// This is the reason such behavior is strictly opt-in.
						this.actions.publishDragSource();
					}
				} else if (nativeType) {
					// A native item (such as URL) dragged from inside the document
					this.beginDragNativeItem(nativeType);
				} else if (!dataTransfer.types && (!e.target.hasAttribute || !e.target.hasAttribute('draggable'))) {
					// Looks like a Safari bug: dataTransfer.types is null, but there was no draggable.
					// Just let it drag. It's a native type (URL or text) and will be picked up in
					// dragenter handler.
					return; // eslint-disable-line no-useless-return
				} else {
					// If by this time no drag source reacted, tell browser not to drag.
					e.preventDefault();
				}
			}
		}, {
			key: 'handleTopDragEndCapture',
			value: function handleTopDragEndCapture() {
				if (this.clearCurrentDragSourceNode()) {
					// Firefox can dispatch this event in an infinite loop
					// if dragend handler does something like showing an alert.
					// Only proceed if we have not handled it already.
					this.actions.endDrag();
				}
			}
		}, {
			key: 'handleTopDragEnterCapture',
			value: function handleTopDragEnterCapture(e) {
				this.dragEnterTargetIds = [];

				var isFirstEnter = this.enterLeaveCounter.enter(e.target);
				if (!isFirstEnter || this.monitor.isDragging()) {
					return;
				}

				var dataTransfer = e.dataTransfer;

				var nativeType = (0, _NativeDragSources.matchNativeItemType)(dataTransfer);

				if (nativeType) {
					// A native item (such as file or URL) dragged from outside the document
					this.beginDragNativeItem(nativeType);
				}
			}
		}, {
			key: 'handleDragEnter',
			value: function handleDragEnter(e, targetId) {
				this.dragEnterTargetIds.unshift(targetId);
			}
		}, {
			key: 'handleTopDragEnter',
			value: function handleTopDragEnter(e) {
				var _this5 = this;

				var dragEnterTargetIds = this.dragEnterTargetIds;

				this.dragEnterTargetIds = [];

				if (!this.monitor.isDragging()) {
					// This is probably a native item type we don't understand.
					return;
				}

				this.altKeyPressed = e.altKey;

				if (!(0, _BrowserDetector.isFirefox)()) {
					// Don't emit hover in `dragenter` on Firefox due to an edge case.
					// If the target changes position as the result of `dragenter`, Firefox
					// will still happily dispatch `dragover` despite target being no longer
					// there. The easy solution is to only fire `hover` in `dragover` on FF.
					this.actions.hover(dragEnterTargetIds, {
						clientOffset: (0, _OffsetUtils.getEventClientOffset)(e)
					});
				}

				var canDrop = dragEnterTargetIds.some(function (targetId) {
					return _this5.monitor.canDropOnTarget(targetId);
				});

				if (canDrop) {
					// IE requires this to fire dragover events
					e.preventDefault();
					e.dataTransfer.dropEffect = this.getCurrentDropEffect();
				}
			}
		}, {
			key: 'handleTopDragOverCapture',
			value: function handleTopDragOverCapture() {
				this.dragOverTargetIds = [];
			}
		}, {
			key: 'handleDragOver',
			value: function handleDragOver(e, targetId) {
				this.dragOverTargetIds.unshift(targetId);
			}
		}, {
			key: 'handleTopDragOver',
			value: function handleTopDragOver(e) {
				var _this6 = this;

				var dragOverTargetIds = this.dragOverTargetIds;

				this.dragOverTargetIds = [];

				if (!this.monitor.isDragging()) {
					// This is probably a native item type we don't understand.
					// Prevent default "drop and blow away the whole document" action.
					e.preventDefault();
					e.dataTransfer.dropEffect = 'none';
					return;
				}

				this.altKeyPressed = e.altKey;

				this.actions.hover(dragOverTargetIds, {
					clientOffset: (0, _OffsetUtils.getEventClientOffset)(e)
				});

				var canDrop = dragOverTargetIds.some(function (targetId) {
					return _this6.monitor.canDropOnTarget(targetId);
				});

				if (canDrop) {
					// Show user-specified drop effect.
					e.preventDefault();
					e.dataTransfer.dropEffect = this.getCurrentDropEffect();
				} else if (this.isDraggingNativeItem()) {
					// Don't show a nice cursor but still prevent default
					// "drop and blow away the whole document" action.
					e.preventDefault();
					e.dataTransfer.dropEffect = 'none';
				} else if (this.checkIfCurrentDragSourceRectChanged()) {
					// Prevent animating to incorrect position.
					// Drop effect must be other than 'none' to prevent animation.
					e.preventDefault();
					e.dataTransfer.dropEffect = 'move';
				}
			}
		}, {
			key: 'handleTopDragLeaveCapture',
			value: function handleTopDragLeaveCapture(e) {
				if (this.isDraggingNativeItem()) {
					e.preventDefault();
				}

				var isLastLeave = this.enterLeaveCounter.leave(e.target);
				if (!isLastLeave) {
					return;
				}

				if (this.isDraggingNativeItem()) {
					this.endDragNativeItem();
				}
			}
		}, {
			key: 'handleTopDropCapture',
			value: function handleTopDropCapture(e) {
				this.dropTargetIds = [];
				e.preventDefault();

				if (this.isDraggingNativeItem()) {
					this.currentNativeSource.mutateItemByReadingDataTransfer(e.dataTransfer);
				}

				this.enterLeaveCounter.reset();
			}
		}, {
			key: 'handleDrop',
			value: function handleDrop(e, targetId) {
				this.dropTargetIds.unshift(targetId);
			}
		}, {
			key: 'handleTopDrop',
			value: function handleTopDrop(e) {
				var dropTargetIds = this.dropTargetIds;

				this.dropTargetIds = [];

				this.actions.hover(dropTargetIds, {
					clientOffset: (0, _OffsetUtils.getEventClientOffset)(e)
				});
				this.actions.drop({ dropEffect: this.getCurrentDropEffect() });

				if (this.isDraggingNativeItem()) {
					this.endDragNativeItem();
				} else {
					this.endDragIfSourceWasRemovedFromDOM();
				}
			}
		}, {
			key: 'handleSelectStart',
			value: function handleSelectStart(e) {
				var target = e.target;

				// Only IE requires us to explicitly say
				// we want drag drop operation to start

				if (typeof target.dragDrop !== 'function') {
					return;
				}

				// Inputs and textareas should be selectable
				if (target.tagName === 'INPUT' || target.tagName === 'SELECT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {
					return;
				}

				// For other targets, ask IE
				// to enable drag and drop
				e.preventDefault();
				target.dragDrop();
			}
		}, {
			key: 'window',
			get: function get() {
				if (this.context && this.context.window) {
					return this.context.window;
				} else if (typeof window !== 'undefined') {
					return window;
				}
				return undefined;
			}
		}]);

		return HTML5Backend;
	}();

	exports.default = HTML5Backend;

/***/ }),
/* 346 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/* eslint
	   no-plusplus: off,
	   no-mixed-operators: off
	*/
	var MonotonicInterpolant = function () {
		function MonotonicInterpolant(xs, ys) {
			_classCallCheck(this, MonotonicInterpolant);

			var length = xs.length;

			// Rearrange xs and ys so that xs is sorted
			var indexes = [];
			for (var i = 0; i < length; i++) {
				indexes.push(i);
			}
			indexes.sort(function (a, b) {
				return xs[a] < xs[b] ? -1 : 1;
			});

			// Get consecutive differences and slopes
			var dys = [];
			var dxs = [];
			var ms = [];
			var dx = void 0;
			var dy = void 0;
			for (var _i = 0; _i < length - 1; _i++) {
				dx = xs[_i + 1] - xs[_i];
				dy = ys[_i + 1] - ys[_i];
				dxs.push(dx);
				dys.push(dy);
				ms.push(dy / dx);
			}

			// Get degree-1 coefficients
			var c1s = [ms[0]];
			for (var _i2 = 0; _i2 < dxs.length - 1; _i2++) {
				var _m = ms[_i2];
				var mNext = ms[_i2 + 1];
				if (_m * mNext <= 0) {
					c1s.push(0);
				} else {
					dx = dxs[_i2];
					var dxNext = dxs[_i2 + 1];
					var common = dx + dxNext;
					c1s.push(3 * common / ((common + dxNext) / _m + (common + dx) / mNext));
				}
			}
			c1s.push(ms[ms.length - 1]);

			// Get degree-2 and degree-3 coefficients
			var c2s = [];
			var c3s = [];
			var m = void 0;
			for (var _i3 = 0; _i3 < c1s.length - 1; _i3++) {
				m = ms[_i3];
				var c1 = c1s[_i3];
				var invDx = 1 / dxs[_i3];
				var _common = c1 + c1s[_i3 + 1] - m - m;
				c2s.push((m - c1 - _common) * invDx);
				c3s.push(_common * invDx * invDx);
			}

			this.xs = xs;
			this.ys = ys;
			this.c1s = c1s;
			this.c2s = c2s;
			this.c3s = c3s;
		}

		_createClass(MonotonicInterpolant, [{
			key: "interpolate",
			value: function interpolate(x) {
				var xs = this.xs,
				    ys = this.ys,
				    c1s = this.c1s,
				    c2s = this.c2s,
				    c3s = this.c3s;

				// The rightmost point in the dataset should give an exact result

				var i = xs.length - 1;
				if (x === xs[i]) {
					return ys[i];
				}

				// Search for the interval x is in, returning the corresponding y if x is one of the original xs
				var low = 0;
				var high = c3s.length - 1;
				var mid = void 0;
				while (low <= high) {
					mid = Math.floor(0.5 * (low + high));
					var xHere = xs[mid];
					if (xHere < x) {
						low = mid + 1;
					} else if (xHere > x) {
						high = mid - 1;
					} else {
						return ys[mid];
					}
				}
				i = Math.max(0, high);

				// Interpolate
				var diff = x - xs[i];
				var diffSq = diff * diff;
				return ys[i] + c1s[i] * diff + c2s[i] * diffSq + c3s[i] * diff * diffSq;
			}
		}]);

		return MonotonicInterpolant;
	}();

	exports.default = MonotonicInterpolant;

/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _nativeTypesConfig;

	exports.createNativeDragSource = createNativeDragSource;
	exports.matchNativeItemType = matchNativeItemType;

	var _NativeTypes = __webpack_require__(77);

	var NativeTypes = _interopRequireWildcard(_NativeTypes);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _defineEnumerableProperties(obj, descs) { for (var key in descs) { var desc = descs[key]; desc.configurable = desc.enumerable = true; if ("value" in desc) desc.writable = true; Object.defineProperty(obj, key, desc); } return obj; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function getDataFromDataTransfer(dataTransfer, typesToTry, defaultValue) {
		var result = typesToTry.reduce(function (resultSoFar, typeToTry) {
			return resultSoFar || dataTransfer.getData(typeToTry);
		}, null);

		return result != null // eslint-disable-line eqeqeq
		? result : defaultValue;
	}

	var nativeTypesConfig = (_nativeTypesConfig = {}, _defineProperty(_nativeTypesConfig, NativeTypes.FILE, {
		exposeProperty: 'files',
		matchesTypes: ['Files'],
		getData: function getData(dataTransfer) {
			return Array.prototype.slice.call(dataTransfer.files);
		}
	}), _defineProperty(_nativeTypesConfig, NativeTypes.URL, {
		exposeProperty: 'urls',
		matchesTypes: ['Url', 'text/uri-list'],
		getData: function getData(dataTransfer, matchesTypes) {
			return getDataFromDataTransfer(dataTransfer, matchesTypes, '').split('\n');
		}
	}), _defineProperty(_nativeTypesConfig, NativeTypes.TEXT, {
		exposeProperty: 'text',
		matchesTypes: ['Text', 'text/plain'],
		getData: function getData(dataTransfer, matchesTypes) {
			return getDataFromDataTransfer(dataTransfer, matchesTypes, '');
		}
	}), _nativeTypesConfig);

	function createNativeDragSource(type) {
		var _nativeTypesConfig$ty = nativeTypesConfig[type],
		    exposeProperty = _nativeTypesConfig$ty.exposeProperty,
		    matchesTypes = _nativeTypesConfig$ty.matchesTypes,
		    getData = _nativeTypesConfig$ty.getData;


		return function () {
			function NativeDragSource() {
				var _item, _mutatorMap;

				_classCallCheck(this, NativeDragSource);

				this.item = (_item = {}, _mutatorMap = {}, _mutatorMap[exposeProperty] = _mutatorMap[exposeProperty] || {}, _mutatorMap[exposeProperty].get = function () {
					// eslint-disable-next-line no-console
					console.warn('Browser doesn\'t allow reading "' + exposeProperty + '" until the drop event.');
					return null;
				}, _defineEnumerableProperties(_item, _mutatorMap), _item);
			}

			_createClass(NativeDragSource, [{
				key: 'mutateItemByReadingDataTransfer',
				value: function mutateItemByReadingDataTransfer(dataTransfer) {
					delete this.item[exposeProperty];
					this.item[exposeProperty] = getData(dataTransfer, matchesTypes);
				}
			}, {
				key: 'canDrag',
				value: function canDrag() {
					return true;
				}
			}, {
				key: 'beginDrag',
				value: function beginDrag() {
					return this.item;
				}
			}, {
				key: 'isDragging',
				value: function isDragging(monitor, handle) {
					return handle === monitor.getSourceId();
				}
			}, {
				key: 'endDrag',
				value: function endDrag() {}
			}]);

			return NativeDragSource;
		}();
	}

	function matchNativeItemType(dataTransfer) {
		var dataTransferTypes = Array.prototype.slice.call(dataTransfer.types || []);

		return Object.keys(nativeTypesConfig).filter(function (nativeItemType) {
			var matchesTypes = nativeTypesConfig[nativeItemType].matchesTypes;

			return matchesTypes.some(function (t) {
				return dataTransferTypes.indexOf(t) > -1;
			});
		})[0] || null;
	}

/***/ }),
/* 348 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.getNodeClientOffset = getNodeClientOffset;
	exports.getEventClientOffset = getEventClientOffset;
	exports.getDragPreviewOffset = getDragPreviewOffset;

	var _BrowserDetector = __webpack_require__(137);

	var _MonotonicInterpolant = __webpack_require__(346);

	var _MonotonicInterpolant2 = _interopRequireDefault(_MonotonicInterpolant);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* eslint
	   no-mixed-operators: off
	*/
	var ELEMENT_NODE = 1;

	function getNodeClientOffset(node) {
		var el = node.nodeType === ELEMENT_NODE ? node : node.parentElement;

		if (!el) {
			return null;
		}

		var _el$getBoundingClient = el.getBoundingClientRect(),
		    top = _el$getBoundingClient.top,
		    left = _el$getBoundingClient.left;

		return { x: left, y: top };
	}

	function getEventClientOffset(e) {
		return {
			x: e.clientX,
			y: e.clientY
		};
	}

	function isImageNode(node) {
		return node.nodeName === 'IMG' && ((0, _BrowserDetector.isFirefox)() || !document.documentElement.contains(node));
	}

	function getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight) {
		var dragPreviewWidth = isImage ? dragPreview.width : sourceWidth;
		var dragPreviewHeight = isImage ? dragPreview.height : sourceHeight;

		// Work around @2x coordinate discrepancies in browsers
		if ((0, _BrowserDetector.isSafari)() && isImage) {
			dragPreviewHeight /= window.devicePixelRatio;
			dragPreviewWidth /= window.devicePixelRatio;
		}
		return { dragPreviewWidth: dragPreviewWidth, dragPreviewHeight: dragPreviewHeight };
	}

	function getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint) {
		// The browsers will use the image intrinsic size under different conditions.
		// Firefox only cares if it's an image, but WebKit also wants it to be detached.
		var isImage = isImageNode(dragPreview);
		var dragPreviewNode = isImage ? sourceNode : dragPreview;
		var dragPreviewNodeOffsetFromClient = getNodeClientOffset(dragPreviewNode);
		var offsetFromDragPreview = {
			x: clientOffset.x - dragPreviewNodeOffsetFromClient.x,
			y: clientOffset.y - dragPreviewNodeOffsetFromClient.y
		};
		var sourceWidth = sourceNode.offsetWidth,
		    sourceHeight = sourceNode.offsetHeight;
		var anchorX = anchorPoint.anchorX,
		    anchorY = anchorPoint.anchorY;

		var _getDragPreviewSize = getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight),
		    dragPreviewWidth = _getDragPreviewSize.dragPreviewWidth,
		    dragPreviewHeight = _getDragPreviewSize.dragPreviewHeight;

		var calculateYOffset = function calculateYOffset() {
			var interpolantY = new _MonotonicInterpolant2.default([0, 0.5, 1], [
			// Dock to the top
			offsetFromDragPreview.y,
			// Align at the center
			offsetFromDragPreview.y / sourceHeight * dragPreviewHeight,
			// Dock to the bottom
			offsetFromDragPreview.y + dragPreviewHeight - sourceHeight]);
			var y = interpolantY.interpolate(anchorY);
			// Work around Safari 8 positioning bug
			if ((0, _BrowserDetector.isSafari)() && isImage) {
				// We'll have to wait for @3x to see if this is entirely correct
				y += (window.devicePixelRatio - 1) * dragPreviewHeight;
			}
			return y;
		};

		var calculateXOffset = function calculateXOffset() {
			// Interpolate coordinates depending on anchor point
			// If you know a simpler way to do this, let me know
			var interpolantX = new _MonotonicInterpolant2.default([0, 0.5, 1], [
			// Dock to the left
			offsetFromDragPreview.x,
			// Align at the center
			offsetFromDragPreview.x / sourceWidth * dragPreviewWidth,
			// Dock to the right
			offsetFromDragPreview.x + dragPreviewWidth - sourceWidth]);
			return interpolantX.interpolate(anchorX);
		};

		// Force offsets if specified in the options.
		var offsetX = offsetPoint.offsetX,
		    offsetY = offsetPoint.offsetY;

		var isManualOffsetX = offsetX === 0 || offsetX;
		var isManualOffsetY = offsetY === 0 || offsetY;
		return {
			x: isManualOffsetX ? offsetX : calculateXOffset(),
			y: isManualOffsetY ? offsetY : calculateYOffset()
		};
	}

/***/ }),
/* 349 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = getEmptyImage;
	var emptyImage = void 0;
	function getEmptyImage() {
		if (!emptyImage) {
			emptyImage = new Image();
			emptyImage.src = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';
		}

		return emptyImage;
	}

/***/ }),
/* 350 */
78,
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _class, _temp;

	var _react = __webpack_require__(2);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _DragDropContext = __webpack_require__(139);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * This class is a React-Component based version of the DragDropContext.
	 * This is an alternative to decorating an application component with an ES7 decorator.
	 */
	var DragDropContextProvider = (_temp = _class = function (_Component) {
		_inherits(DragDropContextProvider, _Component);

		function DragDropContextProvider(props, context) {
			_classCallCheck(this, DragDropContextProvider);

			/**
	     * This property determines which window global to use for creating the DragDropManager.
	     * If a window has been injected explicitly via props, that is used first. If it is available
	     * as a context value, then use that, otherwise use the browser global.
	     */
			var _this = _possibleConstructorReturn(this, (DragDropContextProvider.__proto__ || Object.getPrototypeOf(DragDropContextProvider)).call(this, props, context));

			var getWindow = function getWindow() {
				if (props && props.window) {
					return props.window;
				} else if (context && context.window) {
					return context.window;
				} else if (typeof window !== 'undefined') {
					return window;
				}
				return undefined;
			};

			_this.backend = (0, _DragDropContext.unpackBackendForEs5Users)(props.backend);
			_this.childContext = (0, _DragDropContext.createChildContext)(_this.backend, {
				window: getWindow()
			});
			return _this;
		}

		_createClass(DragDropContextProvider, [{
			key: 'componentWillReceiveProps',
			value: function componentWillReceiveProps(nextProps) {
				if (nextProps.backend !== this.props.backend || nextProps.window !== this.props.window) {
					throw new Error('DragDropContextProvider backend and window props must not change.');
				}
			}
		}, {
			key: 'getChildContext',
			value: function getChildContext() {
				return this.childContext;
			}
		}, {
			key: 'render',
			value: function render() {
				return _react.Children.only(this.props.children);
			}
		}]);

		return DragDropContextProvider;
	}(_react.Component), _class.propTypes = {
		backend: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.object]).isRequired,
		children: _propTypes2.default.element.isRequired,
		window: _propTypes2.default.object // eslint-disable-line react/forbid-prop-types
	}, _class.defaultProps = {
		window: undefined
	}, _class.childContextTypes = _DragDropContext.CHILD_CONTEXT_TYPES, _class.displayName = 'DragDropContextProvider', _class.contextTypes = {
		window: _propTypes2.default.object
	}, _temp);
	exports.default = DragDropContextProvider;

/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	exports.default = DragLayer;

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _hoistNonReactStatics = __webpack_require__(66);

	var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

	var _isPlainObject = __webpack_require__(19);

	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

	var _invariant = __webpack_require__(8);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _shallowEqual = __webpack_require__(78);

	var _shallowEqual2 = _interopRequireDefault(_shallowEqual);

	var _shallowEqualScalar = __webpack_require__(143);

	var _shallowEqualScalar2 = _interopRequireDefault(_shallowEqualScalar);

	var _checkDecoratorArguments = __webpack_require__(47);

	var _checkDecoratorArguments2 = _interopRequireDefault(_checkDecoratorArguments);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function DragLayer(collect) {
		var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		_checkDecoratorArguments2.default.apply(undefined, ['DragLayer', 'collect[, options]'].concat(Array.prototype.slice.call(arguments))); // eslint-disable-line prefer-rest-params
		(0, _invariant2.default)(typeof collect === 'function', 'Expected "collect" provided as the first argument to DragLayer to be a function that collects props to inject into the component. ', 'Instead, received %s. Read more: http://react-dnd.github.io/react-dnd/docs-drag-layer.html', collect);
		(0, _invariant2.default)((0, _isPlainObject2.default)(options), 'Expected "options" provided as the second argument to DragLayer to be a plain object when specified. ' + 'Instead, received %s. Read more: http://react-dnd.github.io/react-dnd/docs-drag-layer.html', options);

		return function decorateLayer(DecoratedComponent) {
			var _class, _temp;

			var _options$arePropsEqua = options.arePropsEqual,
			    arePropsEqual = _options$arePropsEqua === undefined ? _shallowEqualScalar2.default : _options$arePropsEqua;

			var displayName = DecoratedComponent.displayName || DecoratedComponent.name || 'Component';

			var DragLayerContainer = (_temp = _class = function (_Component) {
				_inherits(DragLayerContainer, _Component);

				_createClass(DragLayerContainer, [{
					key: 'getDecoratedComponentInstance',
					value: function getDecoratedComponentInstance() {
						(0, _invariant2.default)(this.child, 'In order to access an instance of the decorated component it can not be a stateless component.');
						return this.child;
					}
				}, {
					key: 'shouldComponentUpdate',
					value: function shouldComponentUpdate(nextProps, nextState) {
						return !arePropsEqual(nextProps, this.props) || !(0, _shallowEqual2.default)(nextState, this.state);
					}
				}]);

				function DragLayerContainer(props, context) {
					_classCallCheck(this, DragLayerContainer);

					var _this = _possibleConstructorReturn(this, (DragLayerContainer.__proto__ || Object.getPrototypeOf(DragLayerContainer)).call(this, props));

					_this.handleChange = _this.handleChange.bind(_this);

					_this.manager = context.dragDropManager;
					(0, _invariant2.default)(_typeof(_this.manager) === 'object', 'Could not find the drag and drop manager in the context of %s. ' + 'Make sure to wrap the top-level component of your app with DragDropContext. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-troubleshooting.html#could-not-find-the-drag-and-drop-manager-in-the-context', displayName, displayName);

					_this.state = _this.getCurrentState();
					return _this;
				}

				_createClass(DragLayerContainer, [{
					key: 'componentDidMount',
					value: function componentDidMount() {
						this.isCurrentlyMounted = true;

						var monitor = this.manager.getMonitor();
						this.unsubscribeFromOffsetChange = monitor.subscribeToOffsetChange(this.handleChange);
						this.unsubscribeFromStateChange = monitor.subscribeToStateChange(this.handleChange);

						this.handleChange();
					}
				}, {
					key: 'componentWillUnmount',
					value: function componentWillUnmount() {
						this.isCurrentlyMounted = false;

						this.unsubscribeFromOffsetChange();
						this.unsubscribeFromStateChange();
					}
				}, {
					key: 'handleChange',
					value: function handleChange() {
						if (!this.isCurrentlyMounted) {
							return;
						}

						var nextState = this.getCurrentState();
						if (!(0, _shallowEqual2.default)(nextState, this.state)) {
							this.setState(nextState);
						}
					}
				}, {
					key: 'getCurrentState',
					value: function getCurrentState() {
						var monitor = this.manager.getMonitor();
						return collect(monitor);
					}
				}, {
					key: 'render',
					value: function render() {
						var _this2 = this;

						return _react2.default.createElement(DecoratedComponent, _extends({}, this.props, this.state, {
							ref: function ref(child) {
								_this2.child = child;
							}
						}));
					}
				}]);

				return DragLayerContainer;
			}(_react.Component), _class.DecoratedComponent = DecoratedComponent, _class.displayName = 'DragLayer(' + displayName + ')', _class.contextTypes = {
				dragDropManager: _propTypes2.default.object.isRequired
			}, _temp);


			return (0, _hoistNonReactStatics2.default)(DragLayerContainer, DecoratedComponent);
		};
	}

/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = DragSource;

	var _invariant = __webpack_require__(8);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _isPlainObject = __webpack_require__(19);

	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

	var _checkDecoratorArguments = __webpack_require__(47);

	var _checkDecoratorArguments2 = _interopRequireDefault(_checkDecoratorArguments);

	var _decorateHandler = __webpack_require__(141);

	var _decorateHandler2 = _interopRequireDefault(_decorateHandler);

	var _registerSource = __webpack_require__(361);

	var _registerSource2 = _interopRequireDefault(_registerSource);

	var _createSourceFactory = __webpack_require__(356);

	var _createSourceFactory2 = _interopRequireDefault(_createSourceFactory);

	var _createSourceMonitor = __webpack_require__(357);

	var _createSourceMonitor2 = _interopRequireDefault(_createSourceMonitor);

	var _createSourceConnector = __webpack_require__(355);

	var _createSourceConnector2 = _interopRequireDefault(_createSourceConnector);

	var _isValidType = __webpack_require__(142);

	var _isValidType2 = _interopRequireDefault(_isValidType);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function DragSource(type, spec, collect) {
		var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

		_checkDecoratorArguments2.default.apply(undefined, ['DragSource', 'type, spec, collect[, options]'].concat(Array.prototype.slice.call(arguments)));
		var getType = type;
		if (typeof type !== 'function') {
			(0, _invariant2.default)((0, _isValidType2.default)(type), 'Expected "type" provided as the first argument to DragSource to be ' + 'a string, or a function that returns a string given the current props. ' + 'Instead, received %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source.html', type);
			getType = function getType() {
				return type;
			};
		}
		(0, _invariant2.default)((0, _isPlainObject2.default)(spec), 'Expected "spec" provided as the second argument to DragSource to be ' + 'a plain object. Instead, received %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source.html', spec);
		var createSource = (0, _createSourceFactory2.default)(spec);
		(0, _invariant2.default)(typeof collect === 'function', 'Expected "collect" provided as the third argument to DragSource to be ' + 'a function that returns a plain object of props to inject. ' + 'Instead, received %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source.html', collect);
		(0, _invariant2.default)((0, _isPlainObject2.default)(options), 'Expected "options" provided as the fourth argument to DragSource to be ' + 'a plain object when specified. ' + 'Instead, received %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source.html', collect);

		return function decorateSource(DecoratedComponent) {
			return (0, _decorateHandler2.default)({
				connectBackend: function connectBackend(backend, sourceId) {
					return backend.connectDragSource(sourceId);
				},
				containerDisplayName: 'DragSource',
				createHandler: createSource,
				registerHandler: _registerSource2.default,
				createMonitor: _createSourceMonitor2.default,
				createConnector: _createSourceConnector2.default,
				DecoratedComponent: DecoratedComponent,
				getType: getType,
				collect: collect,
				options: options
			});
		};
	}

/***/ }),
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = DropTarget;

	var _invariant = __webpack_require__(8);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _isPlainObject = __webpack_require__(19);

	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

	var _checkDecoratorArguments = __webpack_require__(47);

	var _checkDecoratorArguments2 = _interopRequireDefault(_checkDecoratorArguments);

	var _decorateHandler = __webpack_require__(141);

	var _decorateHandler2 = _interopRequireDefault(_decorateHandler);

	var _registerTarget = __webpack_require__(362);

	var _registerTarget2 = _interopRequireDefault(_registerTarget);

	var _createTargetFactory = __webpack_require__(359);

	var _createTargetFactory2 = _interopRequireDefault(_createTargetFactory);

	var _createTargetMonitor = __webpack_require__(360);

	var _createTargetMonitor2 = _interopRequireDefault(_createTargetMonitor);

	var _createTargetConnector = __webpack_require__(358);

	var _createTargetConnector2 = _interopRequireDefault(_createTargetConnector);

	var _isValidType = __webpack_require__(142);

	var _isValidType2 = _interopRequireDefault(_isValidType);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function DropTarget(type, spec, collect) {
		var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

		_checkDecoratorArguments2.default.apply(undefined, ['DropTarget', 'type, spec, collect[, options]'].concat(Array.prototype.slice.call(arguments)));
		var getType = type;
		if (typeof type !== 'function') {
			(0, _invariant2.default)((0, _isValidType2.default)(type, true), 'Expected "type" provided as the first argument to DropTarget to be ' + 'a string, an array of strings, or a function that returns either given ' + 'the current props. Instead, received %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drop-target.html', type);
			getType = function getType() {
				return type;
			};
		}
		(0, _invariant2.default)((0, _isPlainObject2.default)(spec), 'Expected "spec" provided as the second argument to DropTarget to be ' + 'a plain object. Instead, received %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drop-target.html', spec);
		var createTarget = (0, _createTargetFactory2.default)(spec);
		(0, _invariant2.default)(typeof collect === 'function', 'Expected "collect" provided as the third argument to DropTarget to be ' + 'a function that returns a plain object of props to inject. ' + 'Instead, received %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drop-target.html', collect);
		(0, _invariant2.default)((0, _isPlainObject2.default)(options), 'Expected "options" provided as the fourth argument to DropTarget to be ' + 'a plain object when specified. ' + 'Instead, received %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drop-target.html', collect);

		return function decorateTarget(DecoratedComponent) {
			return (0, _decorateHandler2.default)({
				connectBackend: function connectBackend(backend, targetId) {
					return backend.connectDropTarget(targetId);
				},
				containerDisplayName: 'DropTarget',
				createHandler: createTarget,
				registerHandler: _registerTarget2.default,
				createMonitor: _createTargetMonitor2.default,
				createConnector: _createTargetConnector2.default,
				DecoratedComponent: DecoratedComponent,
				getType: getType,
				collect: collect,
				options: options
			});
		};
	}

/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = createSourceConnector;

	var _wrapConnectorHooks = __webpack_require__(144);

	var _wrapConnectorHooks2 = _interopRequireDefault(_wrapConnectorHooks);

	var _areOptionsEqual = __webpack_require__(140);

	var _areOptionsEqual2 = _interopRequireDefault(_areOptionsEqual);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function createSourceConnector(backend) {
		var currentHandlerId = void 0;

		var currentDragSourceNode = void 0;
		var currentDragSourceOptions = void 0;
		var disconnectCurrentDragSource = void 0;

		var currentDragPreviewNode = void 0;
		var currentDragPreviewOptions = void 0;
		var disconnectCurrentDragPreview = void 0;

		function reconnectDragSource() {
			if (disconnectCurrentDragSource) {
				disconnectCurrentDragSource();
				disconnectCurrentDragSource = null;
			}

			if (currentHandlerId && currentDragSourceNode) {
				disconnectCurrentDragSource = backend.connectDragSource(currentHandlerId, currentDragSourceNode, currentDragSourceOptions);
			}
		}

		function reconnectDragPreview() {
			if (disconnectCurrentDragPreview) {
				disconnectCurrentDragPreview();
				disconnectCurrentDragPreview = null;
			}

			if (currentHandlerId && currentDragPreviewNode) {
				disconnectCurrentDragPreview = backend.connectDragPreview(currentHandlerId, currentDragPreviewNode, currentDragPreviewOptions);
			}
		}

		function receiveHandlerId(handlerId) {
			if (handlerId === currentHandlerId) {
				return;
			}

			currentHandlerId = handlerId;
			reconnectDragSource();
			reconnectDragPreview();
		}

		var hooks = (0, _wrapConnectorHooks2.default)({
			dragSource: function connectDragSource(node, options) {
				if (node === currentDragSourceNode && (0, _areOptionsEqual2.default)(options, currentDragSourceOptions)) {
					return;
				}

				currentDragSourceNode = node;
				currentDragSourceOptions = options;

				reconnectDragSource();
			},

			dragPreview: function connectDragPreview(node, options) {
				if (node === currentDragPreviewNode && (0, _areOptionsEqual2.default)(options, currentDragPreviewOptions)) {
					return;
				}

				currentDragPreviewNode = node;
				currentDragPreviewOptions = options;

				reconnectDragPreview();
			}
		});

		return {
			receiveHandlerId: receiveHandlerId,
			hooks: hooks
		};
	}

/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	exports.default = createSourceFactory;

	var _invariant = __webpack_require__(8);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _isPlainObject = __webpack_require__(19);

	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var ALLOWED_SPEC_METHODS = ['canDrag', 'beginDrag', 'isDragging', 'endDrag'];
	var REQUIRED_SPEC_METHODS = ['beginDrag'];

	function createSourceFactory(spec) {
		Object.keys(spec).forEach(function (key) {
			(0, _invariant2.default)(ALLOWED_SPEC_METHODS.indexOf(key) > -1, 'Expected the drag source specification to only have ' + 'some of the following keys: %s. ' + 'Instead received a specification with an unexpected "%s" key. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source.html', ALLOWED_SPEC_METHODS.join(', '), key);
			(0, _invariant2.default)(typeof spec[key] === 'function', 'Expected %s in the drag source specification to be a function. ' + 'Instead received a specification with %s: %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source.html', key, key, spec[key]);
		});
		REQUIRED_SPEC_METHODS.forEach(function (key) {
			(0, _invariant2.default)(typeof spec[key] === 'function', 'Expected %s in the drag source specification to be a function. ' + 'Instead received a specification with %s: %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source.html', key, key, spec[key]);
		});

		var Source = function () {
			function Source(monitor) {
				_classCallCheck(this, Source);

				this.monitor = monitor;
				this.props = null;
				this.component = null;
			}

			_createClass(Source, [{
				key: 'receiveProps',
				value: function receiveProps(props) {
					this.props = props;
				}
			}, {
				key: 'receiveComponent',
				value: function receiveComponent(component) {
					this.component = component;
				}
			}, {
				key: 'canDrag',
				value: function canDrag() {
					if (!spec.canDrag) {
						return true;
					}

					return spec.canDrag(this.props, this.monitor);
				}
			}, {
				key: 'isDragging',
				value: function isDragging(globalMonitor, sourceId) {
					if (!spec.isDragging) {
						return sourceId === globalMonitor.getSourceId();
					}

					return spec.isDragging(this.props, this.monitor);
				}
			}, {
				key: 'beginDrag',
				value: function beginDrag() {
					var item = spec.beginDrag(this.props, this.monitor, this.component);
					if (false) {
						(0, _invariant2.default)((0, _isPlainObject2.default)(item), 'beginDrag() must return a plain object that represents the dragged item. ' + 'Instead received %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source.html', item);
					}
					return item;
				}
			}, {
				key: 'endDrag',
				value: function endDrag() {
					if (!spec.endDrag) {
						return;
					}

					spec.endDrag(this.props, this.monitor, this.component);
				}
			}]);

			return Source;
		}();

		return function createSource(monitor) {
			return new Source(monitor);
		};
	}

/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	exports.default = createSourceMonitor;

	var _invariant = __webpack_require__(8);

	var _invariant2 = _interopRequireDefault(_invariant);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var isCallingCanDrag = false;
	var isCallingIsDragging = false;

	var SourceMonitor = function () {
		function SourceMonitor(manager) {
			_classCallCheck(this, SourceMonitor);

			this.internalMonitor = manager.getMonitor();
		}

		_createClass(SourceMonitor, [{
			key: 'receiveHandlerId',
			value: function receiveHandlerId(sourceId) {
				this.sourceId = sourceId;
			}
		}, {
			key: 'canDrag',
			value: function canDrag() {
				(0, _invariant2.default)(!isCallingCanDrag, 'You may not call monitor.canDrag() inside your canDrag() implementation. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source-monitor.html');

				try {
					isCallingCanDrag = true;
					return this.internalMonitor.canDragSource(this.sourceId);
				} finally {
					isCallingCanDrag = false;
				}
			}
		}, {
			key: 'isDragging',
			value: function isDragging() {
				(0, _invariant2.default)(!isCallingIsDragging, 'You may not call monitor.isDragging() inside your isDragging() implementation. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source-monitor.html');

				try {
					isCallingIsDragging = true;
					return this.internalMonitor.isDraggingSource(this.sourceId);
				} finally {
					isCallingIsDragging = false;
				}
			}
		}, {
			key: 'getItemType',
			value: function getItemType() {
				return this.internalMonitor.getItemType();
			}
		}, {
			key: 'getItem',
			value: function getItem() {
				return this.internalMonitor.getItem();
			}
		}, {
			key: 'getDropResult',
			value: function getDropResult() {
				return this.internalMonitor.getDropResult();
			}
		}, {
			key: 'didDrop',
			value: function didDrop() {
				return this.internalMonitor.didDrop();
			}
		}, {
			key: 'getInitialClientOffset',
			value: function getInitialClientOffset() {
				return this.internalMonitor.getInitialClientOffset();
			}
		}, {
			key: 'getInitialSourceClientOffset',
			value: function getInitialSourceClientOffset() {
				return this.internalMonitor.getInitialSourceClientOffset();
			}
		}, {
			key: 'getSourceClientOffset',
			value: function getSourceClientOffset() {
				return this.internalMonitor.getSourceClientOffset();
			}
		}, {
			key: 'getClientOffset',
			value: function getClientOffset() {
				return this.internalMonitor.getClientOffset();
			}
		}, {
			key: 'getDifferenceFromInitialOffset',
			value: function getDifferenceFromInitialOffset() {
				return this.internalMonitor.getDifferenceFromInitialOffset();
			}
		}]);

		return SourceMonitor;
	}();

	function createSourceMonitor(manager) {
		return new SourceMonitor(manager);
	}

/***/ }),
/* 358 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = createTargetConnector;

	var _wrapConnectorHooks = __webpack_require__(144);

	var _wrapConnectorHooks2 = _interopRequireDefault(_wrapConnectorHooks);

	var _areOptionsEqual = __webpack_require__(140);

	var _areOptionsEqual2 = _interopRequireDefault(_areOptionsEqual);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function createTargetConnector(backend) {
		var currentHandlerId = void 0;

		var currentDropTargetNode = void 0;
		var currentDropTargetOptions = void 0;
		var disconnectCurrentDropTarget = void 0;

		function reconnectDropTarget() {
			if (disconnectCurrentDropTarget) {
				disconnectCurrentDropTarget();
				disconnectCurrentDropTarget = null;
			}

			if (currentHandlerId && currentDropTargetNode) {
				disconnectCurrentDropTarget = backend.connectDropTarget(currentHandlerId, currentDropTargetNode, currentDropTargetOptions);
			}
		}

		function receiveHandlerId(handlerId) {
			if (handlerId === currentHandlerId) {
				return;
			}

			currentHandlerId = handlerId;
			reconnectDropTarget();
		}

		var hooks = (0, _wrapConnectorHooks2.default)({
			dropTarget: function connectDropTarget(node, options) {
				if (node === currentDropTargetNode && (0, _areOptionsEqual2.default)(options, currentDropTargetOptions)) {
					return;
				}

				currentDropTargetNode = node;
				currentDropTargetOptions = options;

				reconnectDropTarget();
			}
		});

		return {
			receiveHandlerId: receiveHandlerId,
			hooks: hooks
		};
	}

/***/ }),
/* 359 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	exports.default = createTargetFactory;

	var _invariant = __webpack_require__(8);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _isPlainObject = __webpack_require__(19);

	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var ALLOWED_SPEC_METHODS = ['canDrop', 'hover', 'drop'];

	function createTargetFactory(spec) {
		Object.keys(spec).forEach(function (key) {
			(0, _invariant2.default)(ALLOWED_SPEC_METHODS.indexOf(key) > -1, 'Expected the drop target specification to only have ' + 'some of the following keys: %s. ' + 'Instead received a specification with an unexpected "%s" key. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drop-target.html', ALLOWED_SPEC_METHODS.join(', '), key);
			(0, _invariant2.default)(typeof spec[key] === 'function', 'Expected %s in the drop target specification to be a function. ' + 'Instead received a specification with %s: %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drop-target.html', key, key, spec[key]);
		});

		var Target = function () {
			function Target(monitor) {
				_classCallCheck(this, Target);

				this.monitor = monitor;
				this.props = null;
				this.component = null;
			}

			_createClass(Target, [{
				key: 'receiveProps',
				value: function receiveProps(props) {
					this.props = props;
				}
			}, {
				key: 'receiveMonitor',
				value: function receiveMonitor(monitor) {
					this.monitor = monitor;
				}
			}, {
				key: 'receiveComponent',
				value: function receiveComponent(component) {
					this.component = component;
				}
			}, {
				key: 'canDrop',
				value: function canDrop() {
					if (!spec.canDrop) {
						return true;
					}

					return spec.canDrop(this.props, this.monitor);
				}
			}, {
				key: 'hover',
				value: function hover() {
					if (!spec.hover) {
						return;
					}

					spec.hover(this.props, this.monitor, this.component);
				}
			}, {
				key: 'drop',
				value: function drop() {
					if (!spec.drop) {
						return undefined;
					}

					var dropResult = spec.drop(this.props, this.monitor, this.component);
					if (false) {
						(0, _invariant2.default)(typeof dropResult === 'undefined' || (0, _isPlainObject2.default)(dropResult), 'drop() must either return undefined, or an object that represents the drop result. ' + 'Instead received %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drop-target.html', dropResult);
					}
					return dropResult;
				}
			}]);

			return Target;
		}();

		return function createTarget(monitor) {
			return new Target(monitor);
		};
	}

/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	exports.default = createTargetMonitor;

	var _invariant = __webpack_require__(8);

	var _invariant2 = _interopRequireDefault(_invariant);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var isCallingCanDrop = false;

	var TargetMonitor = function () {
		function TargetMonitor(manager) {
			_classCallCheck(this, TargetMonitor);

			this.internalMonitor = manager.getMonitor();
		}

		_createClass(TargetMonitor, [{
			key: 'receiveHandlerId',
			value: function receiveHandlerId(targetId) {
				this.targetId = targetId;
			}
		}, {
			key: 'canDrop',
			value: function canDrop() {
				(0, _invariant2.default)(!isCallingCanDrop, 'You may not call monitor.canDrop() inside your canDrop() implementation. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drop-target-monitor.html');

				try {
					isCallingCanDrop = true;
					return this.internalMonitor.canDropOnTarget(this.targetId);
				} finally {
					isCallingCanDrop = false;
				}
			}
		}, {
			key: 'isOver',
			value: function isOver(options) {
				return this.internalMonitor.isOverTarget(this.targetId, options);
			}
		}, {
			key: 'getItemType',
			value: function getItemType() {
				return this.internalMonitor.getItemType();
			}
		}, {
			key: 'getItem',
			value: function getItem() {
				return this.internalMonitor.getItem();
			}
		}, {
			key: 'getDropResult',
			value: function getDropResult() {
				return this.internalMonitor.getDropResult();
			}
		}, {
			key: 'didDrop',
			value: function didDrop() {
				return this.internalMonitor.didDrop();
			}
		}, {
			key: 'getInitialClientOffset',
			value: function getInitialClientOffset() {
				return this.internalMonitor.getInitialClientOffset();
			}
		}, {
			key: 'getInitialSourceClientOffset',
			value: function getInitialSourceClientOffset() {
				return this.internalMonitor.getInitialSourceClientOffset();
			}
		}, {
			key: 'getSourceClientOffset',
			value: function getSourceClientOffset() {
				return this.internalMonitor.getSourceClientOffset();
			}
		}, {
			key: 'getClientOffset',
			value: function getClientOffset() {
				return this.internalMonitor.getClientOffset();
			}
		}, {
			key: 'getDifferenceFromInitialOffset',
			value: function getDifferenceFromInitialOffset() {
				return this.internalMonitor.getDifferenceFromInitialOffset();
			}
		}]);

		return TargetMonitor;
	}();

	function createTargetMonitor(manager) {
		return new TargetMonitor(manager);
	}

/***/ }),
/* 361 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = registerSource;
	function registerSource(type, source, manager) {
		var registry = manager.getRegistry();
		var sourceId = registry.addSource(type, source);

		function unregisterSource() {
			registry.removeSource(sourceId);
		}

		return {
			handlerId: sourceId,
			unregister: unregisterSource
		};
	}

/***/ }),
/* 362 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = registerTarget;
	function registerTarget(type, target, manager) {
		var registry = manager.getRegistry();
		var targetId = registry.addTarget(type, target);

		function unregisterTarget() {
			registry.removeTarget(targetId);
		}

		return {
			handlerId: targetId,
			unregister: unregisterTarget
		};
	}

/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = cloneWithRef;

	var _invariant = __webpack_require__(8);

	var _invariant2 = _interopRequireDefault(_invariant);

	var _react = __webpack_require__(2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function cloneWithRef(element, newRef) {
		var previousRef = element.ref;
		(0, _invariant2.default)(typeof previousRef !== 'string', 'Cannot connect React DnD to an element with an existing string ref. ' + 'Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. ' + 'Read more: https://facebook.github.io/react/docs/more-about-refs.html#the-ref-callback-attribute');

		if (!previousRef) {
			// When there is no ref on the element, use the new ref directly
			return (0, _react.cloneElement)(element, {
				ref: newRef
			});
		}

		return (0, _react.cloneElement)(element, {
			ref: function ref(node) {
				newRef(node);

				if (previousRef) {
					previousRef(node);
				}
			}
		});
	}

/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	var _Select = __webpack_require__(48);

	var _Select2 = _interopRequireDefault(_Select);

	var _Async = __webpack_require__(145);

	var _Async2 = _interopRequireDefault(_Async);

	var _Creatable = __webpack_require__(146);

	var _Creatable2 = _interopRequireDefault(_Creatable);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var AsyncCreatableSelect = function (_React$Component) {
		_inherits(AsyncCreatableSelect, _React$Component);

		function AsyncCreatableSelect() {
			_classCallCheck(this, AsyncCreatableSelect);

			return _possibleConstructorReturn(this, (AsyncCreatableSelect.__proto__ || Object.getPrototypeOf(AsyncCreatableSelect)).apply(this, arguments));
		}

		_createClass(AsyncCreatableSelect, [{
			key: 'focus',
			value: function focus() {
				this.select.focus();
			}
		}, {
			key: 'render',
			value: function render() {
				var _this2 = this;

				return _react2.default.createElement(
					_Async2.default,
					this.props,
					function (_ref) {
						var ref = _ref.ref,
						    asyncProps = _objectWithoutProperties(_ref, ['ref']);

						var asyncRef = ref;
						return _react2.default.createElement(
							_Creatable2.default,
							asyncProps,
							function (_ref2) {
								var ref = _ref2.ref,
								    creatableProps = _objectWithoutProperties(_ref2, ['ref']);

								var creatableRef = ref;
								return _this2.props.children(_extends({}, creatableProps, {
									ref: function ref(select) {
										creatableRef(select);
										asyncRef(select);
										_this2.select = select;
									}
								}));
							}
						);
					}
				);
			}
		}]);

		return AsyncCreatableSelect;
	}(_react2.default.Component);

	;

	function defaultChildren(props) {
		return _react2.default.createElement(_Select2.default, props);
	};

	AsyncCreatableSelect.propTypes = {
		children: _propTypes2.default.func.isRequired // Child function responsible for creating the inner Select component; (props: Object): PropTypes.element
	};

	AsyncCreatableSelect.defaultProps = {
		children: defaultChildren
	};

	exports.default = AsyncCreatableSelect;

/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.defaultFilterOptions = exports.defaultClearRenderer = exports.defaultArrowRenderer = exports.defaultMenuRenderer = exports.Option = exports.Value = exports.Creatable = exports.AsyncCreatable = exports.Async = undefined;

	var _Select = __webpack_require__(48);

	var _Select2 = _interopRequireDefault(_Select);

	var _Async = __webpack_require__(145);

	var _Async2 = _interopRequireDefault(_Async);

	var _AsyncCreatable = __webpack_require__(364);

	var _AsyncCreatable2 = _interopRequireDefault(_AsyncCreatable);

	var _Creatable = __webpack_require__(146);

	var _Creatable2 = _interopRequireDefault(_Creatable);

	var _Value = __webpack_require__(148);

	var _Value2 = _interopRequireDefault(_Value);

	var _Option = __webpack_require__(147);

	var _Option2 = _interopRequireDefault(_Option);

	var _defaultMenuRenderer = __webpack_require__(80);

	var _defaultMenuRenderer2 = _interopRequireDefault(_defaultMenuRenderer);

	var _defaultArrowRenderer = __webpack_require__(149);

	var _defaultArrowRenderer2 = _interopRequireDefault(_defaultArrowRenderer);

	var _defaultClearRenderer = __webpack_require__(150);

	var _defaultClearRenderer2 = _interopRequireDefault(_defaultClearRenderer);

	var _defaultFilterOptions = __webpack_require__(79);

	var _defaultFilterOptions2 = _interopRequireDefault(_defaultFilterOptions);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	_Select2.default.Async = _Async2.default;
	_Select2.default.AsyncCreatable = _AsyncCreatable2.default;
	_Select2.default.Creatable = _Creatable2.default;
	_Select2.default.Value = _Value2.default;
	_Select2.default.Option = _Option2.default;

	exports.default = _Select2.default;
	exports.Async = _Async2.default;
	exports.AsyncCreatable = _AsyncCreatable2.default;
	exports.Creatable = _Creatable2.default;
	exports.Value = _Value2.default;
	exports.Option = _Option2.default;
	exports.defaultMenuRenderer = _defaultMenuRenderer2.default;
	exports.defaultArrowRenderer = _defaultArrowRenderer2.default;
	exports.defaultClearRenderer = _defaultClearRenderer2.default;
	exports.defaultFilterOptions = _defaultFilterOptions2.default;

/***/ }),
/* 366 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = trim;
	function trim(str) {
	    return str.replace(/^\s+|\s+$/g, '');
	}

/***/ }),
/* 367 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _propTypes = __webpack_require__(3);

	var _propTypes2 = _interopRequireDefault(_propTypes);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var sizerStyle = {
		position: 'absolute',
		top: 0,
		left: 0,
		visibility: 'hidden',
		height: 0,
		overflow: 'scroll',
		whiteSpace: 'pre'
	};

	var INPUT_PROPS_BLACKLIST = ['injectStyles', 'inputClassName', 'inputRef', 'inputStyle', 'minWidth', 'onAutosize', 'placeholderIsMinWidth'];

	var cleanInputProps = function cleanInputProps(inputProps) {
		INPUT_PROPS_BLACKLIST.forEach(function (field) {
			return delete inputProps[field];
		});
		return inputProps;
	};

	var copyStyles = function copyStyles(styles, node) {
		node.style.fontSize = styles.fontSize;
		node.style.fontFamily = styles.fontFamily;
		node.style.fontWeight = styles.fontWeight;
		node.style.fontStyle = styles.fontStyle;
		node.style.letterSpacing = styles.letterSpacing;
		node.style.textTransform = styles.textTransform;
	};

	var isIE = typeof window === 'undefined' ? false : /MSIE |Trident\/|Edge\//.test(window.navigator.userAgent);

	var generateId = function generateId() {
		// we only need an auto-generated ID for stylesheet injection, which is only
		// used for IE. so if the browser is not IE, this should return undefined.
		return isIE ? '_' + Math.random().toString(36).substr(2, 12) : undefined;
	};

	var AutosizeInput = function (_Component) {
		_inherits(AutosizeInput, _Component);

		function AutosizeInput(props) {
			_classCallCheck(this, AutosizeInput);

			var _this = _possibleConstructorReturn(this, (AutosizeInput.__proto__ || Object.getPrototypeOf(AutosizeInput)).call(this, props));

			_this.inputRef = function (el) {
				_this.input = el;
				if (typeof _this.props.inputRef === 'function') {
					_this.props.inputRef(el);
				}
			};

			_this.placeHolderSizerRef = function (el) {
				_this.placeHolderSizer = el;
			};

			_this.sizerRef = function (el) {
				_this.sizer = el;
			};

			_this.state = {
				inputWidth: props.minWidth,
				inputId: props.id || generateId()
			};
			return _this;
		}

		_createClass(AutosizeInput, [{
			key: 'componentDidMount',
			value: function componentDidMount() {
				this.mounted = true;
				this.copyInputStyles();
				this.updateInputWidth();
			}
		}, {
			key: 'componentWillReceiveProps',
			value: function componentWillReceiveProps(nextProps) {
				var id = nextProps.id;

				if (id !== this.props.id) {
					this.setState({ inputId: id || generateId() });
				}
			}
		}, {
			key: 'componentDidUpdate',
			value: function componentDidUpdate(prevProps, prevState) {
				if (prevState.inputWidth !== this.state.inputWidth) {
					if (typeof this.props.onAutosize === 'function') {
						this.props.onAutosize(this.state.inputWidth);
					}
				}
				this.updateInputWidth();
			}
		}, {
			key: 'componentWillUnmount',
			value: function componentWillUnmount() {
				this.mounted = false;
			}
		}, {
			key: 'copyInputStyles',
			value: function copyInputStyles() {
				if (!this.mounted || !window.getComputedStyle) {
					return;
				}
				var inputStyles = this.input && window.getComputedStyle(this.input);
				if (!inputStyles) {
					return;
				}
				copyStyles(inputStyles, this.sizer);
				if (this.placeHolderSizer) {
					copyStyles(inputStyles, this.placeHolderSizer);
				}
			}
		}, {
			key: 'updateInputWidth',
			value: function updateInputWidth() {
				if (!this.mounted || !this.sizer || typeof this.sizer.scrollWidth === 'undefined') {
					return;
				}
				var newInputWidth = void 0;
				if (this.props.placeholder && (!this.props.value || this.props.value && this.props.placeholderIsMinWidth)) {
					newInputWidth = Math.max(this.sizer.scrollWidth, this.placeHolderSizer.scrollWidth) + 2;
				} else {
					newInputWidth = this.sizer.scrollWidth + 2;
				}
				// allow for stepper UI on number types
				if (this.props.type === 'number') {
					newInputWidth += 16;
				}
				if (newInputWidth < this.props.minWidth) {
					newInputWidth = this.props.minWidth;
				}
				if (newInputWidth !== this.state.inputWidth) {
					this.setState({
						inputWidth: newInputWidth
					});
				}
			}
		}, {
			key: 'getInput',
			value: function getInput() {
				return this.input;
			}
		}, {
			key: 'focus',
			value: function focus() {
				this.input.focus();
			}
		}, {
			key: 'blur',
			value: function blur() {
				this.input.blur();
			}
		}, {
			key: 'select',
			value: function select() {
				this.input.select();
			}
		}, {
			key: 'renderStyles',
			value: function renderStyles() {
				// this method injects styles to hide IE's clear indicator, which messes
				// with input size detection. the stylesheet is only injected when the
				// browser is IE, and can also be disabled by the `injectStyles` prop.
				var injectStyles = this.props.injectStyles;

				return isIE && injectStyles ? _react2.default.createElement('style', { dangerouslySetInnerHTML: {
						__html: 'input#' + this.state.inputId + '::-ms-clear {display: none;}'
					} }) : null;
			}
		}, {
			key: 'render',
			value: function render() {
				var sizerValue = [this.props.defaultValue, this.props.value, ''].reduce(function (previousValue, currentValue) {
					if (previousValue !== null && previousValue !== undefined) {
						return previousValue;
					}
					return currentValue;
				});

				var wrapperStyle = _extends({}, this.props.style);
				if (!wrapperStyle.display) wrapperStyle.display = 'inline-block';

				var inputStyle = _extends({
					boxSizing: 'content-box',
					width: this.state.inputWidth + 'px'
				}, this.props.inputStyle);

				var inputProps = _objectWithoutProperties(this.props, []);

				cleanInputProps(inputProps);
				inputProps.className = this.props.inputClassName;
				inputProps.id = this.state.inputId;
				inputProps.style = inputStyle;

				return _react2.default.createElement(
					'div',
					{ className: this.props.className, style: wrapperStyle },
					this.renderStyles(),
					_react2.default.createElement('input', _extends({}, inputProps, { ref: this.inputRef })),
					_react2.default.createElement(
						'div',
						{ ref: this.sizerRef, style: sizerStyle },
						sizerValue
					),
					this.props.placeholder ? _react2.default.createElement(
						'div',
						{ ref: this.placeHolderSizerRef, style: sizerStyle },
						this.props.placeholder
					) : null
				);
			}
		}]);

		return AutosizeInput;
	}(_react.Component);

	;

	AutosizeInput.propTypes = {
		className: _propTypes2.default.string, // className for the outer element
		defaultValue: _propTypes2.default.any, // default field value
		id: _propTypes2.default.string, // id to use for the input, can be set for consistent snapshots
		injectStyles: _propTypes2.default.bool, // inject the custom stylesheet to hide clear UI, defaults to true
		inputClassName: _propTypes2.default.string, // className for the input element
		inputRef: _propTypes2.default.func, // ref callback for the input element
		inputStyle: _propTypes2.default.object, // css styles for the input element
		minWidth: _propTypes2.default.oneOfType([// minimum width for input element
		_propTypes2.default.number, _propTypes2.default.string]),
		onAutosize: _propTypes2.default.func, // onAutosize handler: function(newWidth) {}
		onChange: _propTypes2.default.func, // onChange handler: function(newValue) {}
		placeholder: _propTypes2.default.string, // placeholder text
		placeholderIsMinWidth: _propTypes2.default.bool, // don't collapse size to less than the placeholder
		style: _propTypes2.default.object, // css styles for the outer element
		value: _propTypes2.default.any // field value
	};
	AutosizeInput.defaultProps = {
		minWidth: 1,
		injectStyles: true
	};

	exports.default = AutosizeInput;

/***/ }),
/* 368 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.ActionTypes = undefined;
	exports['default'] = createStore;

	var _isPlainObject = __webpack_require__(19);

	var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

	var _symbolObservable = __webpack_require__(371);

	var _symbolObservable2 = _interopRequireDefault(_symbolObservable);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	/**
	 * These are private action types reserved by Redux.
	 * For any unknown actions, you must return the current state.
	 * If the current state is undefined, you must return the initial state.
	 * Do not reference these action types directly in your code.
	 */
	var ActionTypes = exports.ActionTypes = {
	  INIT: '@@redux/INIT'

	  /**
	   * Creates a Redux store that holds the state tree.
	   * The only way to change the data in the store is to call `dispatch()` on it.
	   *
	   * There should only be a single store in your app. To specify how different
	   * parts of the state tree respond to actions, you may combine several reducers
	   * into a single reducer function by using `combineReducers`.
	   *
	   * @param {Function} reducer A function that returns the next state tree, given
	   * the current state tree and the action to handle.
	   *
	   * @param {any} [preloadedState] The initial state. You may optionally specify it
	   * to hydrate the state from the server in universal apps, or to restore a
	   * previously serialized user session.
	   * If you use `combineReducers` to produce the root reducer function, this must be
	   * an object with the same shape as `combineReducers` keys.
	   *
	   * @param {Function} [enhancer] The store enhancer. You may optionally specify it
	   * to enhance the store with third-party capabilities such as middleware,
	   * time travel, persistence, etc. The only store enhancer that ships with Redux
	   * is `applyMiddleware()`.
	   *
	   * @returns {Store} A Redux store that lets you read the state, dispatch actions
	   * and subscribe to changes.
	   */
	};function createStore(reducer, preloadedState, enhancer) {
	  var _ref2;

	  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
	    enhancer = preloadedState;
	    preloadedState = undefined;
	  }

	  if (typeof enhancer !== 'undefined') {
	    if (typeof enhancer !== 'function') {
	      throw new Error('Expected the enhancer to be a function.');
	    }

	    return enhancer(createStore)(reducer, preloadedState);
	  }

	  if (typeof reducer !== 'function') {
	    throw new Error('Expected the reducer to be a function.');
	  }

	  var currentReducer = reducer;
	  var currentState = preloadedState;
	  var currentListeners = [];
	  var nextListeners = currentListeners;
	  var isDispatching = false;

	  function ensureCanMutateNextListeners() {
	    if (nextListeners === currentListeners) {
	      nextListeners = currentListeners.slice();
	    }
	  }

	  /**
	   * Reads the state tree managed by the store.
	   *
	   * @returns {any} The current state tree of your application.
	   */
	  function getState() {
	    return currentState;
	  }

	  /**
	   * Adds a change listener. It will be called any time an action is dispatched,
	   * and some part of the state tree may potentially have changed. You may then
	   * call `getState()` to read the current state tree inside the callback.
	   *
	   * You may call `dispatch()` from a change listener, with the following
	   * caveats:
	   *
	   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
	   * If you subscribe or unsubscribe while the listeners are being invoked, this
	   * will not have any effect on the `dispatch()` that is currently in progress.
	   * However, the next `dispatch()` call, whether nested or not, will use a more
	   * recent snapshot of the subscription list.
	   *
	   * 2. The listener should not expect to see all state changes, as the state
	   * might have been updated multiple times during a nested `dispatch()` before
	   * the listener is called. It is, however, guaranteed that all subscribers
	   * registered before the `dispatch()` started will be called with the latest
	   * state by the time it exits.
	   *
	   * @param {Function} listener A callback to be invoked on every dispatch.
	   * @returns {Function} A function to remove this change listener.
	   */
	  function subscribe(listener) {
	    if (typeof listener !== 'function') {
	      throw new Error('Expected listener to be a function.');
	    }

	    var isSubscribed = true;

	    ensureCanMutateNextListeners();
	    nextListeners.push(listener);

	    return function unsubscribe() {
	      if (!isSubscribed) {
	        return;
	      }

	      isSubscribed = false;

	      ensureCanMutateNextListeners();
	      var index = nextListeners.indexOf(listener);
	      nextListeners.splice(index, 1);
	    };
	  }

	  /**
	   * Dispatches an action. It is the only way to trigger a state change.
	   *
	   * The `reducer` function, used to create the store, will be called with the
	   * current state tree and the given `action`. Its return value will
	   * be considered the **next** state of the tree, and the change listeners
	   * will be notified.
	   *
	   * The base implementation only supports plain object actions. If you want to
	   * dispatch a Promise, an Observable, a thunk, or something else, you need to
	   * wrap your store creating function into the corresponding middleware. For
	   * example, see the documentation for the `redux-thunk` package. Even the
	   * middleware will eventually dispatch plain object actions using this method.
	   *
	   * @param {Object} action A plain object representing â€œwhat changedâ€. It is
	   * a good idea to keep actions serializable so you can record and replay user
	   * sessions, or use the time travelling `redux-devtools`. An action must have
	   * a `type` property which may not be `undefined`. It is a good idea to use
	   * string constants for action types.
	   *
	   * @returns {Object} For convenience, the same action object you dispatched.
	   *
	   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
	   * return something else (for example, a Promise you can await).
	   */
	  function dispatch(action) {
	    if (!(0, _isPlainObject2['default'])(action)) {
	      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
	    }

	    if (typeof action.type === 'undefined') {
	      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
	    }

	    if (isDispatching) {
	      throw new Error('Reducers may not dispatch actions.');
	    }

	    try {
	      isDispatching = true;
	      currentState = currentReducer(currentState, action);
	    } finally {
	      isDispatching = false;
	    }

	    var listeners = currentListeners = nextListeners;
	    for (var i = 0; i < listeners.length; i++) {
	      var listener = listeners[i];
	      listener();
	    }

	    return action;
	  }

	  /**
	   * Replaces the reducer currently used by the store to calculate the state.
	   *
	   * You might need this if your app implements code splitting and you want to
	   * load some of the reducers dynamically. You might also need this if you
	   * implement a hot reloading mechanism for Redux.
	   *
	   * @param {Function} nextReducer The reducer for the store to use instead.
	   * @returns {void}
	   */
	  function replaceReducer(nextReducer) {
	    if (typeof nextReducer !== 'function') {
	      throw new Error('Expected the nextReducer to be a function.');
	    }

	    currentReducer = nextReducer;
	    dispatch({ type: ActionTypes.INIT });
	  }

	  /**
	   * Interoperability point for observable/reactive libraries.
	   * @returns {observable} A minimal observable of state changes.
	   * For more information, see the observable proposal:
	   * https://github.com/tc39/proposal-observable
	   */
	  function observable() {
	    var _ref;

	    var outerSubscribe = subscribe;
	    return _ref = {
	      /**
	       * The minimal observable subscription method.
	       * @param {Object} observer Any object that can be used as an observer.
	       * The observer object should have a `next` method.
	       * @returns {subscription} An object with an `unsubscribe` method that can
	       * be used to unsubscribe the observable from the store, and prevent further
	       * emission of values from the observable.
	       */
	      subscribe: function subscribe(observer) {
	        if (typeof observer !== 'object') {
	          throw new TypeError('Expected the observer to be an object.');
	        }

	        function observeState() {
	          if (observer.next) {
	            observer.next(getState());
	          }
	        }

	        observeState();
	        var unsubscribe = outerSubscribe(observeState);
	        return { unsubscribe: unsubscribe };
	      }
	    }, _ref[_symbolObservable2['default']] = function () {
	      return this;
	    }, _ref;
	  }

	  // When a store is created, an "INIT" action is dispatched so that every
	  // reducer returns their initial state. This effectively populates
	  // the initial state tree.
	  dispatch({ type: ActionTypes.INIT });

	  return _ref2 = {
	    dispatch: dispatch,
	    subscribe: subscribe,
	    getState: getState,
	    replaceReducer: replaceReducer
	  }, _ref2[_symbolObservable2['default']] = observable, _ref2;
	}

/***/ }),
/* 369 */
/***/ (function(module, exports) {

	'use strict';

	exports.__esModule = true;
	exports.defaultMemoize = defaultMemoize;
	exports.createSelectorCreator = createSelectorCreator;
	exports.createStructuredSelector = createStructuredSelector;

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	function defaultEqualityCheck(a, b) {
	  return a === b;
	}

	function defaultMemoize(func) {
	  var equalityCheck = arguments.length <= 1 || arguments[1] === undefined ? defaultEqualityCheck : arguments[1];

	  var lastArgs = null;
	  var lastResult = null;
	  return function () {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    if (lastArgs === null || lastArgs.length !== args.length || !args.every(function (value, index) {
	      return equalityCheck(value, lastArgs[index]);
	    })) {
	      lastResult = func.apply(undefined, args);
	    }
	    lastArgs = args;
	    return lastResult;
	  };
	}

	function getDependencies(funcs) {
	  var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;

	  if (!dependencies.every(function (dep) {
	    return typeof dep === 'function';
	  })) {
	    var dependencyTypes = dependencies.map(function (dep) {
	      return typeof dep;
	    }).join(', ');
	    throw new Error('Selector creators expect all input-selectors to be functions, ' + ('instead received the following types: [' + dependencyTypes + ']'));
	  }

	  return dependencies;
	}

	function createSelectorCreator(memoize) {
	  for (var _len2 = arguments.length, memoizeOptions = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	    memoizeOptions[_key2 - 1] = arguments[_key2];
	  }

	  return function () {
	    for (var _len3 = arguments.length, funcs = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	      funcs[_key3] = arguments[_key3];
	    }

	    var recomputations = 0;
	    var resultFunc = funcs.pop();
	    var dependencies = getDependencies(funcs);

	    var memoizedResultFunc = memoize.apply(undefined, [function () {
	      recomputations++;
	      return resultFunc.apply(undefined, arguments);
	    }].concat(memoizeOptions));

	    var selector = function selector(state, props) {
	      for (var _len4 = arguments.length, args = Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
	        args[_key4 - 2] = arguments[_key4];
	      }

	      var params = dependencies.map(function (dependency) {
	        return dependency.apply(undefined, [state, props].concat(args));
	      });
	      return memoizedResultFunc.apply(undefined, _toConsumableArray(params));
	    };

	    selector.resultFunc = resultFunc;
	    selector.recomputations = function () {
	      return recomputations;
	    };
	    selector.resetRecomputations = function () {
	      return recomputations = 0;
	    };
	    return selector;
	  };
	}

	var createSelector = exports.createSelector = createSelectorCreator(defaultMemoize);

	function createStructuredSelector(selectors) {
	  var selectorCreator = arguments.length <= 1 || arguments[1] === undefined ? createSelector : arguments[1];

	  if (typeof selectors !== 'object') {
	    throw new Error('createStructuredSelector expects first argument to be an object ' + ('where each property is a selector, instead received a ' + typeof selectors));
	  }
	  var objectKeys = Object.keys(selectors);
	  return selectorCreator(objectKeys.map(function (key) {
	    return selectors[key];
	  }), function () {
	    for (var _len5 = arguments.length, values = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
	      values[_key5] = arguments[_key5];
	    }

	    return values.reduce(function (composition, value, index) {
	      composition[objectKeys[index]] = value;
	      return composition;
	    }, {});
	  });
	}

/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory(__webpack_require__(2), __webpack_require__(6));
		else if(typeof define === 'function' && define.amd)
			define(["react", "react-dom"], factory);
		else if(typeof exports === 'object')
			exports["ReactAutocomplete"] = factory(require("react"), require("react-dom"));
		else
			root["ReactAutocomplete"] = factory(root["React"], root["ReactDOM"]);
	})(this, function(__WEBPACK_EXTERNAL_MODULE_7__, __WEBPACK_EXTERNAL_MODULE_8__) {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};

	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {

	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;

	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};

	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;

	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}


	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;

	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;

	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";

	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

		var PropTypes = __webpack_require__(5);
		var React = __webpack_require__(7);
		var ReactDOM = __webpack_require__(8);
		var classnames = __webpack_require__(1);

		var Autocomplete = function (_React$Component) {
		  _inherits(Autocomplete, _React$Component);

		  function Autocomplete(props) {
		    _classCallCheck(this, Autocomplete);

		    var _this = _possibleConstructorReturn(this, (Autocomplete.__proto__ || Object.getPrototypeOf(Autocomplete)).call(this, props));

		    _initialiseProps.call(_this);

		    var searchTerm = props.searchTerm ? props.searchTerm : props.value ? props.value.title : '';

		    _this.state = {
		      results: [],
		      showResults: false,
		      showResultsInProgress: false,
		      searchTerm: searchTerm,
		      focusedValue: null
		    };
		    return _this;
		  }

		  _createClass(Autocomplete, [{
		    key: 'render',
		    value: function render() {
		      var className = classnames(this.props.className, 'react-autocomplete-Autocomplete', this.state.showResults ? 'react-autocomplete-Autocomplete--resultsShown' : undefined);
		      var style = {
		        position: 'relative',
		        outline: 'none'
		      };
		      return React.createElement(
		        'div',
		        {
		          tabIndex: '1',
		          className: className,
		          onFocus: this.onFocus,
		          onBlur: this.onBlur,
		          style: style },
		        React.createElement('input', {
		          ref: 'search',
		          className: 'react-autocomplete-Autocomplete__search',
		          style: { width: '100%' },
		          onClick: this.showAllResults,
		          onChange: this.onQueryChange,
		          onFocus: this.onSearchInputFocus,
		          onBlur: this.onQueryBlur,
		          onKeyDown: this.onQueryKeyDown,
		          value: this.state.searchTerm
		        }),
		        React.createElement(Results, {
		          className: 'react-autocomplete-Autocomplete__results',
		          onSelect: this.onValueChange,
		          onFocus: this.onValueFocus,
		          results: this.state.results,
		          focusedValue: this.state.focusedValue,
		          show: this.state.showResults,
		          renderer: this.props.resultRenderer,
		          label: this.props.label,
		          resultIdentifier: this.props.resultIdentifier
		        })
		      );
		    }
		  }, {
		    key: 'componentWillReceiveProps',
		    value: function componentWillReceiveProps(nextProps) {
		      var searchTerm = nextProps.searchTerm ? nextProps.searchTerm : nextProps.value ? nextProps.value.title : '';
		      this.setState({ searchTerm: searchTerm });
		    }
		  }, {
		    key: 'componentWillMount',
		    value: function componentWillMount() {
		      this.blurTimer = null;
		    }

		    /**
		      * Show results for a search term value.
		      *
		      * This method doesn't update search term value itself.
		      *
		      * @param {Search} searchTerm
		      */

		  }]);

		  return Autocomplete;
		}(React.Component);

		Autocomplete.displayName = 'Autocomplete';
		Autocomplete.propTypes = {
		  options: PropTypes.any,
		  search: PropTypes.func,
		  resultRenderer: PropTypes.oneOfType([PropTypes.element, PropTypes.func]),
		  value: PropTypes.object,
		  onChange: PropTypes.func,
		  onError: PropTypes.func,
		  onFocus: PropTypes.func
		};
		Autocomplete.defaultProps = { search: searchArray };

		var _initialiseProps = function _initialiseProps() {
		  var _this4 = this;

		  this.getResultIdentifier = function (result) {
		    if (_this4.props.resultIdentifier === undefined) {
		      return result.id;
		    } else {
		      return result[_this4.props.resultIdentifier];
		    }
		  };

		  this.showResults = function (searchTerm) {
		    _this4.setState({ showResultsInProgress: true });
		    _this4.props.search(_this4.props.options, searchTerm.trim(), _this4.onSearchComplete);
		  };

		  this.showAllResults = function () {
		    if (!_this4.state.showResultsInProgress && !_this4.state.showResults) {
		      _this4.showResults('');
		    }
		  };

		  this.onValueChange = function (value) {
		    var state = {
		      value: value,
		      showResults: false
		    };

		    if (value) {
		      state.searchTerm = value.title;
		    }

		    _this4.setState(state);

		    if (_this4.props.onChange) {
		      _this4.props.onChange(value);
		    }
		  };

		  this.onSearchComplete = function (err, results) {
		    if (err) {
		      if (_this4.props.onError) {
		        _this4.props.onError(err);
		      } else {
		        throw err;
		      }
		    }

		    _this4.setState({
		      showResultsInProgress: false,
		      showResults: true,
		      results: results
		    });
		  };

		  this.onValueFocus = function (value) {
		    _this4.setState({ focusedValue: value });
		  };

		  this.onQueryChange = function (e) {
		    var searchTerm = e.target.value;
		    _this4.setState({
		      searchTerm: searchTerm,
		      focusedValue: null
		    });
		    _this4.showResults(searchTerm);
		  };

		  this.onFocus = function () {
		    if (_this4.blurTimer) {
		      clearTimeout(_this4.blurTimer);
		      _this4.blurTimer = null;
		    }
		    _this4.refs.search.focus();
		  };

		  this.onSearchInputFocus = function () {
		    if (_this4.props.onFocus) {
		      _this4.props.onFocus();
		    }

		    _this4.showAllResults();
		  };

		  this.onBlur = function () {
		    // wrap in setTimeout so we can catch a click on results
		    _this4.blurTimer = setTimeout(function () {
		      _this4.setState({ showResults: false });
		    }, 100);
		  };

		  this.onQueryKeyDown = function (e) {

		    if (e.key === 'Enter') {
		      e.preventDefault();
		      if (_this4.state.focusedValue) {
		        _this4.onValueChange(_this4.state.focusedValue);
		      }
		    } else if (e.key === 'ArrowUp' && _this4.state.showResults) {
		      e.preventDefault();
		      var prevIdx = Math.max(_this4.focusedValueIndex() - 1, 0);
		      _this4.setState({
		        focusedValue: _this4.state.results[prevIdx]
		      });
		    } else if (e.key === 'ArrowDown') {
		      e.preventDefault();
		      if (_this4.state.showResults) {
		        var nextIdx = Math.min(_this4.focusedValueIndex() + (_this4.state.showResults ? 1 : 0), _this4.state.results.length - 1);
		        _this4.setState({
		          showResults: true,
		          focusedValue: _this4.state.results[nextIdx]
		        });
		      } else {
		        _this4.showAllResults();
		      }
		    }
		  };

		  this.focusedValueIndex = function () {
		    if (!_this4.state.focusedValue) {
		      return -1;
		    }
		    for (var i = 0, len = _this4.state.results.length; i < len; i++) {
		      if (_this4.getResultIdentifier(_this4.state.results[i]) === _this4.getResultIdentifier(_this4.state.focusedValue)) {
		        return i;
		      }
		    }
		    return -1;
		  };
		};

		var Results = function (_React$Component2) {
		  _inherits(Results, _React$Component2);

		  function Results() {
		    var _ref;

		    var _temp, _this2, _ret;

		    _classCallCheck(this, Results);

		    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
		      args[_key] = arguments[_key];
		    }

		    return _ret = (_temp = (_this2 = _possibleConstructorReturn(this, (_ref = Results.__proto__ || Object.getPrototypeOf(Results)).call.apply(_ref, [this].concat(args))), _this2), _this2.getResultIdentifier = function (result) {
		      if (_this2.props.resultIdentifier === undefined) {
		        if (!result.id) {
		          throw Error("id property not found on result. You must specify a resultIdentifier and pass as props to autocomplete component");
		        }
		        return result.id;
		      } else {
		        return result[_this2.props.resultIdentifier];
		      }
		    }, _this2.renderResult = function (result) {
		      var focused = _this2.props.focusedValue && _this2.getResultIdentifier(_this2.props.focusedValue) === _this2.getResultIdentifier(result);
		      var Renderer = _this2.props.renderer || Result;
		      return React.createElement(Renderer, {
		        ref: focused ? "focused" : undefined,
		        key: _this2.getResultIdentifier(result),
		        result: result,
		        focused: focused,
		        onMouseEnter: _this2.onMouseEnterResult,
		        onClick: _this2.props.onSelect,
		        label: _this2.props.label });
		    }, _this2.scrollToFocused = function () {
		      var focused = _this2.refs && _this2.refs.focused;
		      if (focused) {
		        var containerNode = ReactDOM.findDOMNode(_this2);
		        var scroll = containerNode.scrollTop;
		        var height = containerNode.offsetHeight;

		        var node = ReactDOM.findDOMNode(focused);
		        var top = node.offsetTop;
		        var bottom = top + node.offsetHeight;

		        // we update ignoreFocus to true if we change the scroll position so
		        // the mouseover event triggered because of that won't have an
		        // effect
		        if (top < scroll) {
		          _this2.ignoreFocus = true;
		          containerNode.scrollTop = top;
		        } else if (bottom - scroll > height) {
		          _this2.ignoreFocus = true;
		          containerNode.scrollTop = bottom - height;
		        }
		      }
		    }, _this2.onMouseEnterResult = function (e, result) {
		      // check if we need to prevent the next onFocus event because it was
		      // probably caused by a mouseover due to scroll position change
		      if (_this2.ignoreFocus) {
		        _this2.ignoreFocus = false;
		      } else {
		        // we need to make sure focused node is visible
		        // for some reason mouse events fire on visible nodes due to
		        // box-shadow
		        var containerNode = ReactDOM.findDOMNode(_this2);
		        var scroll = containerNode.scrollTop;
		        var height = containerNode.offsetHeight;

		        var node = e.target;
		        var top = node.offsetTop;
		        var bottom = top + node.offsetHeight;

		        if (bottom > scroll && top < scroll + height) {
		          _this2.props.onFocus(result);
		        }
		      }
		    }, _temp), _possibleConstructorReturn(_this2, _ret);
		  }

		  _createClass(Results, [{
		    key: 'render',
		    value: function render() {
		      var style = {
		        display: this.props.show ? 'block' : 'none',
		        position: 'absolute',
		        listStyleType: 'none'
		      };
		      var className = this.props.className;


		      return React.createElement(
		        'ul',
		        { style: style, className: className + " react-autocomplete-Results" },
		        this.props.results.map(this.renderResult)
		      );
		    }
		  }, {
		    key: 'componentDidUpdate',
		    value: function componentDidUpdate() {
		      this.scrollToFocused();
		    }
		  }, {
		    key: 'componentDidMount',
		    value: function componentDidMount() {
		      this.scrollToFocused();
		    }
		  }, {
		    key: 'componentWillMount',
		    value: function componentWillMount() {
		      this.ignoreFocus = false;
		    }
		  }]);

		  return Results;
		}(React.Component);

		var Result = function (_React$Component3) {
		  _inherits(Result, _React$Component3);

		  function Result() {
		    var _ref2;

		    var _temp2, _this3, _ret2;

		    _classCallCheck(this, Result);

		    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
		      args[_key2] = arguments[_key2];
		    }

		    return _ret2 = (_temp2 = (_this3 = _possibleConstructorReturn(this, (_ref2 = Result.__proto__ || Object.getPrototypeOf(Result)).call.apply(_ref2, [this].concat(args))), _this3), _this3.getLabel = function (result) {
		      if (typeof _this3.props.label === 'function') {
		        return _this3.props.label(result);
		      } else if (typeof _this3.props.label === 'string') {
		        return result[_this3.props.label];
		      }
		    }, _this3.onClick = function () {
		      _this3.props.onClick(_this3.props.result);
		    }, _this3.onMouseEnter = function (e) {
		      if (_this3.props.onMouseEnter) {
		        _this3.props.onMouseEnter(e, _this3.props.result);
		      }
		    }, _temp2), _possibleConstructorReturn(_this3, _ret2);
		  }

		  _createClass(Result, [{
		    key: 'render',
		    value: function render() {
		      var className = classnames({
		        'react-autocomplete-Result': true,
		        'react-autocomplete-Result--active': this.props.focused
		      });

		      return React.createElement(
		        'li',
		        {
		          style: { listStyleType: 'none' },
		          className: className,
		          onClick: this.onClick,
		          onMouseEnter: this.onMouseEnter },
		        React.createElement(
		          'a',
		          null,
		          this.getLabel(this.props.result)
		        )
		      );
		    }
		  }, {
		    key: 'shouldComponentUpdate',
		    value: function shouldComponentUpdate(nextProps) {
		      return nextProps.result.id !== this.props.result.id || nextProps.focused !== this.props.focused;
		    }
		  }]);

		  return Result;
		}(React.Component);

		/**
		* Search options using specified search term treating options as an array
		* of candidates.
		*
		* @param {Array.<Object>} options
		* @param {String} searchTerm
		* @param {Callback} cb
		*/


		Result.defaultProps = {
		  label: function label(result) {
		    return result.title;
		  }
		};
		function searchArray(options, searchTerm, cb) {
		  if (!options) {
		    return cb(null, []);
		  }

		  searchTerm = new RegExp(searchTerm, 'i');

		  var results = [];

		  for (var i = 0, len = options.length; i < len; i++) {
		    if (searchTerm.exec(options[i].title)) {
		      results.push(options[i]);
		    }
		  }

		  cb(null, results);
		}

		module.exports = Autocomplete;

	/***/ }),
	/* 1 */
	/***/ (function(module, exports, __webpack_require__) {

		var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
		  Copyright (c) 2015 Jed Watson.
		  Licensed under the MIT License (MIT), see
		  http://jedwatson.github.io/classnames
		*/

		function classNames() {
			var classes = '';
			var arg;

			for (var i = 0; i < arguments.length; i++) {
				arg = arguments[i];
				if (!arg) {
					continue;
				}

				if ('string' === typeof arg || 'number' === typeof arg) {
					classes += ' ' + arg;
				} else if (Object.prototype.toString.call(arg) === '[object Array]') {
					classes += ' ' + classNames.apply(null, arg);
				} else if ('object' === typeof arg) {
					for (var key in arg) {
						if (!arg.hasOwnProperty(key) || !arg[key]) {
							continue;
						}
						classes += ' ' + key;
					}
				}
			}
			return classes.substr(1);
		}

		// safely export classNames for node / browserify
		if (typeof module !== 'undefined' && module.exports) {
			module.exports = classNames;
		}

		// safely export classNames for RequireJS
		if (true) {
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return classNames;
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}


	/***/ }),
	/* 2 */
	/***/ (function(module, exports) {

		"use strict";

		/**
		 * Copyright (c) 2013-present, Facebook, Inc.
		 *
		 * This source code is licensed under the MIT license found in the
		 * LICENSE file in the root directory of this source tree.
		 *
		 * 
		 */

		function makeEmptyFunction(arg) {
		  return function () {
		    return arg;
		  };
		}

		/**
		 * This function accepts and discards inputs; it has no side effects. This is
		 * primarily useful idiomatically for overridable function endpoints which
		 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
		 */
		var emptyFunction = function emptyFunction() {};

		emptyFunction.thatReturns = makeEmptyFunction;
		emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
		emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
		emptyFunction.thatReturnsNull = makeEmptyFunction(null);
		emptyFunction.thatReturnsThis = function () {
		  return this;
		};
		emptyFunction.thatReturnsArgument = function (arg) {
		  return arg;
		};

		module.exports = emptyFunction;

	/***/ }),
	/* 3 */
	/***/ (function(module, exports, __webpack_require__) {

		/**
		 * Copyright (c) 2013-present, Facebook, Inc.
		 *
		 * This source code is licensed under the MIT license found in the
		 * LICENSE file in the root directory of this source tree.
		 *
		 */

		'use strict';

		/**
		 * Use invariant() to assert state which your program assumes to be true.
		 *
		 * Provide sprintf-style format (only %s is supported) and arguments
		 * to provide information about what broke and what you were
		 * expecting.
		 *
		 * The invariant message will be stripped in production, but the invariant
		 * will remain to ensure logic does not differ in production.
		 */

		var validateFormat = function validateFormat(format) {};

		if (false) {
		  validateFormat = function validateFormat(format) {
		    if (format === undefined) {
		      throw new Error('invariant requires an error message argument');
		    }
		  };
		}

		function invariant(condition, format, a, b, c, d, e, f) {
		  validateFormat(format);

		  if (!condition) {
		    var error;
		    if (format === undefined) {
		      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
		    } else {
		      var args = [a, b, c, d, e, f];
		      var argIndex = 0;
		      error = new Error(format.replace(/%s/g, function () {
		        return args[argIndex++];
		      }));
		      error.name = 'Invariant Violation';
		    }

		    error.framesToPop = 1; // we don't care about invariant's own frame
		    throw error;
		  }
		}

		module.exports = invariant;

	/***/ }),
	/* 4 */
	/***/ (function(module, exports, __webpack_require__) {

		/**
		 * Copyright (c) 2013-present, Facebook, Inc.
		 *
		 * This source code is licensed under the MIT license found in the
		 * LICENSE file in the root directory of this source tree.
		 */

		'use strict';

		var emptyFunction = __webpack_require__(2);
		var invariant = __webpack_require__(3);
		var ReactPropTypesSecret = __webpack_require__(6);

		module.exports = function() {
		  function shim(props, propName, componentName, location, propFullName, secret) {
		    if (secret === ReactPropTypesSecret) {
		      // It is still safe when called from React.
		      return;
		    }
		    invariant(
		      false,
		      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
		      'Use PropTypes.checkPropTypes() to call them. ' +
		      'Read more at http://fb.me/use-check-prop-types'
		    );
		  };
		  shim.isRequired = shim;
		  function getShim() {
		    return shim;
		  };
		  // Important!
		  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
		  var ReactPropTypes = {
		    array: shim,
		    bool: shim,
		    func: shim,
		    number: shim,
		    object: shim,
		    string: shim,
		    symbol: shim,

		    any: shim,
		    arrayOf: getShim,
		    element: shim,
		    instanceOf: getShim,
		    node: shim,
		    objectOf: getShim,
		    oneOf: getShim,
		    oneOfType: getShim,
		    shape: getShim,
		    exact: getShim
		  };

		  ReactPropTypes.checkPropTypes = emptyFunction;
		  ReactPropTypes.PropTypes = ReactPropTypes;

		  return ReactPropTypes;
		};


	/***/ }),
	/* 5 */
	/***/ (function(module, exports, __webpack_require__) {

		/**
		 * Copyright (c) 2013-present, Facebook, Inc.
		 *
		 * This source code is licensed under the MIT license found in the
		 * LICENSE file in the root directory of this source tree.
		 */

		if (false) {
		  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
		    Symbol.for &&
		    Symbol.for('react.element')) ||
		    0xeac7;

		  var isValidElement = function(object) {
		    return typeof object === 'object' &&
		      object !== null &&
		      object.$$typeof === REACT_ELEMENT_TYPE;
		  };

		  // By explicitly using `prop-types` you are opting into new development behavior.
		  // http://fb.me/prop-types-in-prod
		  var throwOnDirectAccess = true;
		  module.exports = require('./factoryWithTypeCheckers')(isValidElement, throwOnDirectAccess);
		} else {
		  // By explicitly using `prop-types` you are opting into new production behavior.
		  // http://fb.me/prop-types-in-prod
		  module.exports = __webpack_require__(4)();
		}


	/***/ }),
	/* 6 */
	/***/ (function(module, exports) {

		/**
		 * Copyright (c) 2013-present, Facebook, Inc.
		 *
		 * This source code is licensed under the MIT license found in the
		 * LICENSE file in the root directory of this source tree.
		 */

		'use strict';

		var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

		module.exports = ReactPropTypesSecret;


	/***/ }),
	/* 7 */
	/***/ (function(module, exports) {

		module.exports = __WEBPACK_EXTERNAL_MODULE_7__;

	/***/ }),
	/* 8 */
	/***/ (function(module, exports) {

		module.exports = __WEBPACK_EXTERNAL_MODULE_8__;

	/***/ })
	/******/ ])
	});
	;

/***/ }),
/* 371 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(372);


/***/ }),
/* 372 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _ponyfill = __webpack_require__(373);

	var _ponyfill2 = _interopRequireDefault(_ponyfill);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var root; /* global window */


	if (typeof self !== 'undefined') {
	  root = self;
	} else if (typeof window !== 'undefined') {
	  root = window;
	} else if (typeof (window) !== 'undefined') {
	  root = (window);
	} else if (true) {
	  root = module;
	} else {
	  root = Function('return this')();
	}

	var result = (0, _ponyfill2['default'])(root);
	exports['default'] = result;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 373 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports['default'] = symbolObservablePonyfill;
	function symbolObservablePonyfill(root) {
		var result;
		var _Symbol = root.Symbol;

		if (typeof _Symbol === 'function') {
			if (_Symbol.observable) {
				result = _Symbol.observable;
			} else {
				result = _Symbol('observable');
				_Symbol.observable = result;
			}
		} else {
			result = '@@observable';
		}

		return result;
	};

/***/ }),
/* 374 */
/***/ (function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(20),
	    root = __webpack_require__(11);

	/* Built-in method references that are verified to be native. */
	var DataView = getNative(root, 'DataView');

	module.exports = DataView;


/***/ }),
/* 375 */
[1582, 423, 424, 425, 426, 427],
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(20),
	    root = __webpack_require__(11);

	/* Built-in method references that are verified to be native. */
	var Promise = getNative(root, 'Promise');

	module.exports = Promise;


/***/ }),
/* 377 */
[1602, 20, 11],
/* 378 */
[1607, 82, 447, 448],
/* 379 */
/***/ (function(module, exports, __webpack_require__) {

	var root = __webpack_require__(11);

	/** Built-in value references. */
	var Uint8Array = root.Uint8Array;

	module.exports = Uint8Array;


/***/ }),
/* 380 */
/***/ (function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(20),
	    root = __webpack_require__(11);

	/* Built-in method references that are verified to be native. */
	var WeakMap = getNative(root, 'WeakMap');

	module.exports = WeakMap;


/***/ }),
/* 381 */
/***/ (function(module, exports) {

	/**
	 * A specialized version of `baseAggregator` for arrays.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} setter The function to set `accumulator` values.
	 * @param {Function} iteratee The iteratee to transform keys.
	 * @param {Object} accumulator The initial aggregated object.
	 * @returns {Function} Returns `accumulator`.
	 */
	function arrayAggregator(array, setter, iteratee, accumulator) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    var value = array[index];
	    setter(accumulator, value, iteratee(value), array);
	  }
	  return accumulator;
	}

	module.exports = arrayAggregator;


/***/ }),
/* 382 */
275,
/* 383 */
[1616, 405, 163, 12, 165, 158, 167],
/* 384 */
71,
/* 385 */
277,
/* 386 */
/***/ (function(module, exports) {

	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}

	module.exports = arraySome;


/***/ }),
/* 387 */
/***/ (function(module, exports, __webpack_require__) {

	var baseEach = __webpack_require__(389);

	/**
	 * Aggregates elements of `collection` on `accumulator` with keys transformed
	 * by `iteratee` and values set by `setter`.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} setter The function to set `accumulator` values.
	 * @param {Function} iteratee The iteratee to transform keys.
	 * @param {Object} accumulator The initial aggregated object.
	 * @returns {Function} Returns `accumulator`.
	 */
	function baseAggregator(collection, setter, iteratee, accumulator) {
	  baseEach(collection, function(value, key, collection) {
	    setter(accumulator, value, iteratee(value), collection);
	  });
	  return accumulator;
	}

	module.exports = baseAggregator;


/***/ }),
/* 388 */
[1628, 413],
/* 389 */
/***/ (function(module, exports, __webpack_require__) {

	var baseForOwn = __webpack_require__(391),
	    createBaseEach = __webpack_require__(411);

	/**
	 * The base implementation of `_.forEach` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array|Object} Returns `collection`.
	 */
	var baseEach = createBaseEach(baseForOwn);

	module.exports = baseEach;


/***/ }),
/* 390 */
/***/ (function(module, exports, __webpack_require__) {

	var createBaseFor = __webpack_require__(412);

	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor = createBaseFor();

	module.exports = baseFor;


/***/ }),
/* 391 */
/***/ (function(module, exports, __webpack_require__) {

	var baseFor = __webpack_require__(390),
	    keys = __webpack_require__(87);

	/**
	 * The base implementation of `_.forOwn` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 */
	function baseForOwn(object, iteratee) {
	  return object && baseFor(object, iteratee, keys);
	}

	module.exports = baseForOwn;


/***/ }),
/* 392 */
/***/ (function(module, exports, __webpack_require__) {

	var arrayPush = __webpack_require__(385),
	    isArray = __webpack_require__(12);

	/**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	  var result = keysFunc(object);
	  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
	}

	module.exports = baseGetAllKeys;


/***/ }),
/* 393 */
/***/ (function(module, exports) {

	/**
	 * The base implementation of `_.hasIn` without support for deep paths.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {Array|string} key The key to check.
	 * @returns {boolean} Returns `true` if `key` exists, else `false`.
	 */
	function baseHasIn(object, key) {
	  return object != null && key in Object(object);
	}

	module.exports = baseHasIn;


/***/ }),
/* 394 */
[1639, 31, 32],
/* 395 */
/***/ (function(module, exports, __webpack_require__) {

	var Stack = __webpack_require__(152),
	    equalArrays = __webpack_require__(156),
	    equalByTag = __webpack_require__(414),
	    equalObjects = __webpack_require__(415),
	    getTag = __webpack_require__(420),
	    isArray = __webpack_require__(12),
	    isBuffer = __webpack_require__(165),
	    isTypedArray = __webpack_require__(167);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    objectTag = '[object Object]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = objIsArr ? arrayTag : getTag(object),
	      othTag = othIsArr ? arrayTag : getTag(other);

	  objTag = objTag == argsTag ? objectTag : objTag;
	  othTag = othTag == argsTag ? objectTag : othTag;

	  var objIsObj = objTag == objectTag,
	      othIsObj = othTag == objectTag,
	      isSameTag = objTag == othTag;

	  if (isSameTag && isBuffer(object)) {
	    if (!isBuffer(other)) {
	      return false;
	    }
	    objIsArr = true;
	    objIsObj = false;
	  }
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack);
	    return (objIsArr || isTypedArray(object))
	      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
	      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	  }
	  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;

	      stack || (stack = new Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack);
	  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	}

	module.exports = baseIsEqualDeep;


/***/ }),
/* 396 */
/***/ (function(module, exports, __webpack_require__) {

	var Stack = __webpack_require__(152),
	    baseIsEqual = __webpack_require__(154);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * The base implementation of `_.isMatch` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @param {Object} source The object of property values to match.
	 * @param {Array} matchData The property names, values, and compare flags to match.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 */
	function baseIsMatch(object, source, matchData, customizer) {
	  var index = matchData.length,
	      length = index,
	      noCustomizer = !customizer;

	  if (object == null) {
	    return !length;
	  }
	  object = Object(object);
	  while (index--) {
	    var data = matchData[index];
	    if ((noCustomizer && data[2])
	          ? data[1] !== object[data[0]]
	          : !(data[0] in object)
	        ) {
	      return false;
	    }
	  }
	  while (++index < length) {
	    data = matchData[index];
	    var key = data[0],
	        objValue = object[key],
	        srcValue = data[1];

	    if (noCustomizer && data[2]) {
	      if (objValue === undefined && !(key in object)) {
	        return false;
	      }
	    } else {
	      var stack = new Stack;
	      if (customizer) {
	        var result = customizer(objValue, srcValue, key, object, source, stack);
	      }
	      if (!(result === undefined
	            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
	            : result
	          )) {
	        return false;
	      }
	    }
	  }
	  return true;
	}

	module.exports = baseIsMatch;


/***/ }),
/* 397 */
[1641, 166, 429, 85, 161],
/* 398 */
[1649, 31, 84, 32],
/* 399 */
/***/ (function(module, exports, __webpack_require__) {

	var baseMatches = __webpack_require__(401),
	    baseMatchesProperty = __webpack_require__(402),
	    identity = __webpack_require__(459),
	    isArray = __webpack_require__(12),
	    property = __webpack_require__(461);

	/**
	 * The base implementation of `_.iteratee`.
	 *
	 * @private
	 * @param {*} [value=_.identity] The value to convert to an iteratee.
	 * @returns {Function} Returns the iteratee.
	 */
	function baseIteratee(value) {
	  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	  if (typeof value == 'function') {
	    return value;
	  }
	  if (value == null) {
	    return identity;
	  }
	  if (typeof value == 'object') {
	    return isArray(value)
	      ? baseMatchesProperty(value[0], value[1])
	      : baseMatches(value);
	  }
	  return property(value);
	}

	module.exports = baseIteratee;


/***/ }),
/* 400 */
/***/ (function(module, exports, __webpack_require__) {

	var isPrototype = __webpack_require__(430),
	    nativeKeys = __webpack_require__(443);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = baseKeys;


/***/ }),
/* 401 */
/***/ (function(module, exports, __webpack_require__) {

	var baseIsMatch = __webpack_require__(396),
	    getMatchData = __webpack_require__(417),
	    matchesStrictComparable = __webpack_require__(160);

	/**
	 * The base implementation of `_.matches` which doesn't clone `source`.
	 *
	 * @private
	 * @param {Object} source The object of property values to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatches(source) {
	  var matchData = getMatchData(source);
	  if (matchData.length == 1 && matchData[0][2]) {
	    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
	  }
	  return function(object) {
	    return object === source || baseIsMatch(object, source, matchData);
	  };
	}

	module.exports = baseMatches;


/***/ }),
/* 402 */
/***/ (function(module, exports, __webpack_require__) {

	var baseIsEqual = __webpack_require__(154),
	    get = __webpack_require__(456),
	    hasIn = __webpack_require__(458),
	    isKey = __webpack_require__(83),
	    isStrictComparable = __webpack_require__(159),
	    matchesStrictComparable = __webpack_require__(160),
	    toKey = __webpack_require__(55);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	 *
	 * @private
	 * @param {string} path The path of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatchesProperty(path, srcValue) {
	  if (isKey(path) && isStrictComparable(srcValue)) {
	    return matchesStrictComparable(toKey(path), srcValue);
	  }
	  return function(object) {
	    var objValue = get(object, path);
	    return (objValue === undefined && objValue === srcValue)
	      ? hasIn(object, path)
	      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
	  };
	}

	module.exports = baseMatchesProperty;


/***/ }),
/* 403 */
/***/ (function(module, exports) {

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}

	module.exports = baseProperty;


/***/ }),
/* 404 */
/***/ (function(module, exports, __webpack_require__) {

	var baseGet = __webpack_require__(153);

	/**
	 * A specialized version of `baseProperty` which supports deep paths.
	 *
	 * @private
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function basePropertyDeep(path) {
	  return function(object) {
	    return baseGet(object, path);
	  };
	}

	module.exports = basePropertyDeep;


/***/ }),
/* 405 */
288,
/* 406 */
/***/ (function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(51),
	    arrayMap = __webpack_require__(384),
	    isArray = __webpack_require__(12),
	    isSymbol = __webpack_require__(86);

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isArray(value)) {
	    // Recursively convert values (susceptible to call stack limits).
	    return arrayMap(value, baseToString) + '';
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	module.exports = baseToString;


/***/ }),
/* 407 */
72,
/* 408 */
73,
/* 409 */
[1652, 11],
/* 410 */
/***/ (function(module, exports, __webpack_require__) {

	var arrayAggregator = __webpack_require__(381),
	    baseAggregator = __webpack_require__(387),
	    baseIteratee = __webpack_require__(399),
	    isArray = __webpack_require__(12);

	/**
	 * Creates a function like `_.groupBy`.
	 *
	 * @private
	 * @param {Function} setter The function to set accumulator values.
	 * @param {Function} [initializer] The accumulator object initializer.
	 * @returns {Function} Returns the new aggregator function.
	 */
	function createAggregator(setter, initializer) {
	  return function(collection, iteratee) {
	    var func = isArray(collection) ? arrayAggregator : baseAggregator,
	        accumulator = initializer ? initializer() : {};

	    return func(collection, setter, baseIteratee(iteratee, 2), accumulator);
	  };
	}

	module.exports = createAggregator;


/***/ }),
/* 411 */
/***/ (function(module, exports, __webpack_require__) {

	var isArrayLike = __webpack_require__(164);

	/**
	 * Creates a `baseEach` or `baseEachRight` function.
	 *
	 * @private
	 * @param {Function} eachFunc The function to iterate over a collection.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseEach(eachFunc, fromRight) {
	  return function(collection, iteratee) {
	    if (collection == null) {
	      return collection;
	    }
	    if (!isArrayLike(collection)) {
	      return eachFunc(collection, iteratee);
	    }
	    var length = collection.length,
	        index = fromRight ? length : -1,
	        iterable = Object(collection);

	    while ((fromRight ? index-- : ++index < length)) {
	      if (iteratee(iterable[index], index, iterable) === false) {
	        break;
	      }
	    }
	    return collection;
	  };
	}

	module.exports = createBaseEach;


/***/ }),
/* 412 */
/***/ (function(module, exports) {

	/**
	 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseFor(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var index = -1,
	        iterable = Object(object),
	        props = keysFunc(object),
	        length = props.length;

	    while (length--) {
	      var key = props[fromRight ? length : ++index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}

	module.exports = createBaseFor;


/***/ }),
/* 413 */
[1658, 20],
/* 414 */
/***/ (function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(51),
	    Uint8Array = __webpack_require__(379),
	    eq = __webpack_require__(162),
	    equalArrays = __webpack_require__(156),
	    mapToArray = __webpack_require__(441),
	    setToArray = __webpack_require__(449);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/** `Object#toString` result references. */
	var boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]';

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	  switch (tag) {
	    case dataViewTag:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;

	    case arrayBufferTag:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	        return false;
	      }
	      return true;

	    case boolTag:
	    case dateTag:
	    case numberTag:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq(+object, +other);

	    case errorTag:
	      return object.name == other.name && object.message == other.message;

	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');

	    case mapTag:
	      var convert = mapToArray;

	    case setTag:
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
	      convert || (convert = setToArray);

	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= COMPARE_UNORDERED_FLAG;

	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	      stack['delete'](object);
	      return result;

	    case symbolTag:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }
	  }
	  return false;
	}

	module.exports = equalByTag;


/***/ }),
/* 415 */
/***/ (function(module, exports, __webpack_require__) {

	var getAllKeys = __webpack_require__(416);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1;

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      objProps = getAllKeys(object),
	      objLength = objProps.length,
	      othProps = getAllKeys(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	      return false;
	    }
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(object);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);

	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}

	module.exports = equalObjects;


/***/ }),
/* 416 */
/***/ (function(module, exports, __webpack_require__) {

	var baseGetAllKeys = __webpack_require__(392),
	    getSymbols = __webpack_require__(419),
	    keys = __webpack_require__(87);

	/**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeys(object) {
	  return baseGetAllKeys(object, keys, getSymbols);
	}

	module.exports = getAllKeys;


/***/ }),
/* 417 */
/***/ (function(module, exports, __webpack_require__) {

	var isStrictComparable = __webpack_require__(159),
	    keys = __webpack_require__(87);

	/**
	 * Gets the property names, values, and compare flags of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the match data of `object`.
	 */
	function getMatchData(object) {
	  var result = keys(object),
	      length = result.length;

	  while (length--) {
	    var key = result[length],
	        value = object[key];

	    result[length] = [key, value, isStrictComparable(value)];
	  }
	  return result;
	}

	module.exports = getMatchData;


/***/ }),
/* 418 */
[1672, 51],
/* 419 */
/***/ (function(module, exports, __webpack_require__) {

	var arrayFilter = __webpack_require__(382),
	    stubArray = __webpack_require__(462);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
	  if (object == null) {
	    return [];
	  }
	  object = Object(object);
	  return arrayFilter(nativeGetSymbols(object), function(symbol) {
	    return propertyIsEnumerable.call(object, symbol);
	  });
	};

	module.exports = getSymbols;


/***/ }),
/* 420 */
/***/ (function(module, exports, __webpack_require__) {

	var DataView = __webpack_require__(374),
	    Map = __webpack_require__(81),
	    Promise = __webpack_require__(376),
	    Set = __webpack_require__(377),
	    WeakMap = __webpack_require__(380),
	    baseGetTag = __webpack_require__(31),
	    toSource = __webpack_require__(161);

	/** `Object#toString` result references. */
	var mapTag = '[object Map]',
	    objectTag = '[object Object]',
	    promiseTag = '[object Promise]',
	    setTag = '[object Set]',
	    weakMapTag = '[object WeakMap]';

	var dataViewTag = '[object DataView]';

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map),
	    promiseCtorString = toSource(Promise),
	    setCtorString = toSource(Set),
	    weakMapCtorString = toSource(WeakMap);

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = baseGetTag;

	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	    (Map && getTag(new Map) != mapTag) ||
	    (Promise && getTag(Promise.resolve()) != promiseTag) ||
	    (Set && getTag(new Set) != setTag) ||
	    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	  getTag = function(value) {
	    var result = baseGetTag(value),
	        Ctor = result == objectTag ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : '';

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag;
	        case mapCtorString: return mapTag;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag;
	        case weakMapCtorString: return weakMapTag;
	      }
	    }
	    return result;
	  };
	}

	module.exports = getTag;


/***/ }),
/* 421 */
298,
/* 422 */
/***/ (function(module, exports, __webpack_require__) {

	var castPath = __webpack_require__(155),
	    isArguments = __webpack_require__(163),
	    isArray = __webpack_require__(12),
	    isIndex = __webpack_require__(158),
	    isLength = __webpack_require__(84),
	    toKey = __webpack_require__(55);

	/**
	 * Checks if `path` exists on `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @param {Function} hasFunc The function to check properties.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 */
	function hasPath(object, path, hasFunc) {
	  path = castPath(path, object);

	  var index = -1,
	      length = path.length,
	      result = false;

	  while (++index < length) {
	    var key = toKey(path[index]);
	    if (!(result = object != null && hasFunc(object, key))) {
	      break;
	    }
	    object = object[key];
	  }
	  if (result || ++index != length) {
	    return result;
	  }
	  length = object == null ? 0 : object.length;
	  return !!length && isLength(length) && isIndex(key, length) &&
	    (isArray(object) || isArguments(object));
	}

	module.exports = hasPath;


/***/ }),
/* 423 */
[1675, 54],
/* 424 */
300,
/* 425 */
[1683, 54],
/* 426 */
[1685, 54],
/* 427 */
[1692, 54],
/* 428 */
306,
/* 429 */
[1696, 409],
/* 430 */
308,
/* 431 */
309,
/* 432 */
[1704, 52],
/* 433 */
[1709, 52],
/* 434 */
[1712, 52],
/* 435 */
[1719, 52],
/* 436 */
[1722, 375, 50, 81],
/* 437 */
[1729, 53],
/* 438 */
[1730, 53],
/* 439 */
[1739, 53],
/* 440 */
[1741, 53],
/* 441 */
/***/ (function(module, exports) {

	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);

	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}

	module.exports = mapToArray;


/***/ }),
/* 442 */
/***/ (function(module, exports, __webpack_require__) {

	var memoize = __webpack_require__(460);

	/** Used as the maximum memoize cache size. */
	var MAX_MEMOIZE_SIZE = 500;

	/**
	 * A specialized version of `_.memoize` which clears the memoized function's
	 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	 *
	 * @private
	 * @param {Function} func The function to have its output memoized.
	 * @returns {Function} Returns the new memoized function.
	 */
	function memoizeCapped(func) {
	  var result = memoize(func, function(key) {
	    if (cache.size === MAX_MEMOIZE_SIZE) {
	      cache.clear();
	    }
	    return key;
	  });

	  var cache = result.cache;
	  return result;
	}

	module.exports = memoizeCapped;


/***/ }),
/* 443 */
/***/ (function(module, exports, __webpack_require__) {

	var overArg = __webpack_require__(446);

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = overArg(Object.keys, Object);

	module.exports = nativeKeys;


/***/ }),
/* 444 */
[1750, 157],
/* 445 */
321,
/* 446 */
322,
/* 447 */
324,
/* 448 */
325,
/* 449 */
126,
/* 450 */
/***/ (function(module, exports, __webpack_require__) {

	var ListCache = __webpack_require__(50);

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache;
	  this.size = 0;
	}

	module.exports = stackClear;


/***/ }),
/* 451 */
/***/ (function(module, exports) {

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  var data = this.__data__,
	      result = data['delete'](key);

	  this.size = data.size;
	  return result;
	}

	module.exports = stackDelete;


/***/ }),
/* 452 */
/***/ (function(module, exports) {

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}

	module.exports = stackGet;


/***/ }),
/* 453 */
/***/ (function(module, exports) {

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}

	module.exports = stackHas;


/***/ }),
/* 454 */
/***/ (function(module, exports, __webpack_require__) {

	var ListCache = __webpack_require__(50),
	    Map = __webpack_require__(81),
	    MapCache = __webpack_require__(82);

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var data = this.__data__;
	  if (data instanceof ListCache) {
	    var pairs = data.__data__;
	    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new MapCache(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}

	module.exports = stackSet;


/***/ }),
/* 455 */
/***/ (function(module, exports, __webpack_require__) {

	var memoizeCapped = __webpack_require__(442);

	/** Used to match property names within property paths. */
	var reLeadingDot = /^\./,
	    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;

	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath = memoizeCapped(function(string) {
	  var result = [];
	  if (reLeadingDot.test(string)) {
	    result.push('');
	  }
	  string.replace(rePropName, function(match, number, quote, string) {
	    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	});

	module.exports = stringToPath;


/***/ }),
/* 456 */
/***/ (function(module, exports, __webpack_require__) {

	var baseGet = __webpack_require__(153);

	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is returned in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : baseGet(object, path);
	  return result === undefined ? defaultValue : result;
	}

	module.exports = get;


/***/ }),
/* 457 */
/***/ (function(module, exports, __webpack_require__) {

	var baseAssignValue = __webpack_require__(388),
	    createAggregator = __webpack_require__(410);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Creates an object composed of keys generated from the results of running
	 * each element of `collection` thru `iteratee`. The order of grouped values
	 * is determined by the order they occur in `collection`. The corresponding
	 * value of each key is an array of elements responsible for generating the
	 * key. The iteratee is invoked with one argument: (value).
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	 * @returns {Object} Returns the composed aggregate object.
	 * @example
	 *
	 * _.groupBy([6.1, 4.2, 6.3], Math.floor);
	 * // => { '4': [4.2], '6': [6.1, 6.3] }
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.groupBy(['one', 'two', 'three'], 'length');
	 * // => { '3': ['one', 'two'], '5': ['three'] }
	 */
	var groupBy = createAggregator(function(result, value, key) {
	  if (hasOwnProperty.call(result, key)) {
	    result[key].push(value);
	  } else {
	    baseAssignValue(result, key, [value]);
	  }
	});

	module.exports = groupBy;


/***/ }),
/* 458 */
/***/ (function(module, exports, __webpack_require__) {

	var baseHasIn = __webpack_require__(393),
	    hasPath = __webpack_require__(422);

	/**
	 * Checks if `path` is a direct or inherited property of `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 * @example
	 *
	 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	 *
	 * _.hasIn(object, 'a');
	 * // => true
	 *
	 * _.hasIn(object, 'a.b');
	 * // => true
	 *
	 * _.hasIn(object, ['a', 'b']);
	 * // => true
	 *
	 * _.hasIn(object, 'b');
	 * // => false
	 */
	function hasIn(object, path) {
	  return object != null && hasPath(object, path, baseHasIn);
	}

	module.exports = hasIn;


/***/ }),
/* 459 */
127,
/* 460 */
[1785, 82],
/* 461 */
/***/ (function(module, exports, __webpack_require__) {

	var baseProperty = __webpack_require__(403),
	    basePropertyDeep = __webpack_require__(404),
	    isKey = __webpack_require__(83),
	    toKey = __webpack_require__(55);

	/**
	 * Creates a function that returns the value at `path` of a given object.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 * @example
	 *
	 * var objects = [
	 *   { 'a': { 'b': 2 } },
	 *   { 'a': { 'b': 1 } }
	 * ];
	 *
	 * _.map(objects, _.property('a.b'));
	 * // => [2, 1]
	 *
	 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	 * // => [1, 2]
	 */
	function property(path) {
	  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
	}

	module.exports = property;


/***/ }),
/* 462 */
/***/ (function(module, exports) {

	/**
	 * This method returns a new empty array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {Array} Returns the new empty array.
	 * @example
	 *
	 * var arrays = _.times(2, _.stubArray);
	 *
	 * console.log(arrays);
	 * // => [[], []]
	 *
	 * console.log(arrays[0] === arrays[1]);
	 * // => false
	 */
	function stubArray() {
	  return [];
	}

	module.exports = stubArray;


/***/ }),
/* 463 */
338,
/* 464 */
/***/ (function(module, exports, __webpack_require__) {

	var baseToString = __webpack_require__(406);

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : baseToString(value);
	}

	module.exports = toString;


/***/ }),
/* 465 */
/***/ (function(module, exports, __webpack_require__) {

	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory(__webpack_require__(2), __webpack_require__(6));
		else if(typeof define === 'function' && define.amd)
			define(["react", "react-dom"], factory);
		else if(typeof exports === 'object')
			exports["ReactDataGrid"] = factory(require("react"), require("react-dom"));
		else
			root["ReactDataGrid"] = factory(root["React"], root["ReactDOM"]);
	})(this, function(__WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_5__) {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};

	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {

	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;

	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};

	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;

	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}


	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;

	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;

	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";

	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ((function(modules) {
		// Check all modules for deduplicated modules
		for(var i in modules) {
			if(Object.prototype.hasOwnProperty.call(modules, i)) {
				switch(typeof modules[i]) {
				case "function": break;
				case "object":
					// Module can be created from a template
					modules[i] = (function(_m) {
						var args = _m.slice(1), fn = modules[_m[0]];
						return function (a,b,c) {
							fn.apply(this, [a,b,c].concat(args));
						};
					}(modules[i]));
					break;
				default:
					// Module is a copy of another module
					modules[i] = modules[modules[i]];
					break;
				}
			}
		}
		return modules;
	}([
	/* 0 */
	/***/ (function(module, exports, __webpack_require__) {

		module.exports = __webpack_require__(209);


	/***/ }),
	/* 1 */,
	/* 2 */
	/***/ (function(module, exports) {

		module.exports = __WEBPACK_EXTERNAL_MODULE_2__;

	/***/ }),
	/* 3 */
	/***/ (function(module, exports, __webpack_require__) {

		/**
		 * Copyright (c) 2013-present, Facebook, Inc.
		 *
		 * This source code is licensed under the MIT license found in the
		 * LICENSE file in the root directory of this source tree.
		 */

		if (false) {
		  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
		    Symbol.for &&
		    Symbol.for('react.element')) ||
		    0xeac7;

		  var isValidElement = function(object) {
		    return typeof object === 'object' &&
		      object !== null &&
		      object.$$typeof === REACT_ELEMENT_TYPE;
		  };

		  // By explicitly using `prop-types` you are opting into new development behavior.
		  // http://fb.me/prop-types-in-prod
		  var throwOnDirectAccess = true;
		  module.exports = require('./factoryWithTypeCheckers')(isValidElement, throwOnDirectAccess);
		} else {
		  // By explicitly using `prop-types` you are opting into new production behavior.
		  // http://fb.me/prop-types-in-prod
		  module.exports = __webpack_require__(108)();
		}


	/***/ }),
	/* 4 */,
	/* 5 */
	/***/ (function(module, exports) {

		module.exports = __WEBPACK_EXTERNAL_MODULE_5__;

	/***/ }),
	/* 6 */,
	/* 7 */,
	/* 8 */
	/***/ (function(module, exports, __webpack_require__) {

		var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
		  Copyright (c) 2015 Jed Watson.
		  Licensed under the MIT License (MIT), see
		  http://jedwatson.github.io/classnames
		*/

		function classNames() {
			var classes = '';
			var arg;

			for (var i = 0; i < arguments.length; i++) {
				arg = arguments[i];
				if (!arg) {
					continue;
				}

				if ('string' === typeof arg || 'number' === typeof arg) {
					classes += ' ' + arg;
				} else if (Object.prototype.toString.call(arg) === '[object Array]') {
					classes += ' ' + classNames.apply(null, arg);
				} else if ('object' === typeof arg) {
					for (var key in arg) {
						if (!arg.hasOwnProperty(key) || !arg[key]) {
							continue;
						}
						classes += ' ' + key;
					}
				}
			}
			return classes.substr(1);
		}

		// safely export classNames for node / browserify
		if (typeof module !== 'undefined' && module.exports) {
			module.exports = classNames;
		}

		// safely export classNames for RequireJS
		if (true) {
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return classNames;
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		}


	/***/ }),
	/* 9 */
	/***/ (function(module, exports) {

		'use strict';

		module.exports = {
		  getColumn: function getColumn(columns, idx) {
		    if (Array.isArray(columns)) {
		      return columns[idx];
		    } else if (typeof Immutable !== 'undefined') {
		      return columns.get(idx);
		    }
		  },
		  spliceColumn: function spliceColumn(metrics, idx, column) {
		    if (Array.isArray(metrics.columns)) {
		      metrics.columns.splice(idx, 1, column);
		    } else if (typeof Immutable !== 'undefined') {
		      metrics.columns = metrics.columns.splice(idx, 1, column);
		    }
		    return metrics;
		  },
		  getSize: function getSize(columns) {
		    if (Array.isArray(columns)) {
		      return columns.length;
		    } else if (typeof Immutable !== 'undefined') {
		      return columns.size;
		    }
		  },


		  // Logic extented to allow for functions to be passed down in column.editable
		  // this allows us to deicde whether we can be edting from a cell level
		  canEdit: function canEdit(col, rowData, enableCellSelect) {
		    if (!col) return false;
		    if (col.editable != null && typeof col.editable === 'function') {
		      return enableCellSelect === true && col.editable(rowData);
		    }
		    return enableCellSelect === true && (!!col.editor || !!col.editable);
		  },
		  getValue: function getValue(column, property) {
		    var value = void 0;
		    if (column.toJSON && column.get) {
		      value = column.get(property);
		    } else {
		      value = column[property];
		    }
		    return value;
		  }
		};

	/***/ }),
	/* 10 */
	/***/ (function(module, exports, __webpack_require__) {

		/**
		 * Copyright (c) 2013-present, Facebook, Inc.
		 *
		 * This source code is licensed under the MIT license found in the
		 * LICENSE file in the root directory of this source tree.
		 *
		 */

		'use strict';

		var React = __webpack_require__(2);
		var factory = __webpack_require__(104);

		if (typeof React === 'undefined') {
		  throw Error(
		    'create-react-class could not find the React object. If you are using script tags, ' +
		      'make sure that React is being loaded before create-react-class.'
		  );
		}

		// Hack to grab NoopUpdateQueue from isomorphic React
		var ReactNoopUpdateQueue = new React.Component().updater;

		module.exports = factory(
		  React.Component,
		  React.isValidElement,
		  ReactNoopUpdateQueue
		);


	/***/ }),
	/* 11 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		var _propTypes = __webpack_require__(3);

		var _propTypes2 = _interopRequireDefault(_propTypes);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		module.exports = {
		  selected: _propTypes2['default'].object.isRequired,
		  copied: _propTypes2['default'].object,
		  dragged: _propTypes2['default'].object,
		  onCellClick: _propTypes2['default'].func.isRequired,
		  onCellDoubleClick: _propTypes2['default'].func.isRequired,
		  onCommit: _propTypes2['default'].func.isRequired,
		  onCommitCancel: _propTypes2['default'].func.isRequired,
		  handleDragEnterRow: _propTypes2['default'].func.isRequired,
		  handleTerminateDrag: _propTypes2['default'].func.isRequired,
		  getCellActions: _propTypes2['default'].func
		};

	/***/ }),
	/* 12 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		var _propTypes = __webpack_require__(3);

		var _propTypes2 = _interopRequireDefault(_propTypes);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		var ExcelColumnShape = {
		  name: _propTypes2['default'].node.isRequired,
		  key: _propTypes2['default'].string.isRequired,
		  width: _propTypes2['default'].number.isRequired,
		  filterable: _propTypes2['default'].bool
		};

		module.exports = ExcelColumnShape;

	/***/ }),
	/* 13 */,
	/* 14 */,
	/* 15 */,
	/* 16 */,
	/* 17 */,
	/* 18 */
	/***/ (function(module, exports) {

		"use strict";

		function createObjectWithProperties(originalObj, properties) {
		  var result = {};
		  for (var _iterator = properties, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
		    var _ref;

		    if (_isArray) {
		      if (_i >= _iterator.length) break;
		      _ref = _iterator[_i++];
		    } else {
		      _i = _iterator.next();
		      if (_i.done) break;
		      _ref = _i.value;
		    }

		    var property = _ref;

		    if (originalObj[property]) {
		      result[property] = originalObj[property];
		    }
		  }
		  return result;
		}

		module.exports = createObjectWithProperties;

	/***/ }),
	/* 19 */
	/***/ (function(module, exports) {

		// removed by extract-text-webpack-plugin

	/***/ }),
	/* 20 */
	/***/ (function(module, exports, __webpack_require__) {

		/**
		 *  Copyright (c) 2014-2015, Facebook, Inc.
		 *  All rights reserved.
		 *
		 *  This source code is licensed under the BSD-style license found in the
		 *  LICENSE file in the root directory of this source tree. An additional grant
		 *  of patent rights can be found in the PATENTS file in the same directory.
		 */

		(function (global, factory) {
		   true ? module.exports = factory() :
		  typeof define === 'function' && define.amd ? define(factory) :
		  (global.Immutable = factory());
		}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;

		  function createClass(ctor, superClass) {
		    if (superClass) {
		      ctor.prototype = Object.create(superClass.prototype);
		    }
		    ctor.prototype.constructor = ctor;
		  }

		  function Iterable(value) {
		      return isIterable(value) ? value : Seq(value);
		    }


		  createClass(KeyedIterable, Iterable);
		    function KeyedIterable(value) {
		      return isKeyed(value) ? value : KeyedSeq(value);
		    }


		  createClass(IndexedIterable, Iterable);
		    function IndexedIterable(value) {
		      return isIndexed(value) ? value : IndexedSeq(value);
		    }


		  createClass(SetIterable, Iterable);
		    function SetIterable(value) {
		      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
		    }



		  function isIterable(maybeIterable) {
		    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
		  }

		  function isKeyed(maybeKeyed) {
		    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
		  }

		  function isIndexed(maybeIndexed) {
		    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
		  }

		  function isAssociative(maybeAssociative) {
		    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
		  }

		  function isOrdered(maybeOrdered) {
		    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
		  }

		  Iterable.isIterable = isIterable;
		  Iterable.isKeyed = isKeyed;
		  Iterable.isIndexed = isIndexed;
		  Iterable.isAssociative = isAssociative;
		  Iterable.isOrdered = isOrdered;

		  Iterable.Keyed = KeyedIterable;
		  Iterable.Indexed = IndexedIterable;
		  Iterable.Set = SetIterable;


		  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
		  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
		  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
		  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

		  // Used for setting prototype methods that IE8 chokes on.
		  var DELETE = 'delete';

		  // Constants describing the size of trie nodes.
		  var SHIFT = 5; // Resulted in best performance after ______?
		  var SIZE = 1 << SHIFT;
		  var MASK = SIZE - 1;

		  // A consistent shared value representing "not set" which equals nothing other
		  // than itself, and nothing that could be provided externally.
		  var NOT_SET = {};

		  // Boolean references, Rough equivalent of `bool &`.
		  var CHANGE_LENGTH = { value: false };
		  var DID_ALTER = { value: false };

		  function MakeRef(ref) {
		    ref.value = false;
		    return ref;
		  }

		  function SetRef(ref) {
		    ref && (ref.value = true);
		  }

		  // A function which returns a value representing an "owner" for transient writes
		  // to tries. The return value will only ever equal itself, and will not equal
		  // the return of any subsequent call of this function.
		  function OwnerID() {}

		  // http://jsperf.com/copy-array-inline
		  function arrCopy(arr, offset) {
		    offset = offset || 0;
		    var len = Math.max(0, arr.length - offset);
		    var newArr = new Array(len);
		    for (var ii = 0; ii < len; ii++) {
		      newArr[ii] = arr[ii + offset];
		    }
		    return newArr;
		  }

		  function ensureSize(iter) {
		    if (iter.size === undefined) {
		      iter.size = iter.__iterate(returnTrue);
		    }
		    return iter.size;
		  }

		  function wrapIndex(iter, index) {
		    // This implements "is array index" which the ECMAString spec defines as:
		    //
		    //     A String property name P is an array index if and only if
		    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
		    //     to 2^32âˆ’1.
		    //
		    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
		    if (typeof index !== 'number') {
		      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
		      if ('' + uint32Index !== index || uint32Index === 4294967295) {
		        return NaN;
		      }
		      index = uint32Index;
		    }
		    return index < 0 ? ensureSize(iter) + index : index;
		  }

		  function returnTrue() {
		    return true;
		  }

		  function wholeSlice(begin, end, size) {
		    return (begin === 0 || (size !== undefined && begin <= -size)) &&
		      (end === undefined || (size !== undefined && end >= size));
		  }

		  function resolveBegin(begin, size) {
		    return resolveIndex(begin, size, 0);
		  }

		  function resolveEnd(end, size) {
		    return resolveIndex(end, size, size);
		  }

		  function resolveIndex(index, size, defaultIndex) {
		    return index === undefined ?
		      defaultIndex :
		      index < 0 ?
		        Math.max(0, size + index) :
		        size === undefined ?
		          index :
		          Math.min(size, index);
		  }

		  /* global Symbol */

		  var ITERATE_KEYS = 0;
		  var ITERATE_VALUES = 1;
		  var ITERATE_ENTRIES = 2;

		  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
		  var FAUX_ITERATOR_SYMBOL = '@@iterator';

		  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;


		  function Iterator(next) {
		      this.next = next;
		    }

		    Iterator.prototype.toString = function() {
		      return '[Iterator]';
		    };


		  Iterator.KEYS = ITERATE_KEYS;
		  Iterator.VALUES = ITERATE_VALUES;
		  Iterator.ENTRIES = ITERATE_ENTRIES;

		  Iterator.prototype.inspect =
		  Iterator.prototype.toSource = function () { return this.toString(); }
		  Iterator.prototype[ITERATOR_SYMBOL] = function () {
		    return this;
		  };


		  function iteratorValue(type, k, v, iteratorResult) {
		    var value = type === 0 ? k : type === 1 ? v : [k, v];
		    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {
		      value: value, done: false
		    });
		    return iteratorResult;
		  }

		  function iteratorDone() {
		    return { value: undefined, done: true };
		  }

		  function hasIterator(maybeIterable) {
		    return !!getIteratorFn(maybeIterable);
		  }

		  function isIterator(maybeIterator) {
		    return maybeIterator && typeof maybeIterator.next === 'function';
		  }

		  function getIterator(iterable) {
		    var iteratorFn = getIteratorFn(iterable);
		    return iteratorFn && iteratorFn.call(iterable);
		  }

		  function getIteratorFn(iterable) {
		    var iteratorFn = iterable && (
		      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
		      iterable[FAUX_ITERATOR_SYMBOL]
		    );
		    if (typeof iteratorFn === 'function') {
		      return iteratorFn;
		    }
		  }

		  function isArrayLike(value) {
		    return value && typeof value.length === 'number';
		  }

		  createClass(Seq, Iterable);
		    function Seq(value) {
		      return value === null || value === undefined ? emptySequence() :
		        isIterable(value) ? value.toSeq() : seqFromValue(value);
		    }

		    Seq.of = function(/*...values*/) {
		      return Seq(arguments);
		    };

		    Seq.prototype.toSeq = function() {
		      return this;
		    };

		    Seq.prototype.toString = function() {
		      return this.__toString('Seq {', '}');
		    };

		    Seq.prototype.cacheResult = function() {
		      if (!this._cache && this.__iterateUncached) {
		        this._cache = this.entrySeq().toArray();
		        this.size = this._cache.length;
		      }
		      return this;
		    };

		    // abstract __iterateUncached(fn, reverse)

		    Seq.prototype.__iterate = function(fn, reverse) {
		      return seqIterate(this, fn, reverse, true);
		    };

		    // abstract __iteratorUncached(type, reverse)

		    Seq.prototype.__iterator = function(type, reverse) {
		      return seqIterator(this, type, reverse, true);
		    };



		  createClass(KeyedSeq, Seq);
		    function KeyedSeq(value) {
		      return value === null || value === undefined ?
		        emptySequence().toKeyedSeq() :
		        isIterable(value) ?
		          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :
		          keyedSeqFromValue(value);
		    }

		    KeyedSeq.prototype.toKeyedSeq = function() {
		      return this;
		    };



		  createClass(IndexedSeq, Seq);
		    function IndexedSeq(value) {
		      return value === null || value === undefined ? emptySequence() :
		        !isIterable(value) ? indexedSeqFromValue(value) :
		        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
		    }

		    IndexedSeq.of = function(/*...values*/) {
		      return IndexedSeq(arguments);
		    };

		    IndexedSeq.prototype.toIndexedSeq = function() {
		      return this;
		    };

		    IndexedSeq.prototype.toString = function() {
		      return this.__toString('Seq [', ']');
		    };

		    IndexedSeq.prototype.__iterate = function(fn, reverse) {
		      return seqIterate(this, fn, reverse, false);
		    };

		    IndexedSeq.prototype.__iterator = function(type, reverse) {
		      return seqIterator(this, type, reverse, false);
		    };



		  createClass(SetSeq, Seq);
		    function SetSeq(value) {
		      return (
		        value === null || value === undefined ? emptySequence() :
		        !isIterable(value) ? indexedSeqFromValue(value) :
		        isKeyed(value) ? value.entrySeq() : value
		      ).toSetSeq();
		    }

		    SetSeq.of = function(/*...values*/) {
		      return SetSeq(arguments);
		    };

		    SetSeq.prototype.toSetSeq = function() {
		      return this;
		    };



		  Seq.isSeq = isSeq;
		  Seq.Keyed = KeyedSeq;
		  Seq.Set = SetSeq;
		  Seq.Indexed = IndexedSeq;

		  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';

		  Seq.prototype[IS_SEQ_SENTINEL] = true;



		  createClass(ArraySeq, IndexedSeq);
		    function ArraySeq(array) {
		      this._array = array;
		      this.size = array.length;
		    }

		    ArraySeq.prototype.get = function(index, notSetValue) {
		      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
		    };

		    ArraySeq.prototype.__iterate = function(fn, reverse) {
		      var array = this._array;
		      var maxIndex = array.length - 1;
		      for (var ii = 0; ii <= maxIndex; ii++) {
		        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
		          return ii + 1;
		        }
		      }
		      return ii;
		    };

		    ArraySeq.prototype.__iterator = function(type, reverse) {
		      var array = this._array;
		      var maxIndex = array.length - 1;
		      var ii = 0;
		      return new Iterator(function() 
		        {return ii > maxIndex ?
		          iteratorDone() :
		          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}
		      );
		    };



		  createClass(ObjectSeq, KeyedSeq);
		    function ObjectSeq(object) {
		      var keys = Object.keys(object);
		      this._object = object;
		      this._keys = keys;
		      this.size = keys.length;
		    }

		    ObjectSeq.prototype.get = function(key, notSetValue) {
		      if (notSetValue !== undefined && !this.has(key)) {
		        return notSetValue;
		      }
		      return this._object[key];
		    };

		    ObjectSeq.prototype.has = function(key) {
		      return this._object.hasOwnProperty(key);
		    };

		    ObjectSeq.prototype.__iterate = function(fn, reverse) {
		      var object = this._object;
		      var keys = this._keys;
		      var maxIndex = keys.length - 1;
		      for (var ii = 0; ii <= maxIndex; ii++) {
		        var key = keys[reverse ? maxIndex - ii : ii];
		        if (fn(object[key], key, this) === false) {
		          return ii + 1;
		        }
		      }
		      return ii;
		    };

		    ObjectSeq.prototype.__iterator = function(type, reverse) {
		      var object = this._object;
		      var keys = this._keys;
		      var maxIndex = keys.length - 1;
		      var ii = 0;
		      return new Iterator(function()  {
		        var key = keys[reverse ? maxIndex - ii : ii];
		        return ii++ > maxIndex ?
		          iteratorDone() :
		          iteratorValue(type, key, object[key]);
		      });
		    };

		  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;


		  createClass(IterableSeq, IndexedSeq);
		    function IterableSeq(iterable) {
		      this._iterable = iterable;
		      this.size = iterable.length || iterable.size;
		    }

		    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {
		      if (reverse) {
		        return this.cacheResult().__iterate(fn, reverse);
		      }
		      var iterable = this._iterable;
		      var iterator = getIterator(iterable);
		      var iterations = 0;
		      if (isIterator(iterator)) {
		        var step;
		        while (!(step = iterator.next()).done) {
		          if (fn(step.value, iterations++, this) === false) {
		            break;
		          }
		        }
		      }
		      return iterations;
		    };

		    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {
		      if (reverse) {
		        return this.cacheResult().__iterator(type, reverse);
		      }
		      var iterable = this._iterable;
		      var iterator = getIterator(iterable);
		      if (!isIterator(iterator)) {
		        return new Iterator(iteratorDone);
		      }
		      var iterations = 0;
		      return new Iterator(function()  {
		        var step = iterator.next();
		        return step.done ? step : iteratorValue(type, iterations++, step.value);
		      });
		    };



		  createClass(IteratorSeq, IndexedSeq);
		    function IteratorSeq(iterator) {
		      this._iterator = iterator;
		      this._iteratorCache = [];
		    }

		    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {
		      if (reverse) {
		        return this.cacheResult().__iterate(fn, reverse);
		      }
		      var iterator = this._iterator;
		      var cache = this._iteratorCache;
		      var iterations = 0;
		      while (iterations < cache.length) {
		        if (fn(cache[iterations], iterations++, this) === false) {
		          return iterations;
		        }
		      }
		      var step;
		      while (!(step = iterator.next()).done) {
		        var val = step.value;
		        cache[iterations] = val;
		        if (fn(val, iterations++, this) === false) {
		          break;
		        }
		      }
		      return iterations;
		    };

		    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {
		      if (reverse) {
		        return this.cacheResult().__iterator(type, reverse);
		      }
		      var iterator = this._iterator;
		      var cache = this._iteratorCache;
		      var iterations = 0;
		      return new Iterator(function()  {
		        if (iterations >= cache.length) {
		          var step = iterator.next();
		          if (step.done) {
		            return step;
		          }
		          cache[iterations] = step.value;
		        }
		        return iteratorValue(type, iterations, cache[iterations++]);
		      });
		    };




		  // # pragma Helper functions

		  function isSeq(maybeSeq) {
		    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
		  }

		  var EMPTY_SEQ;

		  function emptySequence() {
		    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
		  }

		  function keyedSeqFromValue(value) {
		    var seq =
		      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :
		      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :
		      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :
		      typeof value === 'object' ? new ObjectSeq(value) :
		      undefined;
		    if (!seq) {
		      throw new TypeError(
		        'Expected Array or iterable object of [k, v] entries, '+
		        'or keyed object: ' + value
		      );
		    }
		    return seq;
		  }

		  function indexedSeqFromValue(value) {
		    var seq = maybeIndexedSeqFromValue(value);
		    if (!seq) {
		      throw new TypeError(
		        'Expected Array or iterable object of values: ' + value
		      );
		    }
		    return seq;
		  }

		  function seqFromValue(value) {
		    var seq = maybeIndexedSeqFromValue(value) ||
		      (typeof value === 'object' && new ObjectSeq(value));
		    if (!seq) {
		      throw new TypeError(
		        'Expected Array or iterable object of values, or keyed object: ' + value
		      );
		    }
		    return seq;
		  }

		  function maybeIndexedSeqFromValue(value) {
		    return (
		      isArrayLike(value) ? new ArraySeq(value) :
		      isIterator(value) ? new IteratorSeq(value) :
		      hasIterator(value) ? new IterableSeq(value) :
		      undefined
		    );
		  }

		  function seqIterate(seq, fn, reverse, useKeys) {
		    var cache = seq._cache;
		    if (cache) {
		      var maxIndex = cache.length - 1;
		      for (var ii = 0; ii <= maxIndex; ii++) {
		        var entry = cache[reverse ? maxIndex - ii : ii];
		        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
		          return ii + 1;
		        }
		      }
		      return ii;
		    }
		    return seq.__iterateUncached(fn, reverse);
		  }

		  function seqIterator(seq, type, reverse, useKeys) {
		    var cache = seq._cache;
		    if (cache) {
		      var maxIndex = cache.length - 1;
		      var ii = 0;
		      return new Iterator(function()  {
		        var entry = cache[reverse ? maxIndex - ii : ii];
		        return ii++ > maxIndex ?
		          iteratorDone() :
		          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
		      });
		    }
		    return seq.__iteratorUncached(type, reverse);
		  }

		  function fromJS(json, converter) {
		    return converter ?
		      fromJSWith(converter, json, '', {'': json}) :
		      fromJSDefault(json);
		  }

		  function fromJSWith(converter, json, key, parentJSON) {
		    if (Array.isArray(json)) {
		      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
		    }
		    if (isPlainObj(json)) {
		      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
		    }
		    return json;
		  }

		  function fromJSDefault(json) {
		    if (Array.isArray(json)) {
		      return IndexedSeq(json).map(fromJSDefault).toList();
		    }
		    if (isPlainObj(json)) {
		      return KeyedSeq(json).map(fromJSDefault).toMap();
		    }
		    return json;
		  }

		  function isPlainObj(value) {
		    return value && (value.constructor === Object || value.constructor === undefined);
		  }

		  /**
		   * An extension of the "same-value" algorithm as [described for use by ES6 Map
		   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
		   *
		   * NaN is considered the same as NaN, however -0 and 0 are considered the same
		   * value, which is different from the algorithm described by
		   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
		   *
		   * This is extended further to allow Objects to describe the values they
		   * represent, by way of `valueOf` or `equals` (and `hashCode`).
		   *
		   * Note: because of this extension, the key equality of Immutable.Map and the
		   * value equality of Immutable.Set will differ from ES6 Map and Set.
		   *
		   * ### Defining custom values
		   *
		   * The easiest way to describe the value an object represents is by implementing
		   * `valueOf`. For example, `Date` represents a value by returning a unix
		   * timestamp for `valueOf`:
		   *
		   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
		   *     var date2 = new Date(1234567890000);
		   *     date1.valueOf(); // 1234567890000
		   *     assert( date1 !== date2 );
		   *     assert( Immutable.is( date1, date2 ) );
		   *
		   * Note: overriding `valueOf` may have other implications if you use this object
		   * where JavaScript expects a primitive, such as implicit string coercion.
		   *
		   * For more complex types, especially collections, implementing `valueOf` may
		   * not be performant. An alternative is to implement `equals` and `hashCode`.
		   *
		   * `equals` takes another object, presumably of similar type, and returns true
		   * if the it is equal. Equality is symmetrical, so the same result should be
		   * returned if this and the argument are flipped.
		   *
		   *     assert( a.equals(b) === b.equals(a) );
		   *
		   * `hashCode` returns a 32bit integer number representing the object which will
		   * be used to determine how to store the value object in a Map or Set. You must
		   * provide both or neither methods, one must not exist without the other.
		   *
		   * Also, an important relationship between these methods must be upheld: if two
		   * values are equal, they *must* return the same hashCode. If the values are not
		   * equal, they might have the same hashCode; this is called a hash collision,
		   * and while undesirable for performance reasons, it is acceptable.
		   *
		   *     if (a.equals(b)) {
		   *       assert( a.hashCode() === b.hashCode() );
		   *     }
		   *
		   * All Immutable collections implement `equals` and `hashCode`.
		   *
		   */
		  function is(valueA, valueB) {
		    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
		      return true;
		    }
		    if (!valueA || !valueB) {
		      return false;
		    }
		    if (typeof valueA.valueOf === 'function' &&
		        typeof valueB.valueOf === 'function') {
		      valueA = valueA.valueOf();
		      valueB = valueB.valueOf();
		      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
		        return true;
		      }
		      if (!valueA || !valueB) {
		        return false;
		      }
		    }
		    if (typeof valueA.equals === 'function' &&
		        typeof valueB.equals === 'function' &&
		        valueA.equals(valueB)) {
		      return true;
		    }
		    return false;
		  }

		  function deepEqual(a, b) {
		    if (a === b) {
		      return true;
		    }

		    if (
		      !isIterable(b) ||
		      a.size !== undefined && b.size !== undefined && a.size !== b.size ||
		      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||
		      isKeyed(a) !== isKeyed(b) ||
		      isIndexed(a) !== isIndexed(b) ||
		      isOrdered(a) !== isOrdered(b)
		    ) {
		      return false;
		    }

		    if (a.size === 0 && b.size === 0) {
		      return true;
		    }

		    var notAssociative = !isAssociative(a);

		    if (isOrdered(a)) {
		      var entries = a.entries();
		      return b.every(function(v, k)  {
		        var entry = entries.next().value;
		        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
		      }) && entries.next().done;
		    }

		    var flipped = false;

		    if (a.size === undefined) {
		      if (b.size === undefined) {
		        if (typeof a.cacheResult === 'function') {
		          a.cacheResult();
		        }
		      } else {
		        flipped = true;
		        var _ = a;
		        a = b;
		        b = _;
		      }
		    }

		    var allEqual = true;
		    var bSize = b.__iterate(function(v, k)  {
		      if (notAssociative ? !a.has(v) :
		          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
		        allEqual = false;
		        return false;
		      }
		    });

		    return allEqual && a.size === bSize;
		  }

		  createClass(Repeat, IndexedSeq);

		    function Repeat(value, times) {
		      if (!(this instanceof Repeat)) {
		        return new Repeat(value, times);
		      }
		      this._value = value;
		      this.size = times === undefined ? Infinity : Math.max(0, times);
		      if (this.size === 0) {
		        if (EMPTY_REPEAT) {
		          return EMPTY_REPEAT;
		        }
		        EMPTY_REPEAT = this;
		      }
		    }

		    Repeat.prototype.toString = function() {
		      if (this.size === 0) {
		        return 'Repeat []';
		      }
		      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
		    };

		    Repeat.prototype.get = function(index, notSetValue) {
		      return this.has(index) ? this._value : notSetValue;
		    };

		    Repeat.prototype.includes = function(searchValue) {
		      return is(this._value, searchValue);
		    };

		    Repeat.prototype.slice = function(begin, end) {
		      var size = this.size;
		      return wholeSlice(begin, end, size) ? this :
		        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
		    };

		    Repeat.prototype.reverse = function() {
		      return this;
		    };

		    Repeat.prototype.indexOf = function(searchValue) {
		      if (is(this._value, searchValue)) {
		        return 0;
		      }
		      return -1;
		    };

		    Repeat.prototype.lastIndexOf = function(searchValue) {
		      if (is(this._value, searchValue)) {
		        return this.size;
		      }
		      return -1;
		    };

		    Repeat.prototype.__iterate = function(fn, reverse) {
		      for (var ii = 0; ii < this.size; ii++) {
		        if (fn(this._value, ii, this) === false) {
		          return ii + 1;
		        }
		      }
		      return ii;
		    };

		    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;
		      var ii = 0;
		      return new Iterator(function() 
		        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}
		      );
		    };

		    Repeat.prototype.equals = function(other) {
		      return other instanceof Repeat ?
		        is(this._value, other._value) :
		        deepEqual(other);
		    };


		  var EMPTY_REPEAT;

		  function invariant(condition, error) {
		    if (!condition) throw new Error(error);
		  }

		  createClass(Range, IndexedSeq);

		    function Range(start, end, step) {
		      if (!(this instanceof Range)) {
		        return new Range(start, end, step);
		      }
		      invariant(step !== 0, 'Cannot step a Range by 0');
		      start = start || 0;
		      if (end === undefined) {
		        end = Infinity;
		      }
		      step = step === undefined ? 1 : Math.abs(step);
		      if (end < start) {
		        step = -step;
		      }
		      this._start = start;
		      this._end = end;
		      this._step = step;
		      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
		      if (this.size === 0) {
		        if (EMPTY_RANGE) {
		          return EMPTY_RANGE;
		        }
		        EMPTY_RANGE = this;
		      }
		    }

		    Range.prototype.toString = function() {
		      if (this.size === 0) {
		        return 'Range []';
		      }
		      return 'Range [ ' +
		        this._start + '...' + this._end +
		        (this._step !== 1 ? ' by ' + this._step : '') +
		      ' ]';
		    };

		    Range.prototype.get = function(index, notSetValue) {
		      return this.has(index) ?
		        this._start + wrapIndex(this, index) * this._step :
		        notSetValue;
		    };

		    Range.prototype.includes = function(searchValue) {
		      var possibleIndex = (searchValue - this._start) / this._step;
		      return possibleIndex >= 0 &&
		        possibleIndex < this.size &&
		        possibleIndex === Math.floor(possibleIndex);
		    };

		    Range.prototype.slice = function(begin, end) {
		      if (wholeSlice(begin, end, this.size)) {
		        return this;
		      }
		      begin = resolveBegin(begin, this.size);
		      end = resolveEnd(end, this.size);
		      if (end <= begin) {
		        return new Range(0, 0);
		      }
		      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
		    };

		    Range.prototype.indexOf = function(searchValue) {
		      var offsetValue = searchValue - this._start;
		      if (offsetValue % this._step === 0) {
		        var index = offsetValue / this._step;
		        if (index >= 0 && index < this.size) {
		          return index
		        }
		      }
		      return -1;
		    };

		    Range.prototype.lastIndexOf = function(searchValue) {
		      return this.indexOf(searchValue);
		    };

		    Range.prototype.__iterate = function(fn, reverse) {
		      var maxIndex = this.size - 1;
		      var step = this._step;
		      var value = reverse ? this._start + maxIndex * step : this._start;
		      for (var ii = 0; ii <= maxIndex; ii++) {
		        if (fn(value, ii, this) === false) {
		          return ii + 1;
		        }
		        value += reverse ? -step : step;
		      }
		      return ii;
		    };

		    Range.prototype.__iterator = function(type, reverse) {
		      var maxIndex = this.size - 1;
		      var step = this._step;
		      var value = reverse ? this._start + maxIndex * step : this._start;
		      var ii = 0;
		      return new Iterator(function()  {
		        var v = value;
		        value += reverse ? -step : step;
		        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
		      });
		    };

		    Range.prototype.equals = function(other) {
		      return other instanceof Range ?
		        this._start === other._start &&
		        this._end === other._end &&
		        this._step === other._step :
		        deepEqual(this, other);
		    };


		  var EMPTY_RANGE;

		  createClass(Collection, Iterable);
		    function Collection() {
		      throw TypeError('Abstract');
		    }


		  createClass(KeyedCollection, Collection);function KeyedCollection() {}

		  createClass(IndexedCollection, Collection);function IndexedCollection() {}

		  createClass(SetCollection, Collection);function SetCollection() {}


		  Collection.Keyed = KeyedCollection;
		  Collection.Indexed = IndexedCollection;
		  Collection.Set = SetCollection;

		  var imul =
		    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?
		    Math.imul :
		    function imul(a, b) {
		      a = a | 0; // int
		      b = b | 0; // int
		      var c = a & 0xffff;
		      var d = b & 0xffff;
		      // Shift by 0 fixes the sign on the high part.
		      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int
		    };

		  // v8 has an optimization for storing 31-bit signed numbers.
		  // Values which have either 00 or 11 as the high order bits qualify.
		  // This function drops the highest order bit in a signed number, maintaining
		  // the sign bit.
		  function smi(i32) {
		    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);
		  }

		  function hash(o) {
		    if (o === false || o === null || o === undefined) {
		      return 0;
		    }
		    if (typeof o.valueOf === 'function') {
		      o = o.valueOf();
		      if (o === false || o === null || o === undefined) {
		        return 0;
		      }
		    }
		    if (o === true) {
		      return 1;
		    }
		    var type = typeof o;
		    if (type === 'number') {
		      if (o !== o || o === Infinity) {
		        return 0;
		      }
		      var h = o | 0;
		      if (h !== o) {
		        h ^= o * 0xFFFFFFFF;
		      }
		      while (o > 0xFFFFFFFF) {
		        o /= 0xFFFFFFFF;
		        h ^= o;
		      }
		      return smi(h);
		    }
		    if (type === 'string') {
		      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
		    }
		    if (typeof o.hashCode === 'function') {
		      return o.hashCode();
		    }
		    if (type === 'object') {
		      return hashJSObj(o);
		    }
		    if (typeof o.toString === 'function') {
		      return hashString(o.toString());
		    }
		    throw new Error('Value type ' + type + ' cannot be hashed.');
		  }

		  function cachedHashString(string) {
		    var hash = stringHashCache[string];
		    if (hash === undefined) {
		      hash = hashString(string);
		      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
		        STRING_HASH_CACHE_SIZE = 0;
		        stringHashCache = {};
		      }
		      STRING_HASH_CACHE_SIZE++;
		      stringHashCache[string] = hash;
		    }
		    return hash;
		  }

		  // http://jsperf.com/hashing-strings
		  function hashString(string) {
		    // This is the hash from JVM
		    // The hash code for a string is computed as
		    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
		    // where s[i] is the ith character of the string and n is the length of
		    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
		    // (exclusive) by dropping high bits.
		    var hash = 0;
		    for (var ii = 0; ii < string.length; ii++) {
		      hash = 31 * hash + string.charCodeAt(ii) | 0;
		    }
		    return smi(hash);
		  }

		  function hashJSObj(obj) {
		    var hash;
		    if (usingWeakMap) {
		      hash = weakMap.get(obj);
		      if (hash !== undefined) {
		        return hash;
		      }
		    }

		    hash = obj[UID_HASH_KEY];
		    if (hash !== undefined) {
		      return hash;
		    }

		    if (!canDefineProperty) {
		      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
		      if (hash !== undefined) {
		        return hash;
		      }

		      hash = getIENodeHash(obj);
		      if (hash !== undefined) {
		        return hash;
		      }
		    }

		    hash = ++objHashUID;
		    if (objHashUID & 0x40000000) {
		      objHashUID = 0;
		    }

		    if (usingWeakMap) {
		      weakMap.set(obj, hash);
		    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
		      throw new Error('Non-extensible objects are not allowed as keys.');
		    } else if (canDefineProperty) {
		      Object.defineProperty(obj, UID_HASH_KEY, {
		        'enumerable': false,
		        'configurable': false,
		        'writable': false,
		        'value': hash
		      });
		    } else if (obj.propertyIsEnumerable !== undefined &&
		               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
		      // Since we can't define a non-enumerable property on the object
		      // we'll hijack one of the less-used non-enumerable properties to
		      // save our hash on it. Since this is a function it will not show up in
		      // `JSON.stringify` which is what we want.
		      obj.propertyIsEnumerable = function() {
		        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
		      };
		      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
		    } else if (obj.nodeType !== undefined) {
		      // At this point we couldn't get the IE `uniqueID` to use as a hash
		      // and we couldn't use a non-enumerable property to exploit the
		      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
		      // itself.
		      obj[UID_HASH_KEY] = hash;
		    } else {
		      throw new Error('Unable to set a non-enumerable property on object.');
		    }

		    return hash;
		  }

		  // Get references to ES5 object methods.
		  var isExtensible = Object.isExtensible;

		  // True if Object.defineProperty works as expected. IE8 fails this test.
		  var canDefineProperty = (function() {
		    try {
		      Object.defineProperty({}, '@', {});
		      return true;
		    } catch (e) {
		      return false;
		    }
		  }());

		  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
		  // and avoid memory leaks from the IE cloneNode bug.
		  function getIENodeHash(node) {
		    if (node && node.nodeType > 0) {
		      switch (node.nodeType) {
		        case 1: // Element
		          return node.uniqueID;
		        case 9: // Document
		          return node.documentElement && node.documentElement.uniqueID;
		      }
		    }
		  }

		  // If possible, use a WeakMap.
		  var usingWeakMap = typeof WeakMap === 'function';
		  var weakMap;
		  if (usingWeakMap) {
		    weakMap = new WeakMap();
		  }

		  var objHashUID = 0;

		  var UID_HASH_KEY = '__immutablehash__';
		  if (typeof Symbol === 'function') {
		    UID_HASH_KEY = Symbol(UID_HASH_KEY);
		  }

		  var STRING_HASH_CACHE_MIN_STRLEN = 16;
		  var STRING_HASH_CACHE_MAX_SIZE = 255;
		  var STRING_HASH_CACHE_SIZE = 0;
		  var stringHashCache = {};

		  function assertNotInfinite(size) {
		    invariant(
		      size !== Infinity,
		      'Cannot perform this action with an infinite size.'
		    );
		  }

		  createClass(Map, KeyedCollection);

		    // @pragma Construction

		    function Map(value) {
		      return value === null || value === undefined ? emptyMap() :
		        isMap(value) && !isOrdered(value) ? value :
		        emptyMap().withMutations(function(map ) {
		          var iter = KeyedIterable(value);
		          assertNotInfinite(iter.size);
		          iter.forEach(function(v, k)  {return map.set(k, v)});
		        });
		    }

		    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);
		      return emptyMap().withMutations(function(map ) {
		        for (var i = 0; i < keyValues.length; i += 2) {
		          if (i + 1 >= keyValues.length) {
		            throw new Error('Missing value for key: ' + keyValues[i]);
		          }
		          map.set(keyValues[i], keyValues[i + 1]);
		        }
		      });
		    };

		    Map.prototype.toString = function() {
		      return this.__toString('Map {', '}');
		    };

		    // @pragma Access

		    Map.prototype.get = function(k, notSetValue) {
		      return this._root ?
		        this._root.get(0, undefined, k, notSetValue) :
		        notSetValue;
		    };

		    // @pragma Modification

		    Map.prototype.set = function(k, v) {
		      return updateMap(this, k, v);
		    };

		    Map.prototype.setIn = function(keyPath, v) {
		      return this.updateIn(keyPath, NOT_SET, function()  {return v});
		    };

		    Map.prototype.remove = function(k) {
		      return updateMap(this, k, NOT_SET);
		    };

		    Map.prototype.deleteIn = function(keyPath) {
		      return this.updateIn(keyPath, function()  {return NOT_SET});
		    };

		    Map.prototype.update = function(k, notSetValue, updater) {
		      return arguments.length === 1 ?
		        k(this) :
		        this.updateIn([k], notSetValue, updater);
		    };

		    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {
		      if (!updater) {
		        updater = notSetValue;
		        notSetValue = undefined;
		      }
		      var updatedValue = updateInDeepMap(
		        this,
		        forceIterator(keyPath),
		        notSetValue,
		        updater
		      );
		      return updatedValue === NOT_SET ? undefined : updatedValue;
		    };

		    Map.prototype.clear = function() {
		      if (this.size === 0) {
		        return this;
		      }
		      if (this.__ownerID) {
		        this.size = 0;
		        this._root = null;
		        this.__hash = undefined;
		        this.__altered = true;
		        return this;
		      }
		      return emptyMap();
		    };

		    // @pragma Composition

		    Map.prototype.merge = function(/*...iters*/) {
		      return mergeIntoMapWith(this, undefined, arguments);
		    };

		    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
		      return mergeIntoMapWith(this, merger, iters);
		    };

		    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
		      return this.updateIn(
		        keyPath,
		        emptyMap(),
		        function(m ) {return typeof m.merge === 'function' ?
		          m.merge.apply(m, iters) :
		          iters[iters.length - 1]}
		      );
		    };

		    Map.prototype.mergeDeep = function(/*...iters*/) {
		      return mergeIntoMapWith(this, deepMerger, arguments);
		    };

		    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
		      return mergeIntoMapWith(this, deepMergerWith(merger), iters);
		    };

		    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
		      return this.updateIn(
		        keyPath,
		        emptyMap(),
		        function(m ) {return typeof m.mergeDeep === 'function' ?
		          m.mergeDeep.apply(m, iters) :
		          iters[iters.length - 1]}
		      );
		    };

		    Map.prototype.sort = function(comparator) {
		      // Late binding
		      return OrderedMap(sortFactory(this, comparator));
		    };

		    Map.prototype.sortBy = function(mapper, comparator) {
		      // Late binding
		      return OrderedMap(sortFactory(this, comparator, mapper));
		    };

		    // @pragma Mutability

		    Map.prototype.withMutations = function(fn) {
		      var mutable = this.asMutable();
		      fn(mutable);
		      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
		    };

		    Map.prototype.asMutable = function() {
		      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
		    };

		    Map.prototype.asImmutable = function() {
		      return this.__ensureOwner();
		    };

		    Map.prototype.wasAltered = function() {
		      return this.__altered;
		    };

		    Map.prototype.__iterator = function(type, reverse) {
		      return new MapIterator(this, type, reverse);
		    };

		    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;
		      var iterations = 0;
		      this._root && this._root.iterate(function(entry ) {
		        iterations++;
		        return fn(entry[1], entry[0], this$0);
		      }, reverse);
		      return iterations;
		    };

		    Map.prototype.__ensureOwner = function(ownerID) {
		      if (ownerID === this.__ownerID) {
		        return this;
		      }
		      if (!ownerID) {
		        this.__ownerID = ownerID;
		        this.__altered = false;
		        return this;
		      }
		      return makeMap(this.size, this._root, ownerID, this.__hash);
		    };


		  function isMap(maybeMap) {
		    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
		  }

		  Map.isMap = isMap;

		  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';

		  var MapPrototype = Map.prototype;
		  MapPrototype[IS_MAP_SENTINEL] = true;
		  MapPrototype[DELETE] = MapPrototype.remove;
		  MapPrototype.removeIn = MapPrototype.deleteIn;


		  // #pragma Trie Nodes



		    function ArrayMapNode(ownerID, entries) {
		      this.ownerID = ownerID;
		      this.entries = entries;
		    }

		    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
		      var entries = this.entries;
		      for (var ii = 0, len = entries.length; ii < len; ii++) {
		        if (is(key, entries[ii][0])) {
		          return entries[ii][1];
		        }
		      }
		      return notSetValue;
		    };

		    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
		      var removed = value === NOT_SET;

		      var entries = this.entries;
		      var idx = 0;
		      for (var len = entries.length; idx < len; idx++) {
		        if (is(key, entries[idx][0])) {
		          break;
		        }
		      }
		      var exists = idx < len;

		      if (exists ? entries[idx][1] === value : removed) {
		        return this;
		      }

		      SetRef(didAlter);
		      (removed || !exists) && SetRef(didChangeSize);

		      if (removed && entries.length === 1) {
		        return; // undefined
		      }

		      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
		        return createNodes(ownerID, entries, key, value);
		      }

		      var isEditable = ownerID && ownerID === this.ownerID;
		      var newEntries = isEditable ? entries : arrCopy(entries);

		      if (exists) {
		        if (removed) {
		          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
		        } else {
		          newEntries[idx] = [key, value];
		        }
		      } else {
		        newEntries.push([key, value]);
		      }

		      if (isEditable) {
		        this.entries = newEntries;
		        return this;
		      }

		      return new ArrayMapNode(ownerID, newEntries);
		    };




		    function BitmapIndexedNode(ownerID, bitmap, nodes) {
		      this.ownerID = ownerID;
		      this.bitmap = bitmap;
		      this.nodes = nodes;
		    }

		    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
		      if (keyHash === undefined) {
		        keyHash = hash(key);
		      }
		      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));
		      var bitmap = this.bitmap;
		      return (bitmap & bit) === 0 ? notSetValue :
		        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);
		    };

		    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
		      if (keyHash === undefined) {
		        keyHash = hash(key);
		      }
		      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
		      var bit = 1 << keyHashFrag;
		      var bitmap = this.bitmap;
		      var exists = (bitmap & bit) !== 0;

		      if (!exists && value === NOT_SET) {
		        return this;
		      }

		      var idx = popCount(bitmap & (bit - 1));
		      var nodes = this.nodes;
		      var node = exists ? nodes[idx] : undefined;
		      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);

		      if (newNode === node) {
		        return this;
		      }

		      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
		        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
		      }

		      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
		        return nodes[idx ^ 1];
		      }

		      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
		        return newNode;
		      }

		      var isEditable = ownerID && ownerID === this.ownerID;
		      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
		      var newNodes = exists ? newNode ?
		        setIn(nodes, idx, newNode, isEditable) :
		        spliceOut(nodes, idx, isEditable) :
		        spliceIn(nodes, idx, newNode, isEditable);

		      if (isEditable) {
		        this.bitmap = newBitmap;
		        this.nodes = newNodes;
		        return this;
		      }

		      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
		    };




		    function HashArrayMapNode(ownerID, count, nodes) {
		      this.ownerID = ownerID;
		      this.count = count;
		      this.nodes = nodes;
		    }

		    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
		      if (keyHash === undefined) {
		        keyHash = hash(key);
		      }
		      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
		      var node = this.nodes[idx];
		      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
		    };

		    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
		      if (keyHash === undefined) {
		        keyHash = hash(key);
		      }
		      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
		      var removed = value === NOT_SET;
		      var nodes = this.nodes;
		      var node = nodes[idx];

		      if (removed && !node) {
		        return this;
		      }

		      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
		      if (newNode === node) {
		        return this;
		      }

		      var newCount = this.count;
		      if (!node) {
		        newCount++;
		      } else if (!newNode) {
		        newCount--;
		        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
		          return packNodes(ownerID, nodes, newCount, idx);
		        }
		      }

		      var isEditable = ownerID && ownerID === this.ownerID;
		      var newNodes = setIn(nodes, idx, newNode, isEditable);

		      if (isEditable) {
		        this.count = newCount;
		        this.nodes = newNodes;
		        return this;
		      }

		      return new HashArrayMapNode(ownerID, newCount, newNodes);
		    };




		    function HashCollisionNode(ownerID, keyHash, entries) {
		      this.ownerID = ownerID;
		      this.keyHash = keyHash;
		      this.entries = entries;
		    }

		    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
		      var entries = this.entries;
		      for (var ii = 0, len = entries.length; ii < len; ii++) {
		        if (is(key, entries[ii][0])) {
		          return entries[ii][1];
		        }
		      }
		      return notSetValue;
		    };

		    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
		      if (keyHash === undefined) {
		        keyHash = hash(key);
		      }

		      var removed = value === NOT_SET;

		      if (keyHash !== this.keyHash) {
		        if (removed) {
		          return this;
		        }
		        SetRef(didAlter);
		        SetRef(didChangeSize);
		        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
		      }

		      var entries = this.entries;
		      var idx = 0;
		      for (var len = entries.length; idx < len; idx++) {
		        if (is(key, entries[idx][0])) {
		          break;
		        }
		      }
		      var exists = idx < len;

		      if (exists ? entries[idx][1] === value : removed) {
		        return this;
		      }

		      SetRef(didAlter);
		      (removed || !exists) && SetRef(didChangeSize);

		      if (removed && len === 2) {
		        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
		      }

		      var isEditable = ownerID && ownerID === this.ownerID;
		      var newEntries = isEditable ? entries : arrCopy(entries);

		      if (exists) {
		        if (removed) {
		          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
		        } else {
		          newEntries[idx] = [key, value];
		        }
		      } else {
		        newEntries.push([key, value]);
		      }

		      if (isEditable) {
		        this.entries = newEntries;
		        return this;
		      }

		      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
		    };




		    function ValueNode(ownerID, keyHash, entry) {
		      this.ownerID = ownerID;
		      this.keyHash = keyHash;
		      this.entry = entry;
		    }

		    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
		      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
		    };

		    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
		      var removed = value === NOT_SET;
		      var keyMatch = is(key, this.entry[0]);
		      if (keyMatch ? value === this.entry[1] : removed) {
		        return this;
		      }

		      SetRef(didAlter);

		      if (removed) {
		        SetRef(didChangeSize);
		        return; // undefined
		      }

		      if (keyMatch) {
		        if (ownerID && ownerID === this.ownerID) {
		          this.entry[1] = value;
		          return this;
		        }
		        return new ValueNode(ownerID, this.keyHash, [key, value]);
		      }

		      SetRef(didChangeSize);
		      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
		    };



		  // #pragma Iterators

		  ArrayMapNode.prototype.iterate =
		  HashCollisionNode.prototype.iterate = function (fn, reverse) {
		    var entries = this.entries;
		    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
		      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
		        return false;
		      }
		    }
		  }

		  BitmapIndexedNode.prototype.iterate =
		  HashArrayMapNode.prototype.iterate = function (fn, reverse) {
		    var nodes = this.nodes;
		    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
		      var node = nodes[reverse ? maxIndex - ii : ii];
		      if (node && node.iterate(fn, reverse) === false) {
		        return false;
		      }
		    }
		  }

		  ValueNode.prototype.iterate = function (fn, reverse) {
		    return fn(this.entry);
		  }

		  createClass(MapIterator, Iterator);

		    function MapIterator(map, type, reverse) {
		      this._type = type;
		      this._reverse = reverse;
		      this._stack = map._root && mapIteratorFrame(map._root);
		    }

		    MapIterator.prototype.next = function() {
		      var type = this._type;
		      var stack = this._stack;
		      while (stack) {
		        var node = stack.node;
		        var index = stack.index++;
		        var maxIndex;
		        if (node.entry) {
		          if (index === 0) {
		            return mapIteratorValue(type, node.entry);
		          }
		        } else if (node.entries) {
		          maxIndex = node.entries.length - 1;
		          if (index <= maxIndex) {
		            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
		          }
		        } else {
		          maxIndex = node.nodes.length - 1;
		          if (index <= maxIndex) {
		            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
		            if (subNode) {
		              if (subNode.entry) {
		                return mapIteratorValue(type, subNode.entry);
		              }
		              stack = this._stack = mapIteratorFrame(subNode, stack);
		            }
		            continue;
		          }
		        }
		        stack = this._stack = this._stack.__prev;
		      }
		      return iteratorDone();
		    };


		  function mapIteratorValue(type, entry) {
		    return iteratorValue(type, entry[0], entry[1]);
		  }

		  function mapIteratorFrame(node, prev) {
		    return {
		      node: node,
		      index: 0,
		      __prev: prev
		    };
		  }

		  function makeMap(size, root, ownerID, hash) {
		    var map = Object.create(MapPrototype);
		    map.size = size;
		    map._root = root;
		    map.__ownerID = ownerID;
		    map.__hash = hash;
		    map.__altered = false;
		    return map;
		  }

		  var EMPTY_MAP;
		  function emptyMap() {
		    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
		  }

		  function updateMap(map, k, v) {
		    var newRoot;
		    var newSize;
		    if (!map._root) {
		      if (v === NOT_SET) {
		        return map;
		      }
		      newSize = 1;
		      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
		    } else {
		      var didChangeSize = MakeRef(CHANGE_LENGTH);
		      var didAlter = MakeRef(DID_ALTER);
		      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
		      if (!didAlter.value) {
		        return map;
		      }
		      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
		    }
		    if (map.__ownerID) {
		      map.size = newSize;
		      map._root = newRoot;
		      map.__hash = undefined;
		      map.__altered = true;
		      return map;
		    }
		    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
		  }

		  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
		    if (!node) {
		      if (value === NOT_SET) {
		        return node;
		      }
		      SetRef(didAlter);
		      SetRef(didChangeSize);
		      return new ValueNode(ownerID, keyHash, [key, value]);
		    }
		    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
		  }

		  function isLeafNode(node) {
		    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
		  }

		  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
		    if (node.keyHash === keyHash) {
		      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
		    }

		    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
		    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;

		    var newNode;
		    var nodes = idx1 === idx2 ?
		      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :
		      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);

		    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
		  }

		  function createNodes(ownerID, entries, key, value) {
		    if (!ownerID) {
		      ownerID = new OwnerID();
		    }
		    var node = new ValueNode(ownerID, hash(key), [key, value]);
		    for (var ii = 0; ii < entries.length; ii++) {
		      var entry = entries[ii];
		      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
		    }
		    return node;
		  }

		  function packNodes(ownerID, nodes, count, excluding) {
		    var bitmap = 0;
		    var packedII = 0;
		    var packedNodes = new Array(count);
		    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
		      var node = nodes[ii];
		      if (node !== undefined && ii !== excluding) {
		        bitmap |= bit;
		        packedNodes[packedII++] = node;
		      }
		    }
		    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
		  }

		  function expandNodes(ownerID, nodes, bitmap, including, node) {
		    var count = 0;
		    var expandedNodes = new Array(SIZE);
		    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
		      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
		    }
		    expandedNodes[including] = node;
		    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
		  }

		  function mergeIntoMapWith(map, merger, iterables) {
		    var iters = [];
		    for (var ii = 0; ii < iterables.length; ii++) {
		      var value = iterables[ii];
		      var iter = KeyedIterable(value);
		      if (!isIterable(value)) {
		        iter = iter.map(function(v ) {return fromJS(v)});
		      }
		      iters.push(iter);
		    }
		    return mergeIntoCollectionWith(map, merger, iters);
		  }

		  function deepMerger(existing, value, key) {
		    return existing && existing.mergeDeep && isIterable(value) ?
		      existing.mergeDeep(value) :
		      is(existing, value) ? existing : value;
		  }

		  function deepMergerWith(merger) {
		    return function(existing, value, key)  {
		      if (existing && existing.mergeDeepWith && isIterable(value)) {
		        return existing.mergeDeepWith(merger, value);
		      }
		      var nextValue = merger(existing, value, key);
		      return is(existing, nextValue) ? existing : nextValue;
		    };
		  }

		  function mergeIntoCollectionWith(collection, merger, iters) {
		    iters = iters.filter(function(x ) {return x.size !== 0});
		    if (iters.length === 0) {
		      return collection;
		    }
		    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
		      return collection.constructor(iters[0]);
		    }
		    return collection.withMutations(function(collection ) {
		      var mergeIntoMap = merger ?
		        function(value, key)  {
		          collection.update(key, NOT_SET, function(existing )
		            {return existing === NOT_SET ? value : merger(existing, value, key)}
		          );
		        } :
		        function(value, key)  {
		          collection.set(key, value);
		        }
		      for (var ii = 0; ii < iters.length; ii++) {
		        iters[ii].forEach(mergeIntoMap);
		      }
		    });
		  }

		  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
		    var isNotSet = existing === NOT_SET;
		    var step = keyPathIter.next();
		    if (step.done) {
		      var existingValue = isNotSet ? notSetValue : existing;
		      var newValue = updater(existingValue);
		      return newValue === existingValue ? existing : newValue;
		    }
		    invariant(
		      isNotSet || (existing && existing.set),
		      'invalid keyPath'
		    );
		    var key = step.value;
		    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
		    var nextUpdated = updateInDeepMap(
		      nextExisting,
		      keyPathIter,
		      notSetValue,
		      updater
		    );
		    return nextUpdated === nextExisting ? existing :
		      nextUpdated === NOT_SET ? existing.remove(key) :
		      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
		  }

		  function popCount(x) {
		    x = x - ((x >> 1) & 0x55555555);
		    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
		    x = (x + (x >> 4)) & 0x0f0f0f0f;
		    x = x + (x >> 8);
		    x = x + (x >> 16);
		    return x & 0x7f;
		  }

		  function setIn(array, idx, val, canEdit) {
		    var newArray = canEdit ? array : arrCopy(array);
		    newArray[idx] = val;
		    return newArray;
		  }

		  function spliceIn(array, idx, val, canEdit) {
		    var newLen = array.length + 1;
		    if (canEdit && idx + 1 === newLen) {
		      array[idx] = val;
		      return array;
		    }
		    var newArray = new Array(newLen);
		    var after = 0;
		    for (var ii = 0; ii < newLen; ii++) {
		      if (ii === idx) {
		        newArray[ii] = val;
		        after = -1;
		      } else {
		        newArray[ii] = array[ii + after];
		      }
		    }
		    return newArray;
		  }

		  function spliceOut(array, idx, canEdit) {
		    var newLen = array.length - 1;
		    if (canEdit && idx === newLen) {
		      array.pop();
		      return array;
		    }
		    var newArray = new Array(newLen);
		    var after = 0;
		    for (var ii = 0; ii < newLen; ii++) {
		      if (ii === idx) {
		        after = 1;
		      }
		      newArray[ii] = array[ii + after];
		    }
		    return newArray;
		  }

		  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
		  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
		  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;

		  createClass(List, IndexedCollection);

		    // @pragma Construction

		    function List(value) {
		      var empty = emptyList();
		      if (value === null || value === undefined) {
		        return empty;
		      }
		      if (isList(value)) {
		        return value;
		      }
		      var iter = IndexedIterable(value);
		      var size = iter.size;
		      if (size === 0) {
		        return empty;
		      }
		      assertNotInfinite(size);
		      if (size > 0 && size < SIZE) {
		        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
		      }
		      return empty.withMutations(function(list ) {
		        list.setSize(size);
		        iter.forEach(function(v, i)  {return list.set(i, v)});
		      });
		    }

		    List.of = function(/*...values*/) {
		      return this(arguments);
		    };

		    List.prototype.toString = function() {
		      return this.__toString('List [', ']');
		    };

		    // @pragma Access

		    List.prototype.get = function(index, notSetValue) {
		      index = wrapIndex(this, index);
		      if (index >= 0 && index < this.size) {
		        index += this._origin;
		        var node = listNodeFor(this, index);
		        return node && node.array[index & MASK];
		      }
		      return notSetValue;
		    };

		    // @pragma Modification

		    List.prototype.set = function(index, value) {
		      return updateList(this, index, value);
		    };

		    List.prototype.remove = function(index) {
		      return !this.has(index) ? this :
		        index === 0 ? this.shift() :
		        index === this.size - 1 ? this.pop() :
		        this.splice(index, 1);
		    };

		    List.prototype.insert = function(index, value) {
		      return this.splice(index, 0, value);
		    };

		    List.prototype.clear = function() {
		      if (this.size === 0) {
		        return this;
		      }
		      if (this.__ownerID) {
		        this.size = this._origin = this._capacity = 0;
		        this._level = SHIFT;
		        this._root = this._tail = null;
		        this.__hash = undefined;
		        this.__altered = true;
		        return this;
		      }
		      return emptyList();
		    };

		    List.prototype.push = function(/*...values*/) {
		      var values = arguments;
		      var oldSize = this.size;
		      return this.withMutations(function(list ) {
		        setListBounds(list, 0, oldSize + values.length);
		        for (var ii = 0; ii < values.length; ii++) {
		          list.set(oldSize + ii, values[ii]);
		        }
		      });
		    };

		    List.prototype.pop = function() {
		      return setListBounds(this, 0, -1);
		    };

		    List.prototype.unshift = function(/*...values*/) {
		      var values = arguments;
		      return this.withMutations(function(list ) {
		        setListBounds(list, -values.length);
		        for (var ii = 0; ii < values.length; ii++) {
		          list.set(ii, values[ii]);
		        }
		      });
		    };

		    List.prototype.shift = function() {
		      return setListBounds(this, 1);
		    };

		    // @pragma Composition

		    List.prototype.merge = function(/*...iters*/) {
		      return mergeIntoListWith(this, undefined, arguments);
		    };

		    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
		      return mergeIntoListWith(this, merger, iters);
		    };

		    List.prototype.mergeDeep = function(/*...iters*/) {
		      return mergeIntoListWith(this, deepMerger, arguments);
		    };

		    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
		      return mergeIntoListWith(this, deepMergerWith(merger), iters);
		    };

		    List.prototype.setSize = function(size) {
		      return setListBounds(this, 0, size);
		    };

		    // @pragma Iteration

		    List.prototype.slice = function(begin, end) {
		      var size = this.size;
		      if (wholeSlice(begin, end, size)) {
		        return this;
		      }
		      return setListBounds(
		        this,
		        resolveBegin(begin, size),
		        resolveEnd(end, size)
		      );
		    };

		    List.prototype.__iterator = function(type, reverse) {
		      var index = 0;
		      var values = iterateList(this, reverse);
		      return new Iterator(function()  {
		        var value = values();
		        return value === DONE ?
		          iteratorDone() :
		          iteratorValue(type, index++, value);
		      });
		    };

		    List.prototype.__iterate = function(fn, reverse) {
		      var index = 0;
		      var values = iterateList(this, reverse);
		      var value;
		      while ((value = values()) !== DONE) {
		        if (fn(value, index++, this) === false) {
		          break;
		        }
		      }
		      return index;
		    };

		    List.prototype.__ensureOwner = function(ownerID) {
		      if (ownerID === this.__ownerID) {
		        return this;
		      }
		      if (!ownerID) {
		        this.__ownerID = ownerID;
		        return this;
		      }
		      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
		    };


		  function isList(maybeList) {
		    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
		  }

		  List.isList = isList;

		  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';

		  var ListPrototype = List.prototype;
		  ListPrototype[IS_LIST_SENTINEL] = true;
		  ListPrototype[DELETE] = ListPrototype.remove;
		  ListPrototype.setIn = MapPrototype.setIn;
		  ListPrototype.deleteIn =
		  ListPrototype.removeIn = MapPrototype.removeIn;
		  ListPrototype.update = MapPrototype.update;
		  ListPrototype.updateIn = MapPrototype.updateIn;
		  ListPrototype.mergeIn = MapPrototype.mergeIn;
		  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
		  ListPrototype.withMutations = MapPrototype.withMutations;
		  ListPrototype.asMutable = MapPrototype.asMutable;
		  ListPrototype.asImmutable = MapPrototype.asImmutable;
		  ListPrototype.wasAltered = MapPrototype.wasAltered;



		    function VNode(array, ownerID) {
		      this.array = array;
		      this.ownerID = ownerID;
		    }

		    // TODO: seems like these methods are very similar

		    VNode.prototype.removeBefore = function(ownerID, level, index) {
		      if (index === level ? 1 << level : 0 || this.array.length === 0) {
		        return this;
		      }
		      var originIndex = (index >>> level) & MASK;
		      if (originIndex >= this.array.length) {
		        return new VNode([], ownerID);
		      }
		      var removingFirst = originIndex === 0;
		      var newChild;
		      if (level > 0) {
		        var oldChild = this.array[originIndex];
		        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
		        if (newChild === oldChild && removingFirst) {
		          return this;
		        }
		      }
		      if (removingFirst && !newChild) {
		        return this;
		      }
		      var editable = editableVNode(this, ownerID);
		      if (!removingFirst) {
		        for (var ii = 0; ii < originIndex; ii++) {
		          editable.array[ii] = undefined;
		        }
		      }
		      if (newChild) {
		        editable.array[originIndex] = newChild;
		      }
		      return editable;
		    };

		    VNode.prototype.removeAfter = function(ownerID, level, index) {
		      if (index === (level ? 1 << level : 0) || this.array.length === 0) {
		        return this;
		      }
		      var sizeIndex = ((index - 1) >>> level) & MASK;
		      if (sizeIndex >= this.array.length) {
		        return this;
		      }

		      var newChild;
		      if (level > 0) {
		        var oldChild = this.array[sizeIndex];
		        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
		        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
		          return this;
		        }
		      }

		      var editable = editableVNode(this, ownerID);
		      editable.array.splice(sizeIndex + 1);
		      if (newChild) {
		        editable.array[sizeIndex] = newChild;
		      }
		      return editable;
		    };



		  var DONE = {};

		  function iterateList(list, reverse) {
		    var left = list._origin;
		    var right = list._capacity;
		    var tailPos = getTailOffset(right);
		    var tail = list._tail;

		    return iterateNodeOrLeaf(list._root, list._level, 0);

		    function iterateNodeOrLeaf(node, level, offset) {
		      return level === 0 ?
		        iterateLeaf(node, offset) :
		        iterateNode(node, level, offset);
		    }

		    function iterateLeaf(node, offset) {
		      var array = offset === tailPos ? tail && tail.array : node && node.array;
		      var from = offset > left ? 0 : left - offset;
		      var to = right - offset;
		      if (to > SIZE) {
		        to = SIZE;
		      }
		      return function()  {
		        if (from === to) {
		          return DONE;
		        }
		        var idx = reverse ? --to : from++;
		        return array && array[idx];
		      };
		    }

		    function iterateNode(node, level, offset) {
		      var values;
		      var array = node && node.array;
		      var from = offset > left ? 0 : (left - offset) >> level;
		      var to = ((right - offset) >> level) + 1;
		      if (to > SIZE) {
		        to = SIZE;
		      }
		      return function()  {
		        do {
		          if (values) {
		            var value = values();
		            if (value !== DONE) {
		              return value;
		            }
		            values = null;
		          }
		          if (from === to) {
		            return DONE;
		          }
		          var idx = reverse ? --to : from++;
		          values = iterateNodeOrLeaf(
		            array && array[idx], level - SHIFT, offset + (idx << level)
		          );
		        } while (true);
		      };
		    }
		  }

		  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
		    var list = Object.create(ListPrototype);
		    list.size = capacity - origin;
		    list._origin = origin;
		    list._capacity = capacity;
		    list._level = level;
		    list._root = root;
		    list._tail = tail;
		    list.__ownerID = ownerID;
		    list.__hash = hash;
		    list.__altered = false;
		    return list;
		  }

		  var EMPTY_LIST;
		  function emptyList() {
		    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
		  }

		  function updateList(list, index, value) {
		    index = wrapIndex(list, index);

		    if (index !== index) {
		      return list;
		    }

		    if (index >= list.size || index < 0) {
		      return list.withMutations(function(list ) {
		        index < 0 ?
		          setListBounds(list, index).set(0, value) :
		          setListBounds(list, 0, index + 1).set(index, value)
		      });
		    }

		    index += list._origin;

		    var newTail = list._tail;
		    var newRoot = list._root;
		    var didAlter = MakeRef(DID_ALTER);
		    if (index >= getTailOffset(list._capacity)) {
		      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
		    } else {
		      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
		    }

		    if (!didAlter.value) {
		      return list;
		    }

		    if (list.__ownerID) {
		      list._root = newRoot;
		      list._tail = newTail;
		      list.__hash = undefined;
		      list.__altered = true;
		      return list;
		    }
		    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
		  }

		  function updateVNode(node, ownerID, level, index, value, didAlter) {
		    var idx = (index >>> level) & MASK;
		    var nodeHas = node && idx < node.array.length;
		    if (!nodeHas && value === undefined) {
		      return node;
		    }

		    var newNode;

		    if (level > 0) {
		      var lowerNode = node && node.array[idx];
		      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
		      if (newLowerNode === lowerNode) {
		        return node;
		      }
		      newNode = editableVNode(node, ownerID);
		      newNode.array[idx] = newLowerNode;
		      return newNode;
		    }

		    if (nodeHas && node.array[idx] === value) {
		      return node;
		    }

		    SetRef(didAlter);

		    newNode = editableVNode(node, ownerID);
		    if (value === undefined && idx === newNode.array.length - 1) {
		      newNode.array.pop();
		    } else {
		      newNode.array[idx] = value;
		    }
		    return newNode;
		  }

		  function editableVNode(node, ownerID) {
		    if (ownerID && node && ownerID === node.ownerID) {
		      return node;
		    }
		    return new VNode(node ? node.array.slice() : [], ownerID);
		  }

		  function listNodeFor(list, rawIndex) {
		    if (rawIndex >= getTailOffset(list._capacity)) {
		      return list._tail;
		    }
		    if (rawIndex < 1 << (list._level + SHIFT)) {
		      var node = list._root;
		      var level = list._level;
		      while (node && level > 0) {
		        node = node.array[(rawIndex >>> level) & MASK];
		        level -= SHIFT;
		      }
		      return node;
		    }
		  }

		  function setListBounds(list, begin, end) {
		    // Sanitize begin & end using this shorthand for ToInt32(argument)
		    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
		    if (begin !== undefined) {
		      begin = begin | 0;
		    }
		    if (end !== undefined) {
		      end = end | 0;
		    }
		    var owner = list.__ownerID || new OwnerID();
		    var oldOrigin = list._origin;
		    var oldCapacity = list._capacity;
		    var newOrigin = oldOrigin + begin;
		    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
		    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
		      return list;
		    }

		    // If it's going to end after it starts, it's empty.
		    if (newOrigin >= newCapacity) {
		      return list.clear();
		    }

		    var newLevel = list._level;
		    var newRoot = list._root;

		    // New origin might need creating a higher root.
		    var offsetShift = 0;
		    while (newOrigin + offsetShift < 0) {
		      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
		      newLevel += SHIFT;
		      offsetShift += 1 << newLevel;
		    }
		    if (offsetShift) {
		      newOrigin += offsetShift;
		      oldOrigin += offsetShift;
		      newCapacity += offsetShift;
		      oldCapacity += offsetShift;
		    }

		    var oldTailOffset = getTailOffset(oldCapacity);
		    var newTailOffset = getTailOffset(newCapacity);

		    // New size might need creating a higher root.
		    while (newTailOffset >= 1 << (newLevel + SHIFT)) {
		      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
		      newLevel += SHIFT;
		    }

		    // Locate or create the new tail.
		    var oldTail = list._tail;
		    var newTail = newTailOffset < oldTailOffset ?
		      listNodeFor(list, newCapacity - 1) :
		      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;

		    // Merge Tail into tree.
		    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
		      newRoot = editableVNode(newRoot, owner);
		      var node = newRoot;
		      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
		        var idx = (oldTailOffset >>> level) & MASK;
		        node = node.array[idx] = editableVNode(node.array[idx], owner);
		      }
		      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
		    }

		    // If the size has been reduced, there's a chance the tail needs to be trimmed.
		    if (newCapacity < oldCapacity) {
		      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
		    }

		    // If the new origin is within the tail, then we do not need a root.
		    if (newOrigin >= newTailOffset) {
		      newOrigin -= newTailOffset;
		      newCapacity -= newTailOffset;
		      newLevel = SHIFT;
		      newRoot = null;
		      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

		    // Otherwise, if the root has been trimmed, garbage collect.
		    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
		      offsetShift = 0;

		      // Identify the new top root node of the subtree of the old root.
		      while (newRoot) {
		        var beginIndex = (newOrigin >>> newLevel) & MASK;
		        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {
		          break;
		        }
		        if (beginIndex) {
		          offsetShift += (1 << newLevel) * beginIndex;
		        }
		        newLevel -= SHIFT;
		        newRoot = newRoot.array[beginIndex];
		      }

		      // Trim the new sides of the new root.
		      if (newRoot && newOrigin > oldOrigin) {
		        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
		      }
		      if (newRoot && newTailOffset < oldTailOffset) {
		        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
		      }
		      if (offsetShift) {
		        newOrigin -= offsetShift;
		        newCapacity -= offsetShift;
		      }
		    }

		    if (list.__ownerID) {
		      list.size = newCapacity - newOrigin;
		      list._origin = newOrigin;
		      list._capacity = newCapacity;
		      list._level = newLevel;
		      list._root = newRoot;
		      list._tail = newTail;
		      list.__hash = undefined;
		      list.__altered = true;
		      return list;
		    }
		    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
		  }

		  function mergeIntoListWith(list, merger, iterables) {
		    var iters = [];
		    var maxSize = 0;
		    for (var ii = 0; ii < iterables.length; ii++) {
		      var value = iterables[ii];
		      var iter = IndexedIterable(value);
		      if (iter.size > maxSize) {
		        maxSize = iter.size;
		      }
		      if (!isIterable(value)) {
		        iter = iter.map(function(v ) {return fromJS(v)});
		      }
		      iters.push(iter);
		    }
		    if (maxSize > list.size) {
		      list = list.setSize(maxSize);
		    }
		    return mergeIntoCollectionWith(list, merger, iters);
		  }

		  function getTailOffset(size) {
		    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);
		  }

		  createClass(OrderedMap, Map);

		    // @pragma Construction

		    function OrderedMap(value) {
		      return value === null || value === undefined ? emptyOrderedMap() :
		        isOrderedMap(value) ? value :
		        emptyOrderedMap().withMutations(function(map ) {
		          var iter = KeyedIterable(value);
		          assertNotInfinite(iter.size);
		          iter.forEach(function(v, k)  {return map.set(k, v)});
		        });
		    }

		    OrderedMap.of = function(/*...values*/) {
		      return this(arguments);
		    };

		    OrderedMap.prototype.toString = function() {
		      return this.__toString('OrderedMap {', '}');
		    };

		    // @pragma Access

		    OrderedMap.prototype.get = function(k, notSetValue) {
		      var index = this._map.get(k);
		      return index !== undefined ? this._list.get(index)[1] : notSetValue;
		    };

		    // @pragma Modification

		    OrderedMap.prototype.clear = function() {
		      if (this.size === 0) {
		        return this;
		      }
		      if (this.__ownerID) {
		        this.size = 0;
		        this._map.clear();
		        this._list.clear();
		        return this;
		      }
		      return emptyOrderedMap();
		    };

		    OrderedMap.prototype.set = function(k, v) {
		      return updateOrderedMap(this, k, v);
		    };

		    OrderedMap.prototype.remove = function(k) {
		      return updateOrderedMap(this, k, NOT_SET);
		    };

		    OrderedMap.prototype.wasAltered = function() {
		      return this._map.wasAltered() || this._list.wasAltered();
		    };

		    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;
		      return this._list.__iterate(
		        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},
		        reverse
		      );
		    };

		    OrderedMap.prototype.__iterator = function(type, reverse) {
		      return this._list.fromEntrySeq().__iterator(type, reverse);
		    };

		    OrderedMap.prototype.__ensureOwner = function(ownerID) {
		      if (ownerID === this.__ownerID) {
		        return this;
		      }
		      var newMap = this._map.__ensureOwner(ownerID);
		      var newList = this._list.__ensureOwner(ownerID);
		      if (!ownerID) {
		        this.__ownerID = ownerID;
		        this._map = newMap;
		        this._list = newList;
		        return this;
		      }
		      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
		    };


		  function isOrderedMap(maybeOrderedMap) {
		    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
		  }

		  OrderedMap.isOrderedMap = isOrderedMap;

		  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
		  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;



		  function makeOrderedMap(map, list, ownerID, hash) {
		    var omap = Object.create(OrderedMap.prototype);
		    omap.size = map ? map.size : 0;
		    omap._map = map;
		    omap._list = list;
		    omap.__ownerID = ownerID;
		    omap.__hash = hash;
		    return omap;
		  }

		  var EMPTY_ORDERED_MAP;
		  function emptyOrderedMap() {
		    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
		  }

		  function updateOrderedMap(omap, k, v) {
		    var map = omap._map;
		    var list = omap._list;
		    var i = map.get(k);
		    var has = i !== undefined;
		    var newMap;
		    var newList;
		    if (v === NOT_SET) { // removed
		      if (!has) {
		        return omap;
		      }
		      if (list.size >= SIZE && list.size >= map.size * 2) {
		        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});
		        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();
		        if (omap.__ownerID) {
		          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
		        }
		      } else {
		        newMap = map.remove(k);
		        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
		      }
		    } else {
		      if (has) {
		        if (v === list.get(i)[1]) {
		          return omap;
		        }
		        newMap = map;
		        newList = list.set(i, [k, v]);
		      } else {
		        newMap = map.set(k, list.size);
		        newList = list.set(list.size, [k, v]);
		      }
		    }
		    if (omap.__ownerID) {
		      omap.size = newMap.size;
		      omap._map = newMap;
		      omap._list = newList;
		      omap.__hash = undefined;
		      return omap;
		    }
		    return makeOrderedMap(newMap, newList);
		  }

		  createClass(ToKeyedSequence, KeyedSeq);
		    function ToKeyedSequence(indexed, useKeys) {
		      this._iter = indexed;
		      this._useKeys = useKeys;
		      this.size = indexed.size;
		    }

		    ToKeyedSequence.prototype.get = function(key, notSetValue) {
		      return this._iter.get(key, notSetValue);
		    };

		    ToKeyedSequence.prototype.has = function(key) {
		      return this._iter.has(key);
		    };

		    ToKeyedSequence.prototype.valueSeq = function() {
		      return this._iter.valueSeq();
		    };

		    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;
		      var reversedSequence = reverseFactory(this, true);
		      if (!this._useKeys) {
		        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};
		      }
		      return reversedSequence;
		    };

		    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;
		      var mappedSequence = mapFactory(this, mapper, context);
		      if (!this._useKeys) {
		        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};
		      }
		      return mappedSequence;
		    };

		    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
		      var ii;
		      return this._iter.__iterate(
		        this._useKeys ?
		          function(v, k)  {return fn(v, k, this$0)} :
		          ((ii = reverse ? resolveSize(this) : 0),
		            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),
		        reverse
		      );
		    };

		    ToKeyedSequence.prototype.__iterator = function(type, reverse) {
		      if (this._useKeys) {
		        return this._iter.__iterator(type, reverse);
		      }
		      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
		      var ii = reverse ? resolveSize(this) : 0;
		      return new Iterator(function()  {
		        var step = iterator.next();
		        return step.done ? step :
		          iteratorValue(type, reverse ? --ii : ii++, step.value, step);
		      });
		    };

		  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;


		  createClass(ToIndexedSequence, IndexedSeq);
		    function ToIndexedSequence(iter) {
		      this._iter = iter;
		      this.size = iter.size;
		    }

		    ToIndexedSequence.prototype.includes = function(value) {
		      return this._iter.includes(value);
		    };

		    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
		      var iterations = 0;
		      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);
		    };

		    ToIndexedSequence.prototype.__iterator = function(type, reverse) {
		      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
		      var iterations = 0;
		      return new Iterator(function()  {
		        var step = iterator.next();
		        return step.done ? step :
		          iteratorValue(type, iterations++, step.value, step)
		      });
		    };



		  createClass(ToSetSequence, SetSeq);
		    function ToSetSequence(iter) {
		      this._iter = iter;
		      this.size = iter.size;
		    }

		    ToSetSequence.prototype.has = function(key) {
		      return this._iter.includes(key);
		    };

		    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
		      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);
		    };

		    ToSetSequence.prototype.__iterator = function(type, reverse) {
		      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
		      return new Iterator(function()  {
		        var step = iterator.next();
		        return step.done ? step :
		          iteratorValue(type, step.value, step.value, step);
		      });
		    };



		  createClass(FromEntriesSequence, KeyedSeq);
		    function FromEntriesSequence(entries) {
		      this._iter = entries;
		      this.size = entries.size;
		    }

		    FromEntriesSequence.prototype.entrySeq = function() {
		      return this._iter.toSeq();
		    };

		    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
		      return this._iter.__iterate(function(entry ) {
		        // Check if entry exists first so array access doesn't throw for holes
		        // in the parent iteration.
		        if (entry) {
		          validateEntry(entry);
		          var indexedIterable = isIterable(entry);
		          return fn(
		            indexedIterable ? entry.get(1) : entry[1],
		            indexedIterable ? entry.get(0) : entry[0],
		            this$0
		          );
		        }
		      }, reverse);
		    };

		    FromEntriesSequence.prototype.__iterator = function(type, reverse) {
		      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
		      return new Iterator(function()  {
		        while (true) {
		          var step = iterator.next();
		          if (step.done) {
		            return step;
		          }
		          var entry = step.value;
		          // Check if entry exists first so array access doesn't throw for holes
		          // in the parent iteration.
		          if (entry) {
		            validateEntry(entry);
		            var indexedIterable = isIterable(entry);
		            return iteratorValue(
		              type,
		              indexedIterable ? entry.get(0) : entry[0],
		              indexedIterable ? entry.get(1) : entry[1],
		              step
		            );
		          }
		        }
		      });
		    };


		  ToIndexedSequence.prototype.cacheResult =
		  ToKeyedSequence.prototype.cacheResult =
		  ToSetSequence.prototype.cacheResult =
		  FromEntriesSequence.prototype.cacheResult =
		    cacheResultThrough;


		  function flipFactory(iterable) {
		    var flipSequence = makeSequence(iterable);
		    flipSequence._iter = iterable;
		    flipSequence.size = iterable.size;
		    flipSequence.flip = function()  {return iterable};
		    flipSequence.reverse = function () {
		      var reversedSequence = iterable.reverse.apply(this); // super.reverse()
		      reversedSequence.flip = function()  {return iterable.reverse()};
		      return reversedSequence;
		    };
		    flipSequence.has = function(key ) {return iterable.includes(key)};
		    flipSequence.includes = function(key ) {return iterable.has(key)};
		    flipSequence.cacheResult = cacheResultThrough;
		    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
		      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);
		    }
		    flipSequence.__iteratorUncached = function(type, reverse) {
		      if (type === ITERATE_ENTRIES) {
		        var iterator = iterable.__iterator(type, reverse);
		        return new Iterator(function()  {
		          var step = iterator.next();
		          if (!step.done) {
		            var k = step.value[0];
		            step.value[0] = step.value[1];
		            step.value[1] = k;
		          }
		          return step;
		        });
		      }
		      return iterable.__iterator(
		        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
		        reverse
		      );
		    }
		    return flipSequence;
		  }


		  function mapFactory(iterable, mapper, context) {
		    var mappedSequence = makeSequence(iterable);
		    mappedSequence.size = iterable.size;
		    mappedSequence.has = function(key ) {return iterable.has(key)};
		    mappedSequence.get = function(key, notSetValue)  {
		      var v = iterable.get(key, NOT_SET);
		      return v === NOT_SET ?
		        notSetValue :
		        mapper.call(context, v, key, iterable);
		    };
		    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
		      return iterable.__iterate(
		        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},
		        reverse
		      );
		    }
		    mappedSequence.__iteratorUncached = function (type, reverse) {
		      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
		      return new Iterator(function()  {
		        var step = iterator.next();
		        if (step.done) {
		          return step;
		        }
		        var entry = step.value;
		        var key = entry[0];
		        return iteratorValue(
		          type,
		          key,
		          mapper.call(context, entry[1], key, iterable),
		          step
		        );
		      });
		    }
		    return mappedSequence;
		  }


		  function reverseFactory(iterable, useKeys) {
		    var reversedSequence = makeSequence(iterable);
		    reversedSequence._iter = iterable;
		    reversedSequence.size = iterable.size;
		    reversedSequence.reverse = function()  {return iterable};
		    if (iterable.flip) {
		      reversedSequence.flip = function () {
		        var flipSequence = flipFactory(iterable);
		        flipSequence.reverse = function()  {return iterable.flip()};
		        return flipSequence;
		      };
		    }
		    reversedSequence.get = function(key, notSetValue) 
		      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};
		    reversedSequence.has = function(key )
		      {return iterable.has(useKeys ? key : -1 - key)};
		    reversedSequence.includes = function(value ) {return iterable.includes(value)};
		    reversedSequence.cacheResult = cacheResultThrough;
		    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;
		      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);
		    };
		    reversedSequence.__iterator =
		      function(type, reverse)  {return iterable.__iterator(type, !reverse)};
		    return reversedSequence;
		  }


		  function filterFactory(iterable, predicate, context, useKeys) {
		    var filterSequence = makeSequence(iterable);
		    if (useKeys) {
		      filterSequence.has = function(key ) {
		        var v = iterable.get(key, NOT_SET);
		        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
		      };
		      filterSequence.get = function(key, notSetValue)  {
		        var v = iterable.get(key, NOT_SET);
		        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?
		          v : notSetValue;
		      };
		    }
		    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
		      var iterations = 0;
		      iterable.__iterate(function(v, k, c)  {
		        if (predicate.call(context, v, k, c)) {
		          iterations++;
		          return fn(v, useKeys ? k : iterations - 1, this$0);
		        }
		      }, reverse);
		      return iterations;
		    };
		    filterSequence.__iteratorUncached = function (type, reverse) {
		      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
		      var iterations = 0;
		      return new Iterator(function()  {
		        while (true) {
		          var step = iterator.next();
		          if (step.done) {
		            return step;
		          }
		          var entry = step.value;
		          var key = entry[0];
		          var value = entry[1];
		          if (predicate.call(context, value, key, iterable)) {
		            return iteratorValue(type, useKeys ? key : iterations++, value, step);
		          }
		        }
		      });
		    }
		    return filterSequence;
		  }


		  function countByFactory(iterable, grouper, context) {
		    var groups = Map().asMutable();
		    iterable.__iterate(function(v, k)  {
		      groups.update(
		        grouper.call(context, v, k, iterable),
		        0,
		        function(a ) {return a + 1}
		      );
		    });
		    return groups.asImmutable();
		  }


		  function groupByFactory(iterable, grouper, context) {
		    var isKeyedIter = isKeyed(iterable);
		    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();
		    iterable.__iterate(function(v, k)  {
		      groups.update(
		        grouper.call(context, v, k, iterable),
		        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}
		      );
		    });
		    var coerce = iterableClass(iterable);
		    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});
		  }


		  function sliceFactory(iterable, begin, end, useKeys) {
		    var originalSize = iterable.size;

		    // Sanitize begin & end using this shorthand for ToInt32(argument)
		    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
		    if (begin !== undefined) {
		      begin = begin | 0;
		    }
		    if (end !== undefined) {
		      if (end === Infinity) {
		        end = originalSize;
		      } else {
		        end = end | 0;
		      }
		    }

		    if (wholeSlice(begin, end, originalSize)) {
		      return iterable;
		    }

		    var resolvedBegin = resolveBegin(begin, originalSize);
		    var resolvedEnd = resolveEnd(end, originalSize);

		    // begin or end will be NaN if they were provided as negative numbers and
		    // this iterable's size is unknown. In that case, cache first so there is
		    // a known size and these do not resolve to NaN.
		    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
		      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
		    }

		    // Note: resolvedEnd is undefined when the original sequence's length is
		    // unknown and this slice did not supply an end and should contain all
		    // elements after resolvedBegin.
		    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
		    var resolvedSize = resolvedEnd - resolvedBegin;
		    var sliceSize;
		    if (resolvedSize === resolvedSize) {
		      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
		    }

		    var sliceSeq = makeSequence(iterable);

		    // If iterable.size is undefined, the size of the realized sliceSeq is
		    // unknown at this point unless the number of items to slice is 0
		    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;

		    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
		      sliceSeq.get = function (index, notSetValue) {
		        index = wrapIndex(this, index);
		        return index >= 0 && index < sliceSize ?
		          iterable.get(index + resolvedBegin, notSetValue) :
		          notSetValue;
		      }
		    }

		    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;
		      if (sliceSize === 0) {
		        return 0;
		      }
		      if (reverse) {
		        return this.cacheResult().__iterate(fn, reverse);
		      }
		      var skipped = 0;
		      var isSkipping = true;
		      var iterations = 0;
		      iterable.__iterate(function(v, k)  {
		        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
		          iterations++;
		          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&
		                 iterations !== sliceSize;
		        }
		      });
		      return iterations;
		    };

		    sliceSeq.__iteratorUncached = function(type, reverse) {
		      if (sliceSize !== 0 && reverse) {
		        return this.cacheResult().__iterator(type, reverse);
		      }
		      // Don't bother instantiating parent iterator if taking 0.
		      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
		      var skipped = 0;
		      var iterations = 0;
		      return new Iterator(function()  {
		        while (skipped++ < resolvedBegin) {
		          iterator.next();
		        }
		        if (++iterations > sliceSize) {
		          return iteratorDone();
		        }
		        var step = iterator.next();
		        if (useKeys || type === ITERATE_VALUES) {
		          return step;
		        } else if (type === ITERATE_KEYS) {
		          return iteratorValue(type, iterations - 1, undefined, step);
		        } else {
		          return iteratorValue(type, iterations - 1, step.value[1], step);
		        }
		      });
		    }

		    return sliceSeq;
		  }


		  function takeWhileFactory(iterable, predicate, context) {
		    var takeSequence = makeSequence(iterable);
		    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
		      if (reverse) {
		        return this.cacheResult().__iterate(fn, reverse);
		      }
		      var iterations = 0;
		      iterable.__iterate(function(v, k, c) 
		        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}
		      );
		      return iterations;
		    };
		    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
		      if (reverse) {
		        return this.cacheResult().__iterator(type, reverse);
		      }
		      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
		      var iterating = true;
		      return new Iterator(function()  {
		        if (!iterating) {
		          return iteratorDone();
		        }
		        var step = iterator.next();
		        if (step.done) {
		          return step;
		        }
		        var entry = step.value;
		        var k = entry[0];
		        var v = entry[1];
		        if (!predicate.call(context, v, k, this$0)) {
		          iterating = false;
		          return iteratorDone();
		        }
		        return type === ITERATE_ENTRIES ? step :
		          iteratorValue(type, k, v, step);
		      });
		    };
		    return takeSequence;
		  }


		  function skipWhileFactory(iterable, predicate, context, useKeys) {
		    var skipSequence = makeSequence(iterable);
		    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
		      if (reverse) {
		        return this.cacheResult().__iterate(fn, reverse);
		      }
		      var isSkipping = true;
		      var iterations = 0;
		      iterable.__iterate(function(v, k, c)  {
		        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
		          iterations++;
		          return fn(v, useKeys ? k : iterations - 1, this$0);
		        }
		      });
		      return iterations;
		    };
		    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
		      if (reverse) {
		        return this.cacheResult().__iterator(type, reverse);
		      }
		      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
		      var skipping = true;
		      var iterations = 0;
		      return new Iterator(function()  {
		        var step, k, v;
		        do {
		          step = iterator.next();
		          if (step.done) {
		            if (useKeys || type === ITERATE_VALUES) {
		              return step;
		            } else if (type === ITERATE_KEYS) {
		              return iteratorValue(type, iterations++, undefined, step);
		            } else {
		              return iteratorValue(type, iterations++, step.value[1], step);
		            }
		          }
		          var entry = step.value;
		          k = entry[0];
		          v = entry[1];
		          skipping && (skipping = predicate.call(context, v, k, this$0));
		        } while (skipping);
		        return type === ITERATE_ENTRIES ? step :
		          iteratorValue(type, k, v, step);
		      });
		    };
		    return skipSequence;
		  }


		  function concatFactory(iterable, values) {
		    var isKeyedIterable = isKeyed(iterable);
		    var iters = [iterable].concat(values).map(function(v ) {
		      if (!isIterable(v)) {
		        v = isKeyedIterable ?
		          keyedSeqFromValue(v) :
		          indexedSeqFromValue(Array.isArray(v) ? v : [v]);
		      } else if (isKeyedIterable) {
		        v = KeyedIterable(v);
		      }
		      return v;
		    }).filter(function(v ) {return v.size !== 0});

		    if (iters.length === 0) {
		      return iterable;
		    }

		    if (iters.length === 1) {
		      var singleton = iters[0];
		      if (singleton === iterable ||
		          isKeyedIterable && isKeyed(singleton) ||
		          isIndexed(iterable) && isIndexed(singleton)) {
		        return singleton;
		      }
		    }

		    var concatSeq = new ArraySeq(iters);
		    if (isKeyedIterable) {
		      concatSeq = concatSeq.toKeyedSeq();
		    } else if (!isIndexed(iterable)) {
		      concatSeq = concatSeq.toSetSeq();
		    }
		    concatSeq = concatSeq.flatten(true);
		    concatSeq.size = iters.reduce(
		      function(sum, seq)  {
		        if (sum !== undefined) {
		          var size = seq.size;
		          if (size !== undefined) {
		            return sum + size;
		          }
		        }
		      },
		      0
		    );
		    return concatSeq;
		  }


		  function flattenFactory(iterable, depth, useKeys) {
		    var flatSequence = makeSequence(iterable);
		    flatSequence.__iterateUncached = function(fn, reverse) {
		      var iterations = 0;
		      var stopped = false;
		      function flatDeep(iter, currentDepth) {var this$0 = this;
		        iter.__iterate(function(v, k)  {
		          if ((!depth || currentDepth < depth) && isIterable(v)) {
		            flatDeep(v, currentDepth + 1);
		          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
		            stopped = true;
		          }
		          return !stopped;
		        }, reverse);
		      }
		      flatDeep(iterable, 0);
		      return iterations;
		    }
		    flatSequence.__iteratorUncached = function(type, reverse) {
		      var iterator = iterable.__iterator(type, reverse);
		      var stack = [];
		      var iterations = 0;
		      return new Iterator(function()  {
		        while (iterator) {
		          var step = iterator.next();
		          if (step.done !== false) {
		            iterator = stack.pop();
		            continue;
		          }
		          var v = step.value;
		          if (type === ITERATE_ENTRIES) {
		            v = v[1];
		          }
		          if ((!depth || stack.length < depth) && isIterable(v)) {
		            stack.push(iterator);
		            iterator = v.__iterator(type, reverse);
		          } else {
		            return useKeys ? step : iteratorValue(type, iterations++, v, step);
		          }
		        }
		        return iteratorDone();
		      });
		    }
		    return flatSequence;
		  }


		  function flatMapFactory(iterable, mapper, context) {
		    var coerce = iterableClass(iterable);
		    return iterable.toSeq().map(
		      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}
		    ).flatten(true);
		  }


		  function interposeFactory(iterable, separator) {
		    var interposedSequence = makeSequence(iterable);
		    interposedSequence.size = iterable.size && iterable.size * 2 -1;
		    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
		      var iterations = 0;
		      iterable.__iterate(function(v, k) 
		        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&
		        fn(v, iterations++, this$0) !== false},
		        reverse
		      );
		      return iterations;
		    };
		    interposedSequence.__iteratorUncached = function(type, reverse) {
		      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
		      var iterations = 0;
		      var step;
		      return new Iterator(function()  {
		        if (!step || iterations % 2) {
		          step = iterator.next();
		          if (step.done) {
		            return step;
		          }
		        }
		        return iterations % 2 ?
		          iteratorValue(type, iterations++, separator) :
		          iteratorValue(type, iterations++, step.value, step);
		      });
		    };
		    return interposedSequence;
		  }


		  function sortFactory(iterable, comparator, mapper) {
		    if (!comparator) {
		      comparator = defaultComparator;
		    }
		    var isKeyedIterable = isKeyed(iterable);
		    var index = 0;
		    var entries = iterable.toSeq().map(
		      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}
		    ).toArray();
		    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(
		      isKeyedIterable ?
		      function(v, i)  { entries[i].length = 2; } :
		      function(v, i)  { entries[i] = v[1]; }
		    );
		    return isKeyedIterable ? KeyedSeq(entries) :
		      isIndexed(iterable) ? IndexedSeq(entries) :
		      SetSeq(entries);
		  }


		  function maxFactory(iterable, comparator, mapper) {
		    if (!comparator) {
		      comparator = defaultComparator;
		    }
		    if (mapper) {
		      var entry = iterable.toSeq()
		        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})
		        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});
		      return entry && entry[0];
		    } else {
		      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});
		    }
		  }

		  function maxCompare(comparator, a, b) {
		    var comp = comparator(b, a);
		    // b is considered the new max if the comparator declares them equal, but
		    // they are not equal and b is in fact a nullish value.
		    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;
		  }


		  function zipWithFactory(keyIter, zipper, iters) {
		    var zipSequence = makeSequence(keyIter);
		    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();
		    // Note: this a generic base implementation of __iterate in terms of
		    // __iterator which may be more generically useful in the future.
		    zipSequence.__iterate = function(fn, reverse) {
		      /* generic:
		      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
		      var step;
		      var iterations = 0;
		      while (!(step = iterator.next()).done) {
		        iterations++;
		        if (fn(step.value[1], step.value[0], this) === false) {
		          break;
		        }
		      }
		      return iterations;
		      */
		      // indexed:
		      var iterator = this.__iterator(ITERATE_VALUES, reverse);
		      var step;
		      var iterations = 0;
		      while (!(step = iterator.next()).done) {
		        if (fn(step.value, iterations++, this) === false) {
		          break;
		        }
		      }
		      return iterations;
		    };
		    zipSequence.__iteratorUncached = function(type, reverse) {
		      var iterators = iters.map(function(i )
		        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}
		      );
		      var iterations = 0;
		      var isDone = false;
		      return new Iterator(function()  {
		        var steps;
		        if (!isDone) {
		          steps = iterators.map(function(i ) {return i.next()});
		          isDone = steps.some(function(s ) {return s.done});
		        }
		        if (isDone) {
		          return iteratorDone();
		        }
		        return iteratorValue(
		          type,
		          iterations++,
		          zipper.apply(null, steps.map(function(s ) {return s.value}))
		        );
		      });
		    };
		    return zipSequence
		  }


		  // #pragma Helper Functions

		  function reify(iter, seq) {
		    return isSeq(iter) ? seq : iter.constructor(seq);
		  }

		  function validateEntry(entry) {
		    if (entry !== Object(entry)) {
		      throw new TypeError('Expected [K, V] tuple: ' + entry);
		    }
		  }

		  function resolveSize(iter) {
		    assertNotInfinite(iter.size);
		    return ensureSize(iter);
		  }

		  function iterableClass(iterable) {
		    return isKeyed(iterable) ? KeyedIterable :
		      isIndexed(iterable) ? IndexedIterable :
		      SetIterable;
		  }

		  function makeSequence(iterable) {
		    return Object.create(
		      (
		        isKeyed(iterable) ? KeyedSeq :
		        isIndexed(iterable) ? IndexedSeq :
		        SetSeq
		      ).prototype
		    );
		  }

		  function cacheResultThrough() {
		    if (this._iter.cacheResult) {
		      this._iter.cacheResult();
		      this.size = this._iter.size;
		      return this;
		    } else {
		      return Seq.prototype.cacheResult.call(this);
		    }
		  }

		  function defaultComparator(a, b) {
		    return a > b ? 1 : a < b ? -1 : 0;
		  }

		  function forceIterator(keyPath) {
		    var iter = getIterator(keyPath);
		    if (!iter) {
		      // Array might not be iterable in this environment, so we need a fallback
		      // to our wrapped type.
		      if (!isArrayLike(keyPath)) {
		        throw new TypeError('Expected iterable or array-like: ' + keyPath);
		      }
		      iter = getIterator(Iterable(keyPath));
		    }
		    return iter;
		  }

		  createClass(Record, KeyedCollection);

		    function Record(defaultValues, name) {
		      var hasInitialized;

		      var RecordType = function Record(values) {
		        if (values instanceof RecordType) {
		          return values;
		        }
		        if (!(this instanceof RecordType)) {
		          return new RecordType(values);
		        }
		        if (!hasInitialized) {
		          hasInitialized = true;
		          var keys = Object.keys(defaultValues);
		          setProps(RecordTypePrototype, keys);
		          RecordTypePrototype.size = keys.length;
		          RecordTypePrototype._name = name;
		          RecordTypePrototype._keys = keys;
		          RecordTypePrototype._defaultValues = defaultValues;
		        }
		        this._map = Map(values);
		      };

		      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
		      RecordTypePrototype.constructor = RecordType;

		      return RecordType;
		    }

		    Record.prototype.toString = function() {
		      return this.__toString(recordName(this) + ' {', '}');
		    };

		    // @pragma Access

		    Record.prototype.has = function(k) {
		      return this._defaultValues.hasOwnProperty(k);
		    };

		    Record.prototype.get = function(k, notSetValue) {
		      if (!this.has(k)) {
		        return notSetValue;
		      }
		      var defaultVal = this._defaultValues[k];
		      return this._map ? this._map.get(k, defaultVal) : defaultVal;
		    };

		    // @pragma Modification

		    Record.prototype.clear = function() {
		      if (this.__ownerID) {
		        this._map && this._map.clear();
		        return this;
		      }
		      var RecordType = this.constructor;
		      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
		    };

		    Record.prototype.set = function(k, v) {
		      if (!this.has(k)) {
		        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
		      }
		      if (this._map && !this._map.has(k)) {
		        var defaultVal = this._defaultValues[k];
		        if (v === defaultVal) {
		          return this;
		        }
		      }
		      var newMap = this._map && this._map.set(k, v);
		      if (this.__ownerID || newMap === this._map) {
		        return this;
		      }
		      return makeRecord(this, newMap);
		    };

		    Record.prototype.remove = function(k) {
		      if (!this.has(k)) {
		        return this;
		      }
		      var newMap = this._map && this._map.remove(k);
		      if (this.__ownerID || newMap === this._map) {
		        return this;
		      }
		      return makeRecord(this, newMap);
		    };

		    Record.prototype.wasAltered = function() {
		      return this._map.wasAltered();
		    };

		    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;
		      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);
		    };

		    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;
		      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);
		    };

		    Record.prototype.__ensureOwner = function(ownerID) {
		      if (ownerID === this.__ownerID) {
		        return this;
		      }
		      var newMap = this._map && this._map.__ensureOwner(ownerID);
		      if (!ownerID) {
		        this.__ownerID = ownerID;
		        this._map = newMap;
		        return this;
		      }
		      return makeRecord(this, newMap, ownerID);
		    };


		  var RecordPrototype = Record.prototype;
		  RecordPrototype[DELETE] = RecordPrototype.remove;
		  RecordPrototype.deleteIn =
		  RecordPrototype.removeIn = MapPrototype.removeIn;
		  RecordPrototype.merge = MapPrototype.merge;
		  RecordPrototype.mergeWith = MapPrototype.mergeWith;
		  RecordPrototype.mergeIn = MapPrototype.mergeIn;
		  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
		  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
		  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
		  RecordPrototype.setIn = MapPrototype.setIn;
		  RecordPrototype.update = MapPrototype.update;
		  RecordPrototype.updateIn = MapPrototype.updateIn;
		  RecordPrototype.withMutations = MapPrototype.withMutations;
		  RecordPrototype.asMutable = MapPrototype.asMutable;
		  RecordPrototype.asImmutable = MapPrototype.asImmutable;


		  function makeRecord(likeRecord, map, ownerID) {
		    var record = Object.create(Object.getPrototypeOf(likeRecord));
		    record._map = map;
		    record.__ownerID = ownerID;
		    return record;
		  }

		  function recordName(record) {
		    return record._name || record.constructor.name || 'Record';
		  }

		  function setProps(prototype, names) {
		    try {
		      names.forEach(setProp.bind(undefined, prototype));
		    } catch (error) {
		      // Object.defineProperty failed. Probably IE8.
		    }
		  }

		  function setProp(prototype, name) {
		    Object.defineProperty(prototype, name, {
		      get: function() {
		        return this.get(name);
		      },
		      set: function(value) {
		        invariant(this.__ownerID, 'Cannot set on an immutable record.');
		        this.set(name, value);
		      }
		    });
		  }

		  createClass(Set, SetCollection);

		    // @pragma Construction

		    function Set(value) {
		      return value === null || value === undefined ? emptySet() :
		        isSet(value) && !isOrdered(value) ? value :
		        emptySet().withMutations(function(set ) {
		          var iter = SetIterable(value);
		          assertNotInfinite(iter.size);
		          iter.forEach(function(v ) {return set.add(v)});
		        });
		    }

		    Set.of = function(/*...values*/) {
		      return this(arguments);
		    };

		    Set.fromKeys = function(value) {
		      return this(KeyedIterable(value).keySeq());
		    };

		    Set.prototype.toString = function() {
		      return this.__toString('Set {', '}');
		    };

		    // @pragma Access

		    Set.prototype.has = function(value) {
		      return this._map.has(value);
		    };

		    // @pragma Modification

		    Set.prototype.add = function(value) {
		      return updateSet(this, this._map.set(value, true));
		    };

		    Set.prototype.remove = function(value) {
		      return updateSet(this, this._map.remove(value));
		    };

		    Set.prototype.clear = function() {
		      return updateSet(this, this._map.clear());
		    };

		    // @pragma Composition

		    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);
		      iters = iters.filter(function(x ) {return x.size !== 0});
		      if (iters.length === 0) {
		        return this;
		      }
		      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
		        return this.constructor(iters[0]);
		      }
		      return this.withMutations(function(set ) {
		        for (var ii = 0; ii < iters.length; ii++) {
		          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});
		        }
		      });
		    };

		    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);
		      if (iters.length === 0) {
		        return this;
		      }
		      iters = iters.map(function(iter ) {return SetIterable(iter)});
		      var originalSet = this;
		      return this.withMutations(function(set ) {
		        originalSet.forEach(function(value ) {
		          if (!iters.every(function(iter ) {return iter.includes(value)})) {
		            set.remove(value);
		          }
		        });
		      });
		    };

		    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);
		      if (iters.length === 0) {
		        return this;
		      }
		      iters = iters.map(function(iter ) {return SetIterable(iter)});
		      var originalSet = this;
		      return this.withMutations(function(set ) {
		        originalSet.forEach(function(value ) {
		          if (iters.some(function(iter ) {return iter.includes(value)})) {
		            set.remove(value);
		          }
		        });
		      });
		    };

		    Set.prototype.merge = function() {
		      return this.union.apply(this, arguments);
		    };

		    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
		      return this.union.apply(this, iters);
		    };

		    Set.prototype.sort = function(comparator) {
		      // Late binding
		      return OrderedSet(sortFactory(this, comparator));
		    };

		    Set.prototype.sortBy = function(mapper, comparator) {
		      // Late binding
		      return OrderedSet(sortFactory(this, comparator, mapper));
		    };

		    Set.prototype.wasAltered = function() {
		      return this._map.wasAltered();
		    };

		    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;
		      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);
		    };

		    Set.prototype.__iterator = function(type, reverse) {
		      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);
		    };

		    Set.prototype.__ensureOwner = function(ownerID) {
		      if (ownerID === this.__ownerID) {
		        return this;
		      }
		      var newMap = this._map.__ensureOwner(ownerID);
		      if (!ownerID) {
		        this.__ownerID = ownerID;
		        this._map = newMap;
		        return this;
		      }
		      return this.__make(newMap, ownerID);
		    };


		  function isSet(maybeSet) {
		    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
		  }

		  Set.isSet = isSet;

		  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';

		  var SetPrototype = Set.prototype;
		  SetPrototype[IS_SET_SENTINEL] = true;
		  SetPrototype[DELETE] = SetPrototype.remove;
		  SetPrototype.mergeDeep = SetPrototype.merge;
		  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
		  SetPrototype.withMutations = MapPrototype.withMutations;
		  SetPrototype.asMutable = MapPrototype.asMutable;
		  SetPrototype.asImmutable = MapPrototype.asImmutable;

		  SetPrototype.__empty = emptySet;
		  SetPrototype.__make = makeSet;

		  function updateSet(set, newMap) {
		    if (set.__ownerID) {
		      set.size = newMap.size;
		      set._map = newMap;
		      return set;
		    }
		    return newMap === set._map ? set :
		      newMap.size === 0 ? set.__empty() :
		      set.__make(newMap);
		  }

		  function makeSet(map, ownerID) {
		    var set = Object.create(SetPrototype);
		    set.size = map ? map.size : 0;
		    set._map = map;
		    set.__ownerID = ownerID;
		    return set;
		  }

		  var EMPTY_SET;
		  function emptySet() {
		    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
		  }

		  createClass(OrderedSet, Set);

		    // @pragma Construction

		    function OrderedSet(value) {
		      return value === null || value === undefined ? emptyOrderedSet() :
		        isOrderedSet(value) ? value :
		        emptyOrderedSet().withMutations(function(set ) {
		          var iter = SetIterable(value);
		          assertNotInfinite(iter.size);
		          iter.forEach(function(v ) {return set.add(v)});
		        });
		    }

		    OrderedSet.of = function(/*...values*/) {
		      return this(arguments);
		    };

		    OrderedSet.fromKeys = function(value) {
		      return this(KeyedIterable(value).keySeq());
		    };

		    OrderedSet.prototype.toString = function() {
		      return this.__toString('OrderedSet {', '}');
		    };


		  function isOrderedSet(maybeOrderedSet) {
		    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
		  }

		  OrderedSet.isOrderedSet = isOrderedSet;

		  var OrderedSetPrototype = OrderedSet.prototype;
		  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;

		  OrderedSetPrototype.__empty = emptyOrderedSet;
		  OrderedSetPrototype.__make = makeOrderedSet;

		  function makeOrderedSet(map, ownerID) {
		    var set = Object.create(OrderedSetPrototype);
		    set.size = map ? map.size : 0;
		    set._map = map;
		    set.__ownerID = ownerID;
		    return set;
		  }

		  var EMPTY_ORDERED_SET;
		  function emptyOrderedSet() {
		    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
		  }

		  createClass(Stack, IndexedCollection);

		    // @pragma Construction

		    function Stack(value) {
		      return value === null || value === undefined ? emptyStack() :
		        isStack(value) ? value :
		        emptyStack().unshiftAll(value);
		    }

		    Stack.of = function(/*...values*/) {
		      return this(arguments);
		    };

		    Stack.prototype.toString = function() {
		      return this.__toString('Stack [', ']');
		    };

		    // @pragma Access

		    Stack.prototype.get = function(index, notSetValue) {
		      var head = this._head;
		      index = wrapIndex(this, index);
		      while (head && index--) {
		        head = head.next;
		      }
		      return head ? head.value : notSetValue;
		    };

		    Stack.prototype.peek = function() {
		      return this._head && this._head.value;
		    };

		    // @pragma Modification

		    Stack.prototype.push = function(/*...values*/) {
		      if (arguments.length === 0) {
		        return this;
		      }
		      var newSize = this.size + arguments.length;
		      var head = this._head;
		      for (var ii = arguments.length - 1; ii >= 0; ii--) {
		        head = {
		          value: arguments[ii],
		          next: head
		        };
		      }
		      if (this.__ownerID) {
		        this.size = newSize;
		        this._head = head;
		        this.__hash = undefined;
		        this.__altered = true;
		        return this;
		      }
		      return makeStack(newSize, head);
		    };

		    Stack.prototype.pushAll = function(iter) {
		      iter = IndexedIterable(iter);
		      if (iter.size === 0) {
		        return this;
		      }
		      assertNotInfinite(iter.size);
		      var newSize = this.size;
		      var head = this._head;
		      iter.reverse().forEach(function(value ) {
		        newSize++;
		        head = {
		          value: value,
		          next: head
		        };
		      });
		      if (this.__ownerID) {
		        this.size = newSize;
		        this._head = head;
		        this.__hash = undefined;
		        this.__altered = true;
		        return this;
		      }
		      return makeStack(newSize, head);
		    };

		    Stack.prototype.pop = function() {
		      return this.slice(1);
		    };

		    Stack.prototype.unshift = function(/*...values*/) {
		      return this.push.apply(this, arguments);
		    };

		    Stack.prototype.unshiftAll = function(iter) {
		      return this.pushAll(iter);
		    };

		    Stack.prototype.shift = function() {
		      return this.pop.apply(this, arguments);
		    };

		    Stack.prototype.clear = function() {
		      if (this.size === 0) {
		        return this;
		      }
		      if (this.__ownerID) {
		        this.size = 0;
		        this._head = undefined;
		        this.__hash = undefined;
		        this.__altered = true;
		        return this;
		      }
		      return emptyStack();
		    };

		    Stack.prototype.slice = function(begin, end) {
		      if (wholeSlice(begin, end, this.size)) {
		        return this;
		      }
		      var resolvedBegin = resolveBegin(begin, this.size);
		      var resolvedEnd = resolveEnd(end, this.size);
		      if (resolvedEnd !== this.size) {
		        // super.slice(begin, end);
		        return IndexedCollection.prototype.slice.call(this, begin, end);
		      }
		      var newSize = this.size - resolvedBegin;
		      var head = this._head;
		      while (resolvedBegin--) {
		        head = head.next;
		      }
		      if (this.__ownerID) {
		        this.size = newSize;
		        this._head = head;
		        this.__hash = undefined;
		        this.__altered = true;
		        return this;
		      }
		      return makeStack(newSize, head);
		    };

		    // @pragma Mutability

		    Stack.prototype.__ensureOwner = function(ownerID) {
		      if (ownerID === this.__ownerID) {
		        return this;
		      }
		      if (!ownerID) {
		        this.__ownerID = ownerID;
		        this.__altered = false;
		        return this;
		      }
		      return makeStack(this.size, this._head, ownerID, this.__hash);
		    };

		    // @pragma Iteration

		    Stack.prototype.__iterate = function(fn, reverse) {
		      if (reverse) {
		        return this.reverse().__iterate(fn);
		      }
		      var iterations = 0;
		      var node = this._head;
		      while (node) {
		        if (fn(node.value, iterations++, this) === false) {
		          break;
		        }
		        node = node.next;
		      }
		      return iterations;
		    };

		    Stack.prototype.__iterator = function(type, reverse) {
		      if (reverse) {
		        return this.reverse().__iterator(type);
		      }
		      var iterations = 0;
		      var node = this._head;
		      return new Iterator(function()  {
		        if (node) {
		          var value = node.value;
		          node = node.next;
		          return iteratorValue(type, iterations++, value);
		        }
		        return iteratorDone();
		      });
		    };


		  function isStack(maybeStack) {
		    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
		  }

		  Stack.isStack = isStack;

		  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';

		  var StackPrototype = Stack.prototype;
		  StackPrototype[IS_STACK_SENTINEL] = true;
		  StackPrototype.withMutations = MapPrototype.withMutations;
		  StackPrototype.asMutable = MapPrototype.asMutable;
		  StackPrototype.asImmutable = MapPrototype.asImmutable;
		  StackPrototype.wasAltered = MapPrototype.wasAltered;


		  function makeStack(size, head, ownerID, hash) {
		    var map = Object.create(StackPrototype);
		    map.size = size;
		    map._head = head;
		    map.__ownerID = ownerID;
		    map.__hash = hash;
		    map.__altered = false;
		    return map;
		  }

		  var EMPTY_STACK;
		  function emptyStack() {
		    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
		  }

		  /**
		   * Contributes additional methods to a constructor
		   */
		  function mixin(ctor, methods) {
		    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };
		    Object.keys(methods).forEach(keyCopier);
		    Object.getOwnPropertySymbols &&
		      Object.getOwnPropertySymbols(methods).forEach(keyCopier);
		    return ctor;
		  }

		  Iterable.Iterator = Iterator;

		  mixin(Iterable, {

		    // ### Conversion to other types

		    toArray: function() {
		      assertNotInfinite(this.size);
		      var array = new Array(this.size || 0);
		      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });
		      return array;
		    },

		    toIndexedSeq: function() {
		      return new ToIndexedSequence(this);
		    },

		    toJS: function() {
		      return this.toSeq().map(
		        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}
		      ).__toJS();
		    },

		    toJSON: function() {
		      return this.toSeq().map(
		        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}
		      ).__toJS();
		    },

		    toKeyedSeq: function() {
		      return new ToKeyedSequence(this, true);
		    },

		    toMap: function() {
		      // Use Late Binding here to solve the circular dependency.
		      return Map(this.toKeyedSeq());
		    },

		    toObject: function() {
		      assertNotInfinite(this.size);
		      var object = {};
		      this.__iterate(function(v, k)  { object[k] = v; });
		      return object;
		    },

		    toOrderedMap: function() {
		      // Use Late Binding here to solve the circular dependency.
		      return OrderedMap(this.toKeyedSeq());
		    },

		    toOrderedSet: function() {
		      // Use Late Binding here to solve the circular dependency.
		      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
		    },

		    toSet: function() {
		      // Use Late Binding here to solve the circular dependency.
		      return Set(isKeyed(this) ? this.valueSeq() : this);
		    },

		    toSetSeq: function() {
		      return new ToSetSequence(this);
		    },

		    toSeq: function() {
		      return isIndexed(this) ? this.toIndexedSeq() :
		        isKeyed(this) ? this.toKeyedSeq() :
		        this.toSetSeq();
		    },

		    toStack: function() {
		      // Use Late Binding here to solve the circular dependency.
		      return Stack(isKeyed(this) ? this.valueSeq() : this);
		    },

		    toList: function() {
		      // Use Late Binding here to solve the circular dependency.
		      return List(isKeyed(this) ? this.valueSeq() : this);
		    },


		    // ### Common JavaScript methods and properties

		    toString: function() {
		      return '[Iterable]';
		    },

		    __toString: function(head, tail) {
		      if (this.size === 0) {
		        return head + tail;
		      }
		      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
		    },


		    // ### ES6 Collection methods (ES6 Array and Map)

		    concat: function() {var values = SLICE$0.call(arguments, 0);
		      return reify(this, concatFactory(this, values));
		    },

		    includes: function(searchValue) {
		      return this.some(function(value ) {return is(value, searchValue)});
		    },

		    entries: function() {
		      return this.__iterator(ITERATE_ENTRIES);
		    },

		    every: function(predicate, context) {
		      assertNotInfinite(this.size);
		      var returnValue = true;
		      this.__iterate(function(v, k, c)  {
		        if (!predicate.call(context, v, k, c)) {
		          returnValue = false;
		          return false;
		        }
		      });
		      return returnValue;
		    },

		    filter: function(predicate, context) {
		      return reify(this, filterFactory(this, predicate, context, true));
		    },

		    find: function(predicate, context, notSetValue) {
		      var entry = this.findEntry(predicate, context);
		      return entry ? entry[1] : notSetValue;
		    },

		    forEach: function(sideEffect, context) {
		      assertNotInfinite(this.size);
		      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
		    },

		    join: function(separator) {
		      assertNotInfinite(this.size);
		      separator = separator !== undefined ? '' + separator : ',';
		      var joined = '';
		      var isFirst = true;
		      this.__iterate(function(v ) {
		        isFirst ? (isFirst = false) : (joined += separator);
		        joined += v !== null && v !== undefined ? v.toString() : '';
		      });
		      return joined;
		    },

		    keys: function() {
		      return this.__iterator(ITERATE_KEYS);
		    },

		    map: function(mapper, context) {
		      return reify(this, mapFactory(this, mapper, context));
		    },

		    reduce: function(reducer, initialReduction, context) {
		      assertNotInfinite(this.size);
		      var reduction;
		      var useFirst;
		      if (arguments.length < 2) {
		        useFirst = true;
		      } else {
		        reduction = initialReduction;
		      }
		      this.__iterate(function(v, k, c)  {
		        if (useFirst) {
		          useFirst = false;
		          reduction = v;
		        } else {
		          reduction = reducer.call(context, reduction, v, k, c);
		        }
		      });
		      return reduction;
		    },

		    reduceRight: function(reducer, initialReduction, context) {
		      var reversed = this.toKeyedSeq().reverse();
		      return reversed.reduce.apply(reversed, arguments);
		    },

		    reverse: function() {
		      return reify(this, reverseFactory(this, true));
		    },

		    slice: function(begin, end) {
		      return reify(this, sliceFactory(this, begin, end, true));
		    },

		    some: function(predicate, context) {
		      return !this.every(not(predicate), context);
		    },

		    sort: function(comparator) {
		      return reify(this, sortFactory(this, comparator));
		    },

		    values: function() {
		      return this.__iterator(ITERATE_VALUES);
		    },


		    // ### More sequential methods

		    butLast: function() {
		      return this.slice(0, -1);
		    },

		    isEmpty: function() {
		      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});
		    },

		    count: function(predicate, context) {
		      return ensureSize(
		        predicate ? this.toSeq().filter(predicate, context) : this
		      );
		    },

		    countBy: function(grouper, context) {
		      return countByFactory(this, grouper, context);
		    },

		    equals: function(other) {
		      return deepEqual(this, other);
		    },

		    entrySeq: function() {
		      var iterable = this;
		      if (iterable._cache) {
		        // We cache as an entries array, so we can just return the cache!
		        return new ArraySeq(iterable._cache);
		      }
		      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
		      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};
		      return entriesSequence;
		    },

		    filterNot: function(predicate, context) {
		      return this.filter(not(predicate), context);
		    },

		    findEntry: function(predicate, context, notSetValue) {
		      var found = notSetValue;
		      this.__iterate(function(v, k, c)  {
		        if (predicate.call(context, v, k, c)) {
		          found = [k, v];
		          return false;
		        }
		      });
		      return found;
		    },

		    findKey: function(predicate, context) {
		      var entry = this.findEntry(predicate, context);
		      return entry && entry[0];
		    },

		    findLast: function(predicate, context, notSetValue) {
		      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
		    },

		    findLastEntry: function(predicate, context, notSetValue) {
		      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
		    },

		    findLastKey: function(predicate, context) {
		      return this.toKeyedSeq().reverse().findKey(predicate, context);
		    },

		    first: function() {
		      return this.find(returnTrue);
		    },

		    flatMap: function(mapper, context) {
		      return reify(this, flatMapFactory(this, mapper, context));
		    },

		    flatten: function(depth) {
		      return reify(this, flattenFactory(this, depth, true));
		    },

		    fromEntrySeq: function() {
		      return new FromEntriesSequence(this);
		    },

		    get: function(searchKey, notSetValue) {
		      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);
		    },

		    getIn: function(searchKeyPath, notSetValue) {
		      var nested = this;
		      // Note: in an ES6 environment, we would prefer:
		      // for (var key of searchKeyPath) {
		      var iter = forceIterator(searchKeyPath);
		      var step;
		      while (!(step = iter.next()).done) {
		        var key = step.value;
		        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
		        if (nested === NOT_SET) {
		          return notSetValue;
		        }
		      }
		      return nested;
		    },

		    groupBy: function(grouper, context) {
		      return groupByFactory(this, grouper, context);
		    },

		    has: function(searchKey) {
		      return this.get(searchKey, NOT_SET) !== NOT_SET;
		    },

		    hasIn: function(searchKeyPath) {
		      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
		    },

		    isSubset: function(iter) {
		      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
		      return this.every(function(value ) {return iter.includes(value)});
		    },

		    isSuperset: function(iter) {
		      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
		      return iter.isSubset(this);
		    },

		    keyOf: function(searchValue) {
		      return this.findKey(function(value ) {return is(value, searchValue)});
		    },

		    keySeq: function() {
		      return this.toSeq().map(keyMapper).toIndexedSeq();
		    },

		    last: function() {
		      return this.toSeq().reverse().first();
		    },

		    lastKeyOf: function(searchValue) {
		      return this.toKeyedSeq().reverse().keyOf(searchValue);
		    },

		    max: function(comparator) {
		      return maxFactory(this, comparator);
		    },

		    maxBy: function(mapper, comparator) {
		      return maxFactory(this, comparator, mapper);
		    },

		    min: function(comparator) {
		      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
		    },

		    minBy: function(mapper, comparator) {
		      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
		    },

		    rest: function() {
		      return this.slice(1);
		    },

		    skip: function(amount) {
		      return this.slice(Math.max(0, amount));
		    },

		    skipLast: function(amount) {
		      return reify(this, this.toSeq().reverse().skip(amount).reverse());
		    },

		    skipWhile: function(predicate, context) {
		      return reify(this, skipWhileFactory(this, predicate, context, true));
		    },

		    skipUntil: function(predicate, context) {
		      return this.skipWhile(not(predicate), context);
		    },

		    sortBy: function(mapper, comparator) {
		      return reify(this, sortFactory(this, comparator, mapper));
		    },

		    take: function(amount) {
		      return this.slice(0, Math.max(0, amount));
		    },

		    takeLast: function(amount) {
		      return reify(this, this.toSeq().reverse().take(amount).reverse());
		    },

		    takeWhile: function(predicate, context) {
		      return reify(this, takeWhileFactory(this, predicate, context));
		    },

		    takeUntil: function(predicate, context) {
		      return this.takeWhile(not(predicate), context);
		    },

		    valueSeq: function() {
		      return this.toIndexedSeq();
		    },


		    // ### Hashable Object

		    hashCode: function() {
		      return this.__hash || (this.__hash = hashIterable(this));
		    }


		    // ### Internal

		    // abstract __iterate(fn, reverse)

		    // abstract __iterator(type, reverse)
		  });

		  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
		  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
		  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
		  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

		  var IterablePrototype = Iterable.prototype;
		  IterablePrototype[IS_ITERABLE_SENTINEL] = true;
		  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
		  IterablePrototype.__toJS = IterablePrototype.toArray;
		  IterablePrototype.__toStringMapper = quoteString;
		  IterablePrototype.inspect =
		  IterablePrototype.toSource = function() { return this.toString(); };
		  IterablePrototype.chain = IterablePrototype.flatMap;
		  IterablePrototype.contains = IterablePrototype.includes;

		  mixin(KeyedIterable, {

		    // ### More sequential methods

		    flip: function() {
		      return reify(this, flipFactory(this));
		    },

		    mapEntries: function(mapper, context) {var this$0 = this;
		      var iterations = 0;
		      return reify(this,
		        this.toSeq().map(
		          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}
		        ).fromEntrySeq()
		      );
		    },

		    mapKeys: function(mapper, context) {var this$0 = this;
		      return reify(this,
		        this.toSeq().flip().map(
		          function(k, v)  {return mapper.call(context, k, v, this$0)}
		        ).flip()
		      );
		    }

		  });

		  var KeyedIterablePrototype = KeyedIterable.prototype;
		  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
		  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
		  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
		  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};



		  mixin(IndexedIterable, {

		    // ### Conversion to other types

		    toKeyedSeq: function() {
		      return new ToKeyedSequence(this, false);
		    },


		    // ### ES6 Collection methods (ES6 Array and Map)

		    filter: function(predicate, context) {
		      return reify(this, filterFactory(this, predicate, context, false));
		    },

		    findIndex: function(predicate, context) {
		      var entry = this.findEntry(predicate, context);
		      return entry ? entry[0] : -1;
		    },

		    indexOf: function(searchValue) {
		      var key = this.keyOf(searchValue);
		      return key === undefined ? -1 : key;
		    },

		    lastIndexOf: function(searchValue) {
		      var key = this.lastKeyOf(searchValue);
		      return key === undefined ? -1 : key;
		    },

		    reverse: function() {
		      return reify(this, reverseFactory(this, false));
		    },

		    slice: function(begin, end) {
		      return reify(this, sliceFactory(this, begin, end, false));
		    },

		    splice: function(index, removeNum /*, ...values*/) {
		      var numArgs = arguments.length;
		      removeNum = Math.max(removeNum | 0, 0);
		      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
		        return this;
		      }
		      // If index is negative, it should resolve relative to the size of the
		      // collection. However size may be expensive to compute if not cached, so
		      // only call count() if the number is in fact negative.
		      index = resolveBegin(index, index < 0 ? this.count() : this.size);
		      var spliced = this.slice(0, index);
		      return reify(
		        this,
		        numArgs === 1 ?
		          spliced :
		          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
		      );
		    },


		    // ### More collection methods

		    findLastIndex: function(predicate, context) {
		      var entry = this.findLastEntry(predicate, context);
		      return entry ? entry[0] : -1;
		    },

		    first: function() {
		      return this.get(0);
		    },

		    flatten: function(depth) {
		      return reify(this, flattenFactory(this, depth, false));
		    },

		    get: function(index, notSetValue) {
		      index = wrapIndex(this, index);
		      return (index < 0 || (this.size === Infinity ||
		          (this.size !== undefined && index > this.size))) ?
		        notSetValue :
		        this.find(function(_, key)  {return key === index}, undefined, notSetValue);
		    },

		    has: function(index) {
		      index = wrapIndex(this, index);
		      return index >= 0 && (this.size !== undefined ?
		        this.size === Infinity || index < this.size :
		        this.indexOf(index) !== -1
		      );
		    },

		    interpose: function(separator) {
		      return reify(this, interposeFactory(this, separator));
		    },

		    interleave: function(/*...iterables*/) {
		      var iterables = [this].concat(arrCopy(arguments));
		      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
		      var interleaved = zipped.flatten(true);
		      if (zipped.size) {
		        interleaved.size = zipped.size * iterables.length;
		      }
		      return reify(this, interleaved);
		    },

		    keySeq: function() {
		      return Range(0, this.size);
		    },

		    last: function() {
		      return this.get(-1);
		    },

		    skipWhile: function(predicate, context) {
		      return reify(this, skipWhileFactory(this, predicate, context, false));
		    },

		    zip: function(/*, ...iterables */) {
		      var iterables = [this].concat(arrCopy(arguments));
		      return reify(this, zipWithFactory(this, defaultZipper, iterables));
		    },

		    zipWith: function(zipper/*, ...iterables */) {
		      var iterables = arrCopy(arguments);
		      iterables[0] = this;
		      return reify(this, zipWithFactory(this, zipper, iterables));
		    }

		  });

		  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
		  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;



		  mixin(SetIterable, {

		    // ### ES6 Collection methods (ES6 Array and Map)

		    get: function(value, notSetValue) {
		      return this.has(value) ? value : notSetValue;
		    },

		    includes: function(value) {
		      return this.has(value);
		    },


		    // ### More sequential methods

		    keySeq: function() {
		      return this.valueSeq();
		    }

		  });

		  SetIterable.prototype.has = IterablePrototype.includes;
		  SetIterable.prototype.contains = SetIterable.prototype.includes;


		  // Mixin subclasses

		  mixin(KeyedSeq, KeyedIterable.prototype);
		  mixin(IndexedSeq, IndexedIterable.prototype);
		  mixin(SetSeq, SetIterable.prototype);

		  mixin(KeyedCollection, KeyedIterable.prototype);
		  mixin(IndexedCollection, IndexedIterable.prototype);
		  mixin(SetCollection, SetIterable.prototype);


		  // #pragma Helper functions

		  function keyMapper(v, k) {
		    return k;
		  }

		  function entryMapper(v, k) {
		    return [k, v];
		  }

		  function not(predicate) {
		    return function() {
		      return !predicate.apply(this, arguments);
		    }
		  }

		  function neg(predicate) {
		    return function() {
		      return -predicate.apply(this, arguments);
		    }
		  }

		  function quoteString(value) {
		    return typeof value === 'string' ? JSON.stringify(value) : String(value);
		  }

		  function defaultZipper() {
		    return arrCopy(arguments);
		  }

		  function defaultNegComparator(a, b) {
		    return a < b ? 1 : a > b ? -1 : 0;
		  }

		  function hashIterable(iterable) {
		    if (iterable.size === Infinity) {
		      return 0;
		    }
		    var ordered = isOrdered(iterable);
		    var keyed = isKeyed(iterable);
		    var h = ordered ? 1 : 0;
		    var size = iterable.__iterate(
		      keyed ?
		        ordered ?
		          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :
		          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :
		        ordered ?
		          function(v ) { h = 31 * h + hash(v) | 0; } :
		          function(v ) { h = h + hash(v) | 0; }
		    );
		    return murmurHashOfSize(size, h);
		  }

		  function murmurHashOfSize(size, h) {
		    h = imul(h, 0xCC9E2D51);
		    h = imul(h << 15 | h >>> -15, 0x1B873593);
		    h = imul(h << 13 | h >>> -13, 5);
		    h = (h + 0xE6546B64 | 0) ^ size;
		    h = imul(h ^ h >>> 16, 0x85EBCA6B);
		    h = imul(h ^ h >>> 13, 0xC2B2AE35);
		    h = smi(h ^ h >>> 16);
		    return h;
		  }

		  function hashMerge(a, b) {
		    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
		  }

		  var Immutable = {

		    Iterable: Iterable,

		    Seq: Seq,
		    Collection: Collection,
		    Map: Map,
		    OrderedMap: OrderedMap,
		    List: List,
		    Stack: Stack,
		    Set: Set,
		    OrderedSet: OrderedSet,

		    Record: Record,
		    Range: Range,
		    Repeat: Repeat,

		    is: is,
		    fromJS: fromJS

		  };

		  return Immutable;

		}));

	/***/ }),
	/* 21 */,
	/* 22 */,
	/* 23 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		var _propTypes = __webpack_require__(3);

		var _propTypes2 = _interopRequireDefault(_propTypes);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		var React = __webpack_require__(2);
		var shallowCloneObject = __webpack_require__(38);


		var contextTypes = {
		  metricsComputator: _propTypes2['default'].object
		};

		var MetricsComputatorMixin = {

		  childContextTypes: contextTypes,

		  getChildContext: function getChildContext() {
		    return { metricsComputator: this };
		  },
		  getMetricImpl: function getMetricImpl(name) {
		    return this._DOMMetrics.metrics[name].value;
		  },
		  registerMetricsImpl: function registerMetricsImpl(component, metrics) {
		    var getters = {};
		    var s = this._DOMMetrics;

		    for (var name in metrics) {
		      if (s.metrics[name] !== undefined) {
		        throw new Error('DOM metric ' + name + ' is already defined');
		      }
		      s.metrics[name] = { component: component, computator: metrics[name].bind(component) };
		      getters[name] = this.getMetricImpl.bind(null, name);
		    }

		    if (s.components.indexOf(component) === -1) {
		      s.components.push(component);
		    }

		    return getters;
		  },
		  unregisterMetricsFor: function unregisterMetricsFor(component) {
		    var s = this._DOMMetrics;
		    var idx = s.components.indexOf(component);

		    if (idx > -1) {
		      s.components.splice(idx, 1);

		      var name = void 0;
		      var metricsToDelete = {};

		      for (name in s.metrics) {
		        if (s.metrics[name].component === component) {
		          metricsToDelete[name] = true;
		        }
		      }

		      for (name in metricsToDelete) {
		        if (metricsToDelete.hasOwnProperty(name)) {
		          delete s.metrics[name];
		        }
		      }
		    }
		  },
		  updateMetrics: function updateMetrics() {
		    var s = this._DOMMetrics;

		    var needUpdate = false;

		    for (var name in s.metrics) {
		      if (!s.metrics.hasOwnProperty(name)) continue;

		      var newMetric = s.metrics[name].computator();
		      if (newMetric !== s.metrics[name].value) {
		        needUpdate = true;
		      }
		      s.metrics[name].value = newMetric;
		    }

		    if (needUpdate) {
		      for (var i = 0, len = s.components.length; i < len; i++) {
		        if (s.components[i].metricsUpdated) {
		          s.components[i].metricsUpdated();
		        }
		      }
		    }
		  },
		  componentWillMount: function componentWillMount() {
		    this._DOMMetrics = {
		      metrics: {},
		      components: []
		    };
		  },
		  componentDidMount: function componentDidMount() {
		    if (window.addEventListener) {
		      window.addEventListener('resize', this.updateMetrics);
		    } else {
		      window.attachEvent('resize', this.updateMetrics);
		    }
		    this.updateMetrics();
		  },
		  componentWillUnmount: function componentWillUnmount() {
		    window.removeEventListener('resize', this.updateMetrics);
		  }
		};

		var MetricsMixin = {

		  contextTypes: contextTypes,

		  componentWillMount: function componentWillMount() {
		    if (this.DOMMetrics) {
		      this._DOMMetricsDefs = shallowCloneObject(this.DOMMetrics);

		      this.DOMMetrics = {};
		      for (var name in this._DOMMetricsDefs) {
		        if (!this._DOMMetricsDefs.hasOwnProperty(name)) continue;

		        this.DOMMetrics[name] = function () {};
		      }
		    }
		  },
		  componentDidMount: function componentDidMount() {
		    if (this.DOMMetrics) {
		      this.DOMMetrics = this.registerMetrics(this._DOMMetricsDefs);
		    }
		  },
		  componentWillUnmount: function componentWillUnmount() {
		    if (!this.registerMetricsImpl) {
		      return this.context.metricsComputator.unregisterMetricsFor(this);
		    }
		    if (this.hasOwnProperty('DOMMetrics')) {
		      delete this.DOMMetrics;
		    }
		  },
		  registerMetrics: function registerMetrics(metrics) {
		    if (this.registerMetricsImpl) {
		      return this.registerMetricsImpl(this, metrics);
		    }

		    return this.context.metricsComputator.registerMetricsImpl(this, metrics);
		  },
		  getMetric: function getMetric(name) {
		    if (this.getMetricImpl) {
		      return this.getMetricImpl(name);
		    }

		    return this.context.metricsComputator.getMetricImpl(name);
		  }
		};

		module.exports = {
		  MetricsComputatorMixin: MetricsComputatorMixin,
		  MetricsMixin: MetricsMixin
		};

	/***/ }),
	/* 24 */
	/***/ (function(module, exports) {

		'use strict';

		var isFunction = function isFunction(functionToCheck) {
		  var getType = {};
		  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
		};

		module.exports = isFunction;

	/***/ }),
	/* 25 */,
	/* 26 */
	19,
	/* 27 */,
	/* 28 */
	19,
	/* 29 */,
	/* 30 */,
	/* 31 */,
	/* 32 */,
	/* 33 */,
	/* 34 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		var _keyMirror = __webpack_require__(216);

		var _keyMirror2 = _interopRequireDefault(_keyMirror);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		var constants = {
		  UpdateActions: (0, _keyMirror2['default'])({
		    CELL_UPDATE: null,
		    COLUMN_FILL: null,
		    COPY_PASTE: null,
		    CELL_DRAG: null
		  }),
		  DragItemTypes: {
		    Column: 'column'
		  },
		  CellExpand: {
		    DOWN_TRIANGLE: String.fromCharCode('9660'),
		    RIGHT_TRIANGLE: String.fromCharCode('9654')
		  }
		};

		module.exports = constants;

	/***/ }),
	/* 35 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		var shallowCloneObject = __webpack_require__(38);
		var sameColumn = __webpack_require__(182);
		var ColumnUtils = __webpack_require__(9);
		var getScrollbarSize = __webpack_require__(37);
		var isColumnsImmutable = __webpack_require__(72);

		function setColumnWidths(columns, totalWidth) {
		  return columns.map(function (column) {
		    var colInfo = Object.assign({}, column);
		    if (column.width) {
		      if (/^([0-9]+)%$/.exec(column.width.toString())) {
		        colInfo.width = Math.floor(column.width / 100 * totalWidth);
		      }
		    }
		    return colInfo;
		  });
		}

		function setDefferedColumnWidths(columns, unallocatedWidth, minColumnWidth) {
		  var defferedColumns = columns.filter(function (c) {
		    return !c.width;
		  });
		  return columns.map(function (column) {
		    if (!column.width && column.width !== 0) {
		      if (unallocatedWidth <= 0) {
		        column.width = minColumnWidth;
		      } else {
		        var columnWidth = Math.floor(unallocatedWidth / ColumnUtils.getSize(defferedColumns));
		        if (columnWidth < minColumnWidth) {
		          column.width = minColumnWidth;
		        } else {
		          column.width = columnWidth;
		        }
		      }
		    }
		    return column;
		  });
		}

		function setColumnOffsets(columns) {
		  var left = 0;
		  return columns.map(function (column) {
		    column.left = left;
		    left += column.width;
		    return column;
		  });
		}

		/**
		 * Update column metrics calculation.
		 *
		 * @param {ColumnMetricsType} metrics
		 */
		function recalculate(metrics) {
		  // compute width for columns which specify width
		  var columns = setColumnWidths(metrics.columns, metrics.totalWidth);

		  var unallocatedWidth = columns.filter(function (c) {
		    return c.width;
		  }).reduce(function (w, column) {
		    return w - column.width;
		  }, metrics.totalWidth);
		  unallocatedWidth -= getScrollbarSize();

		  var width = columns.filter(function (c) {
		    return c.width;
		  }).reduce(function (w, column) {
		    return w + column.width;
		  }, 0);

		  // compute width for columns which doesn't specify width
		  columns = setDefferedColumnWidths(columns, unallocatedWidth, metrics.minColumnWidth);

		  // compute left offset
		  columns = setColumnOffsets(columns);

		  return {
		    columns: columns,
		    width: width,
		    totalWidth: metrics.totalWidth,
		    minColumnWidth: metrics.minColumnWidth
		  };
		}

		/**
		 * Update column metrics calculation by resizing a column.
		 *
		 * @param {ColumnMetricsType} metrics
		 * @param {Column} column
		 * @param {number} width
		 */
		function resizeColumn(metrics, index, width) {
		  var column = ColumnUtils.getColumn(metrics.columns, index);
		  var metricsClone = shallowCloneObject(metrics);
		  metricsClone.columns = metrics.columns.slice(0);

		  var updatedColumn = shallowCloneObject(column);
		  updatedColumn.width = Math.max(width, metricsClone.minColumnWidth);

		  metricsClone = ColumnUtils.spliceColumn(metricsClone, index, updatedColumn);

		  return recalculate(metricsClone);
		}

		function areColumnsImmutable(prevColumns, nextColumns) {
		  return isColumnsImmutable(prevColumns) && isColumnsImmutable(nextColumns);
		}

		function compareEachColumn(prevColumns, nextColumns, isSameColumn) {
		  var i = void 0;
		  var len = void 0;
		  var column = void 0;
		  var prevColumnsByKey = {};
		  var nextColumnsByKey = {};

		  if (ColumnUtils.getSize(prevColumns) !== ColumnUtils.getSize(nextColumns)) {
		    return false;
		  }

		  for (i = 0, len = ColumnUtils.getSize(prevColumns); i < len; i++) {
		    column = prevColumns[i];
		    prevColumnsByKey[column.key] = column;
		  }

		  for (i = 0, len = ColumnUtils.getSize(nextColumns); i < len; i++) {
		    column = nextColumns[i];
		    nextColumnsByKey[column.key] = column;
		    var prevColumn = prevColumnsByKey[column.key];
		    if (prevColumn === undefined || !isSameColumn(prevColumn, column)) {
		      return false;
		    }
		  }

		  for (i = 0, len = ColumnUtils.getSize(prevColumns); i < len; i++) {
		    column = prevColumns[i];
		    var nextColumn = nextColumnsByKey[column.key];
		    if (nextColumn === undefined) {
		      return false;
		    }
		  }
		  return true;
		}

		function sameColumns(prevColumns, nextColumns, isSameColumn) {
		  if (areColumnsImmutable(prevColumns, nextColumns)) {
		    return prevColumns === nextColumns;
		  }

		  return compareEachColumn(prevColumns, nextColumns, isSameColumn);
		}

		module.exports = { recalculate: recalculate, resizeColumn: resizeColumn, sameColumn: sameColumn, sameColumns: sameColumns };

	/***/ }),
	/* 36 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

		var _OverflowCell = __webpack_require__(192);

		var _OverflowCell2 = _interopRequireDefault(_OverflowCell);

		var _RowComparer = __webpack_require__(64);

		var _RowComparer2 = _interopRequireDefault(_RowComparer);

		var _propTypes = __webpack_require__(3);

		var _propTypes2 = _interopRequireDefault(_propTypes);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

		var React = __webpack_require__(2);

		var createReactClass = __webpack_require__(10);
		var joinClasses = __webpack_require__(8);
		var Cell = __webpack_require__(61);
		var ColumnUtilsMixin = __webpack_require__(9);
		var cellMetaDataShape = __webpack_require__(11);
		var createObjectWithProperties = __webpack_require__(18);
		__webpack_require__(28);

		var CellExpander = function (_React$Component) {
		  _inherits(CellExpander, _React$Component);

		  function CellExpander() {
		    _classCallCheck(this, CellExpander);

		    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
		  }

		  CellExpander.prototype.render = function render() {
		    return React.createElement(Cell, this.props);
		  };

		  return CellExpander;
		}(React.Component);

		// The list of the propTypes that we want to include in the Row div


		var knownDivPropertyKeys = ['height'];

		var Row = createReactClass({
		  displayName: 'Row',

		  propTypes: {
		    height: _propTypes2['default'].number.isRequired,
		    columns: _propTypes2['default'].oneOfType([_propTypes2['default'].object, _propTypes2['default'].array]).isRequired,
		    row: _propTypes2['default'].any.isRequired,
		    cellRenderer: _propTypes2['default'].func,
		    cellMetaData: _propTypes2['default'].shape(cellMetaDataShape),
		    isSelected: _propTypes2['default'].bool,
		    idx: _propTypes2['default'].number.isRequired,
		    expandedRows: _propTypes2['default'].arrayOf(_propTypes2['default'].object),
		    extraClasses: _propTypes2['default'].string,
		    forceUpdate: _propTypes2['default'].bool,
		    subRowDetails: _propTypes2['default'].object,
		    isRowHovered: _propTypes2['default'].bool,
		    colVisibleStart: _propTypes2['default'].number.isRequired,
		    colVisibleEnd: _propTypes2['default'].number.isRequired,
		    colDisplayStart: _propTypes2['default'].number.isRequired,
		    colDisplayEnd: _propTypes2['default'].number.isRequired,
		    isScrolling: _propTypes2['default'].bool.isRequired
		  },

		  mixins: [ColumnUtilsMixin],

		  getDefaultProps: function getDefaultProps() {
		    return {
		      cellRenderer: Cell,
		      isSelected: false,
		      height: 35
		    };
		  },
		  shouldComponentUpdate: function shouldComponentUpdate(nextProps) {
		    return (0, _RowComparer2['default'])(nextProps, this.props);
		  },
		  handleDragEnter: function handleDragEnter() {
		    var handleDragEnterRow = this.props.cellMetaData.handleDragEnterRow;
		    if (handleDragEnterRow) {
		      handleDragEnterRow(this.props.idx);
		    }
		  },
		  getSelectedColumn: function getSelectedColumn() {
		    if (this.props.cellMetaData) {
		      var selected = this.props.cellMetaData.selected;
		      if (selected && selected.idx) {
		        return this.getColumn(this.props.columns, selected.idx);
		      }
		    }
		  },
		  getCellRenderer: function getCellRenderer(columnKey) {
		    var CellRenderer = this.props.cellRenderer;
		    if (this.props.subRowDetails && this.props.subRowDetails.field === columnKey) {
		      return CellExpander;
		    }
		    return CellRenderer;
		  },
		  getCell: function getCell(column, i, selectedColumn) {
		    var _this2 = this;

		    var CellRenderer = this.props.cellRenderer;
		    var _props = this.props,
		        colVisibleStart = _props.colVisibleStart,
		        colVisibleEnd = _props.colVisibleEnd,
		        idx = _props.idx,
		        cellMetaData = _props.cellMetaData;
		    var key = column.key,
		        formatter = column.formatter,
		        locked = column.locked;

		    var baseCellProps = { key: key + '-' + idx, idx: i, rowIdx: idx, height: this.getRowHeight(), column: column, cellMetaData: cellMetaData };

		    if ((i < colVisibleStart || i > colVisibleEnd) && !locked) {
		      return React.createElement(_OverflowCell2['default'], _extends({ ref: function ref(node) {
		          return _this2[key] = node;
		        } }, baseCellProps));
		    }

		    var _props2 = this.props,
		        row = _props2.row,
		        isSelected = _props2.isSelected;

		    var cellProps = {
		      ref: function ref(node) {
		        return _this2[key] = node;
		      },
		      value: this.getCellValue(key || i),
		      rowData: row,
		      isRowSelected: isSelected,
		      expandableOptions: this.getExpandableOptions(key),
		      selectedColumn: selectedColumn,
		      formatter: formatter,
		      isScrolling: this.props.isScrolling
		    };

		    return React.createElement(CellRenderer, _extends({}, baseCellProps, cellProps));
		  },
		  getCells: function getCells() {
		    var _this3 = this;

		    var cells = [];
		    var lockedCells = [];
		    var selectedColumn = this.getSelectedColumn();
		    var lastColumnIdx = this.props.columns.size - 1;
		    if (this.props.columns) {
		      this.props.columns.forEach(function (column, i) {
		        if (i === lastColumnIdx) {
		          column.isLastColumn = true;
		        }
		        var cell = _this3.getCell(column, i, selectedColumn);
		        if (column.locked) {
		          lockedCells.push(cell);
		        } else {
		          cells.push(cell);
		        }
		      });
		    }

		    return cells.concat(lockedCells);
		  },
		  getRowHeight: function getRowHeight() {
		    var rows = this.props.expandedRows || null;
		    if (rows && this.props.idx) {
		      var row = rows[this.props.idx] || null;
		      if (row) {
		        return row.height;
		      }
		    }
		    return this.props.height;
		  },
		  getCellValue: function getCellValue(key) {
		    var val = void 0;
		    if (key === 'select-row') {
		      return this.props.isSelected;
		    } else if (typeof this.props.row.get === 'function') {
		      val = this.props.row.get(key);
		    } else {
		      val = this.props.row[key];
		    }
		    return val;
		  },
		  isContextMenuDisplayed: function isContextMenuDisplayed() {
		    if (this.props.cellMetaData) {
		      var selected = this.props.cellMetaData.selected;
		      if (selected && selected.contextMenuDisplayed && selected.rowIdx === this.props.idx) {
		        return true;
		      }
		    }
		    return false;
		  },
		  getExpandableOptions: function getExpandableOptions(columnKey) {
		    var subRowDetails = this.props.subRowDetails;
		    if (subRowDetails) {
		      return { canExpand: subRowDetails && subRowDetails.field === columnKey && (subRowDetails.children && subRowDetails.children.length > 0 || subRowDetails.group === true), field: subRowDetails.field, expanded: subRowDetails && subRowDetails.expanded, children: subRowDetails && subRowDetails.children, treeDepth: subRowDetails ? subRowDetails.treeDepth : 0, subRowDetails: subRowDetails };
		    }
		    return {};
		  },
		  setScrollLeft: function setScrollLeft(scrollLeft) {
		    var _this4 = this;

		    this.props.columns.forEach(function (column) {
		      if (column.locked) {
		        if (!_this4[column.key]) return;
		        _this4[column.key].setScrollLeft(scrollLeft);
		      }
		    });
		  },
		  getKnownDivProps: function getKnownDivProps() {
		    return createObjectWithProperties(this.props, knownDivPropertyKeys);
		  },
		  renderCell: function renderCell(props) {
		    if (typeof this.props.cellRenderer === 'function') {
		      this.props.cellRenderer.call(this, props);
		    }
		    if (React.isValidElement(this.props.cellRenderer)) {
		      return React.cloneElement(this.props.cellRenderer, props);
		    }

		    return this.props.cellRenderer(props);
		  },
		  render: function render() {
		    var className = joinClasses('react-grid-Row', 'react-grid-Row--' + (this.props.idx % 2 === 0 ? 'even' : 'odd'), {
		      'row-selected': this.props.isSelected,
		      'row-context-menu': this.isContextMenuDisplayed()
		    }, this.props.extraClasses);

		    var style = {
		      height: this.getRowHeight(this.props),
		      overflow: 'hidden',
		      contain: 'layout'
		    };

		    var cells = this.getCells();
		    return React.createElement(
		      'div',
		      _extends({}, this.getKnownDivProps(), { className: className, style: style, onDragEnter: this.handleDragEnter }),
		      React.isValidElement(this.props.row) ? this.props.row : cells
		    );
		  }
		});

		module.exports = Row;

	/***/ }),
	/* 37 */
	/***/ (function(module, exports) {

		'use strict';

		var size = void 0;

		function getScrollbarSize() {
		  if (size === undefined) {
		    var outer = document.createElement('div');
		    outer.style.width = '50px';
		    outer.style.height = '50px';
		    outer.style.position = 'absolute';
		    outer.style.top = '-200px';
		    outer.style.left = '-200px';

		    var inner = document.createElement('div');
		    inner.style.height = '100px';
		    inner.style.width = '100%';

		    outer.appendChild(inner);
		    document.body.appendChild(outer);

		    var outerWidth = outer.clientWidth;
		    outer.style.overflowY = 'scroll';
		    var innerWidth = inner.clientWidth;

		    document.body.removeChild(outer);

		    size = outerWidth - innerWidth;
		  }

		  return size;
		}

		module.exports = getScrollbarSize;

	/***/ }),
	/* 38 */
	/***/ (function(module, exports) {

		"use strict";

		function shallowCloneObject(obj) {
		  var result = {};
		  for (var k in obj) {
		    if (obj.hasOwnProperty(k)) {
		      result[k] = obj[k];
		    }
		  }
		  return result;
		}

		module.exports = shallowCloneObject;

	/***/ }),
	/* 39 */
	/***/ (function(module, exports) {

		'use strict';

		function ToObject(val) {
			if (val == null) {
				throw new TypeError('Object.assign cannot be called with null or undefined');
			}

			return Object(val);
		}

		module.exports = Object.assign || function (target, source) {
			var from;
			var keys;
			var to = ToObject(target);

			for (var s = 1; s < arguments.length; s++) {
				from = arguments[s];
				keys = Object.keys(Object(from));

				for (var i = 0; i < keys.length; i++) {
					to[keys[i]] = from[keys[i]];
				}
			}

			return to;
		};


	/***/ }),
	/* 40 */
	19,
	/* 41 */,
	/* 42 */,
	/* 43 */,
	/* 44 */,
	/* 45 */,
	/* 46 */,
	/* 47 */,
	/* 48 */,
	/* 49 */,
	/* 50 */,
	/* 51 */,
	/* 52 */,
	/* 53 */,
	/* 54 */,
	/* 55 */,
	/* 56 */,
	/* 57 */,
	/* 58 */,
	/* 59 */,
	/* 60 */,
	/* 61 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

		var _underscore = __webpack_require__(102);

		var _underscore2 = _interopRequireDefault(_underscore);

		var _propTypes = __webpack_require__(3);

		var _propTypes2 = _interopRequireDefault(_propTypes);

		var _CellAction = __webpack_require__(179);

		var _CellAction2 = _interopRequireDefault(_CellAction);

		var _CellExpand = __webpack_require__(180);

		var _CellExpand2 = _interopRequireDefault(_CellExpand);

		var _ChildRowDeleteButton = __webpack_require__(181);

		var _ChildRowDeleteButton2 = _interopRequireDefault(_ChildRowDeleteButton);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

		var React = __webpack_require__(2);

		var joinClasses = __webpack_require__(8);
		var EditorContainer = __webpack_require__(203);
		var ExcelColumn = __webpack_require__(12);
		var isFunction = __webpack_require__(24);
		var CellMetaDataShape = __webpack_require__(11);
		var SimpleCellFormatter = __webpack_require__(70);
		var ColumnUtils = __webpack_require__(9);
		var createObjectWithProperties = __webpack_require__(18);

		__webpack_require__(40);

		// The list of the propTypes that we want to include in the Cell div
		var knownDivPropertyKeys = ['height', 'tabIndex', 'value'];

		var Cell = function (_React$Component) {
		  _inherits(Cell, _React$Component);

		  function Cell() {
		    var _temp, _this, _ret;

		    _classCallCheck(this, Cell);

		    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
		      args[_key] = arguments[_key];
		    }

		    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
		      isCellValueChanging: false,
		      isLockChanging: false
		    }, _this.onCellClick = function (e) {
		      var meta = _this.props.cellMetaData;
		      if (meta != null && meta.onCellClick && typeof meta.onCellClick === 'function') {
		        meta.onCellClick({ rowIdx: _this.props.rowIdx, idx: _this.props.idx }, e);
		      }
		    }, _this.onCellContextMenu = function () {
		      var meta = _this.props.cellMetaData;
		      if (meta != null && meta.onCellContextMenu && typeof meta.onCellContextMenu === 'function') {
		        meta.onCellContextMenu({ rowIdx: _this.props.rowIdx, idx: _this.props.idx });
		      }
		    }, _this.onCellDoubleClick = function (e) {
		      var meta = _this.props.cellMetaData;
		      if (meta != null && meta.onCellDoubleClick && typeof meta.onCellDoubleClick === 'function') {
		        meta.onCellDoubleClick({ rowIdx: _this.props.rowIdx, idx: _this.props.idx }, e);
		      }
		    }, _this.onCellExpand = function (e) {
		      e.stopPropagation();
		      var meta = _this.props.cellMetaData;
		      if (meta != null && meta.onCellExpand != null) {
		        meta.onCellExpand({ rowIdx: _this.props.rowIdx, idx: _this.props.idx, rowData: _this.props.rowData, expandArgs: _this.props.expandableOptions });
		      }
		    }, _this.onCellKeyDown = function (e) {
		      if (_this.canExpand() && e.key === 'Enter') {
		        _this.onCellExpand(e);
		      }
		    }, _this.onDeleteSubRow = function () {
		      var meta = _this.props.cellMetaData;
		      if (meta != null && meta.onDeleteSubRow != null) {
		        meta.onDeleteSubRow({ rowIdx: _this.props.rowIdx, idx: _this.props.idx, rowData: _this.props.rowData, expandArgs: _this.props.expandableOptions });
		      }
		    }, _this.onDragHandleDoubleClick = function (e) {
		      e.stopPropagation();
		      var meta = _this.props.cellMetaData;
		      if (meta != null && meta.onDragHandleDoubleClick && typeof meta.onDragHandleDoubleClick === 'function') {
		        meta.onDragHandleDoubleClick({ rowIdx: _this.props.rowIdx, idx: _this.props.idx, rowData: _this.getRowData(), e: e });
		      }
		    }, _this.onDragOver = function (e) {
		      e.preventDefault();
		    }, _this.getStyle = function () {
		      var style = {
		        position: 'absolute',
		        width: _this.props.column.width,
		        height: _this.props.height,
		        left: _this.props.column.left,
		        contain: 'layout'
		      };
		      return style;
		    }, _this.getFormatter = function () {
		      var col = _this.props.column;
		      if (_this.isActive()) {
		        return React.createElement(EditorContainer, { rowData: _this.getRowData(), rowIdx: _this.props.rowIdx, value: _this.props.value, idx: _this.props.idx, cellMetaData: _this.props.cellMetaData, column: col, height: _this.props.height });
		      }

		      return _this.props.column.formatter;
		    }, _this.getRowData = function () {
		      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.props;

		      return props.rowData.toJSON ? props.rowData.toJSON() : props.rowData;
		    }, _this.getFormatterDependencies = function () {
		      // convention based method to get corresponding Id or Name of any Name or Id property
		      if (typeof _this.props.column.getRowMetaData === 'function') {
		        return _this.props.column.getRowMetaData(_this.getRowData(), _this.props.column);
		      }
		    }, _this.getCellClass = function () {
		      var className = joinClasses(_this.props.column.cellClass, 'react-grid-Cell', _this.props.className, _this.props.column.locked ? 'react-grid-Cell--locked' : null);
		      var extraClasses = joinClasses({
		        'row-selected': _this.props.isRowSelected,
		        editing: _this.isActive(),
		        copied: _this.isCopied() || _this.wasDraggedOver() || _this.isDraggedOverUpwards() || _this.isDraggedOverDownwards(),
		        'is-dragged-over-up': _this.isDraggedOverUpwards(),
		        'is-dragged-over-down': _this.isDraggedOverDownwards(),
		        'was-dragged-over': _this.wasDraggedOver(),
		        'cell-tooltip': _this.props.tooltip ? true : false,
		        'rdg-child-cell': _this.props.expandableOptions && _this.props.expandableOptions.subRowDetails && _this.props.expandableOptions.treeDepth > 0,
		        'last-column': _this.props.column.isLastColumn
		      });
		      return joinClasses(className, extraClasses);
		    }, _this.getUpdateCellClass = function () {
		      return _this.props.column.getUpdateCellClass ? _this.props.column.getUpdateCellClass(_this.props.selectedColumn, _this.props.column, _this.state.isCellValueChanging) : '';
		    }, _this.isColumnSelected = function () {
		      var meta = _this.props.cellMetaData;
		      if (meta == null) {
		        return false;
		      }

		      return meta.selected && meta.selected.idx === _this.props.idx;
		    }, _this.isSelected = function () {
		      var meta = _this.props.cellMetaData;
		      if (meta == null) {
		        return false;
		      }

		      return meta.selected && meta.selected.rowIdx === _this.props.rowIdx && meta.selected.idx === _this.props.idx;
		    }, _this.isActive = function () {
		      var meta = _this.props.cellMetaData;
		      if (meta == null) {
		        return false;
		      }
		      return _this.isSelected() && meta.selected.active === true;
		    }, _this.isCellSelectionChanging = function (nextProps) {
		      var meta = _this.props.cellMetaData;
		      if (meta == null) {
		        return false;
		      }
		      var nextSelected = nextProps.cellMetaData.selected;
		      if (meta.selected && nextSelected) {
		        return _this.props.idx === nextSelected.idx || _this.props.idx === meta.selected.idx;
		      }

		      return true;
		    }, _this.isCellSelectEnabled = function () {
		      var meta = _this.props.cellMetaData;
		      if (meta == null) {
		        return false;
		      }
		      return meta.enableCellSelect;
		    }, _this.hasChangedDependentValues = function (nextProps) {
		      var currentColumn = _this.props.column;
		      var hasChangedDependentValues = false;

		      if (currentColumn.getRowMetaData) {
		        var currentRowMetaData = currentColumn.getRowMetaData(_this.getRowData(), currentColumn);
		        var nextColumn = nextProps.column;
		        var nextRowMetaData = nextColumn.getRowMetaData(_this.getRowData(nextProps), nextColumn);

		        hasChangedDependentValues = !_underscore2['default'].isEqual(currentRowMetaData, nextRowMetaData);
		      }

		      return hasChangedDependentValues;
		    }, _this.applyUpdateClass = function () {
		      var updateCellClass = _this.getUpdateCellClass();
		      // -> removing the class
		      if (updateCellClass != null && updateCellClass !== '') {
		        var cellDOMNode = _this.node;
		        if (cellDOMNode.classList) {
		          cellDOMNode.classList.remove(updateCellClass);
		          // -> and re-adding the class
		          cellDOMNode.classList.add(updateCellClass);
		        } else if (cellDOMNode.className.indexOf(updateCellClass) === -1) {
		          // IE9 doesn't support classList, nor (I think) altering element.className
		          // without replacing it wholesale.
		          cellDOMNode.className = cellDOMNode.className + ' ' + updateCellClass;
		        }
		      }
		    }, _this.setScrollLeft = function (scrollLeft) {
		      var node = _this.node;
		      if (node) {
		        var transform = 'translate3d(' + scrollLeft + 'px, 0px, 0px)';
		        node.style.webkitTransform = transform;
		        node.style.transform = transform;
		      }
		    }, _this.removeScroll = function () {
		      var node = _this.node;
		      if (node) {
		        node.style.webkitTransform = null;
		        node.style.transform = null;
		      }
		    }, _this.isCopied = function () {
		      var copied = _this.props.cellMetaData.copied;
		      return copied && copied.rowIdx === _this.props.rowIdx && copied.idx === _this.props.idx;
		    }, _this.isDraggedOver = function () {
		      var dragged = _this.props.cellMetaData.dragged;
		      return dragged && dragged.overRowIdx === _this.props.rowIdx && dragged.idx === _this.props.idx;
		    }, _this.wasDraggedOver = function () {
		      var dragged = _this.props.cellMetaData.dragged;
		      return dragged && (dragged.overRowIdx < _this.props.rowIdx && _this.props.rowIdx < dragged.rowIdx || dragged.overRowIdx > _this.props.rowIdx && _this.props.rowIdx > dragged.rowIdx) && dragged.idx === _this.props.idx;
		    }, _this.isDraggedCellChanging = function (nextProps) {
		      var isChanging = void 0;
		      var dragged = _this.props.cellMetaData.dragged;
		      var nextDragged = nextProps.cellMetaData.dragged;
		      if (dragged) {
		        isChanging = nextDragged && _this.props.idx === nextDragged.idx || dragged && _this.props.idx === dragged.idx;
		        return isChanging;
		      }

		      return false;
		    }, _this.isCopyCellChanging = function (nextProps) {
		      var isChanging = void 0;
		      var copied = _this.props.cellMetaData.copied;
		      var nextCopied = nextProps.cellMetaData.copied;
		      if (copied) {
		        isChanging = nextCopied && _this.props.idx === nextCopied.idx || copied && _this.props.idx === copied.idx;
		        return isChanging;
		      }
		      return false;
		    }, _this.isDraggedOverUpwards = function () {
		      var dragged = _this.props.cellMetaData.dragged;
		      return !_this.isSelected() && _this.isDraggedOver() && _this.props.rowIdx < dragged.rowIdx;
		    }, _this.isDraggedOverDownwards = function () {
		      var dragged = _this.props.cellMetaData.dragged;
		      return !_this.isSelected() && _this.isDraggedOver() && _this.props.rowIdx > dragged.rowIdx;
		    }, _this.isFocusedOnBody = function () {
		      return document.activeElement == null || document.activeElement.nodeName && typeof document.activeElement.nodeName === 'string' && document.activeElement.nodeName.toLowerCase() === 'body';
		    }, _this.isFocusedOnCell = function () {
		      return document.activeElement && document.activeElement.className === 'react-grid-Cell';
		    }, _this.checkFocus = function () {
		      if (_this.isSelected() && !_this.isActive()) {
		        if (_this.props.isScrolling && !_this.props.cellMetaData.isScrollingVerticallyWithKeyboard && !_this.props.cellMetaData.isScrollingHorizontallyWithKeyboard) {
		          return;
		        }
		        // If the enableCellAutoFocus is set in the ReactDataGrid props, it will allow the cell to take focus when the browser is focused on the body.
		        // Otherwise, only focus to the current cell if the currently active node in the document is within the data grid.
		        // Meaning focus should not be stolen from elements that the grid doesnt control.
		        var cellAutoFocusEnabled = _this.props.cellMetaData && _this.props.cellMetaData.enableCellAutoFocus;
		        var dataGridDOMNode = _this.props.cellMetaData && _this.props.cellMetaData.getDataGridDOMNode ? _this.props.cellMetaData.getDataGridDOMNode() : null;
		        if (_this.isFocusedOnCell() || cellAutoFocusEnabled && _this.isFocusedOnBody() || dataGridDOMNode && dataGridDOMNode.contains(document.activeElement)) {
		          var cellDOMNode = _this.node;
		          if (cellDOMNode) {
		            cellDOMNode.focus();
		          }
		        }
		      }
		    }, _this.canEdit = function () {
		      return _this.props.column.editor != null || _this.props.column.editable;
		    }, _this.canExpand = function () {
		      return _this.props.expandableOptions && _this.props.expandableOptions.canExpand;
		    }, _this.createColumEventCallBack = function (onColumnEvent, info) {
		      return function (e) {
		        onColumnEvent(e, info);
		      };
		    }, _this.createCellEventCallBack = function (gridEvent, columnEvent) {
		      return function (e) {
		        gridEvent(e);
		        columnEvent(e);
		      };
		    }, _this.createEventDTO = function (gridEvents, columnEvents, onColumnEvent) {
		      var allEvents = Object.assign({}, gridEvents);

		      for (var eventKey in columnEvents) {
		        if (columnEvents.hasOwnProperty(eventKey)) {
		          var event = columnEvents[event];
		          var eventInfo = { idx: _this.props.idx, rowIdx: _this.props.rowIdx, rowId: _this.props.rowData[_this.props.cellMetaData.rowKey], name: eventKey };
		          var eventCallback = _this.createColumEventCallBack(onColumnEvent, eventInfo);

		          if (allEvents.hasOwnProperty(eventKey)) {
		            var currentEvent = allEvents[eventKey];
		            allEvents[eventKey] = _this.createCellEventCallBack(currentEvent, eventCallback);
		          } else {
		            allEvents[eventKey] = eventCallback;
		          }
		        }
		      }

		      return allEvents;
		    }, _this.getEvents = function () {
		      var columnEvents = _this.props.column ? Object.assign({}, _this.props.column.events) : undefined;
		      var onColumnEvent = _this.props.cellMetaData ? _this.props.cellMetaData.onColumnEvent : undefined;
		      var gridEvents = {
		        onClick: _this.onCellClick,
		        onDoubleClick: _this.onCellDoubleClick,
		        onContextMenu: _this.onCellContextMenu,
		        onDragOver: _this.onDragOver
		      };

		      if (!columnEvents || !onColumnEvent) {
		        return gridEvents;
		      }

		      return _this.createEventDTO(gridEvents, columnEvents, onColumnEvent);
		    }, _this.getKnownDivProps = function () {
		      return createObjectWithProperties(_this.props, knownDivPropertyKeys);
		    }, _this.renderCellContent = function (props) {
		      var CellContent = void 0;
		      var Formatter = _this.getFormatter();
		      if (React.isValidElement(Formatter)) {
		        props.dependentValues = _this.getFormatterDependencies();
		        CellContent = React.cloneElement(Formatter, props);
		      } else if (isFunction(Formatter)) {
		        CellContent = React.createElement(Formatter, { value: _this.props.value, dependentValues: _this.getFormatterDependencies() });
		      } else {
		        CellContent = React.createElement(SimpleCellFormatter, { value: _this.props.value });
		      }
		      var isExpandCell = _this.props.expandableOptions ? _this.props.expandableOptions.field === _this.props.column.key : false;
		      var treeDepth = _this.props.expandableOptions ? _this.props.expandableOptions.treeDepth : 0;
		      var marginLeft = _this.props.expandableOptions && isExpandCell ? _this.props.expandableOptions.treeDepth * 30 : 0;
		      var cellExpander = void 0;
		      var cellDeleter = void 0;
		      if (_this.canExpand()) {
		        cellExpander = React.createElement(_CellExpand2['default'], { expandableOptions: _this.props.expandableOptions, onCellExpand: _this.onCellExpand });
		      }

		      var isDeleteSubRowEnabled = _this.props.cellMetaData.onDeleteSubRow ? true : false;

		      if (treeDepth > 0 && isExpandCell) {
		        cellDeleter = React.createElement(_ChildRowDeleteButton2['default'], { treeDepth: treeDepth, cellHeight: _this.props.height, siblingIndex: _this.props.expandableOptions.subRowDetails.siblingIndex, numberSiblings: _this.props.expandableOptions.subRowDetails.numberSiblings, onDeleteSubRow: _this.onDeleteSubRow, isDeleteSubRowEnabled: isDeleteSubRowEnabled });
		      }
		      return React.createElement(
		        'div',
		        { className: 'react-grid-Cell__value' },
		        cellDeleter,
		        React.createElement(
		          'div',
		          { style: { marginLeft: marginLeft } },
		          React.createElement(
		            'span',
		            null,
		            CellContent
		          ),
		          ' ',
		          _this.props.cellControls,
		          ' ',
		          cellExpander
		        )
		      );
		    }, _temp), _possibleConstructorReturn(_this, _ret);
		  }

		  Cell.prototype.componentDidMount = function componentDidMount() {
		    this.checkFocus();
		  };

		  Cell.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
		    this.setState({
		      isCellValueChanging: this.props.isCellValueChanging(this.props.value, nextProps.value),
		      isLockChanging: this.props.column.locked !== nextProps.column.locked
		    });
		  };

		  Cell.prototype.componentDidUpdate = function componentDidUpdate() {
		    this.checkFocus();
		    var dragged = this.props.cellMetaData.dragged;
		    if (dragged && dragged.complete === true) {
		      this.props.cellMetaData.handleTerminateDrag();
		    }
		    if (this.state.isCellValueChanging && this.props.selectedColumn != null) {
		      this.applyUpdateClass();
		    }
		    if (this.state.isLockChanging && !this.props.column.locked) {
		      this.removeScroll();
		    }
		  };

		  Cell.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
		    var shouldUpdate = this.props.column.width !== nextProps.column.width || this.props.column.left !== nextProps.column.left || this.props.column.cellClass !== nextProps.column.cellClass || this.props.height !== nextProps.height || this.props.rowIdx !== nextProps.rowIdx || this.isCellSelectionChanging(nextProps) || this.isDraggedCellChanging(nextProps) || this.isCopyCellChanging(nextProps) || this.props.isRowSelected !== nextProps.isRowSelected || this.isSelected() || this.props.isCellValueChanging(this.props.value, nextProps.value) || this.props.forceUpdate === true || this.props.className !== nextProps.className || this.props.expandableOptions !== nextProps.expandableOptions || this.hasChangedDependentValues(nextProps) || this.props.column.locked !== nextProps.column.locked;
		    return shouldUpdate;
		  };

		  Cell.prototype.getCellActions = function getCellActions() {
		    var _props = this.props,
		        cellMetaData = _props.cellMetaData,
		        column = _props.column,
		        rowData = _props.rowData;

		    if (cellMetaData && cellMetaData.getCellActions) {
		      var cellActions = cellMetaData.getCellActions(column, rowData);
		      if (cellActions && cellActions.length) {
		        return cellActions.map(function (action, index) {
		          return React.createElement(_CellAction2['default'], { action: action, isFirst: index === 0 });
		        });
		      }
		      return null;
		    }
		    return null;
		  };

		  Cell.prototype.render = function render() {
		    var _this2 = this;

		    if (this.props.column.hidden) {
		      return null;
		    }

		    var style = this.getStyle();

		    var className = this.getCellClass();

		    var cellActions = this.getCellActions();

		    var cellContent = this.props.children || this.renderCellContent({
		      value: this.props.value,
		      column: this.props.column,
		      rowIdx: this.props.rowIdx,
		      isExpanded: this.props.isExpanded
		    });

		    var dragHandle = !this.isActive() && ColumnUtils.canEdit(this.props.column, this.props.rowData, this.props.cellMetaData.enableCellSelect) ? React.createElement(
		      'div',
		      { className: 'drag-handle', draggable: 'true', onDoubleClick: this.onDragHandleDoubleClick },
		      React.createElement('span', { style: { display: 'none' } })
		    ) : null;
		    var events = this.getEvents();
		    var tooltip = this.props.tooltip ? React.createElement(
		      'span',
		      { className: 'cell-tooltip-text' },
		      this.props.tooltip
		    ) : null;

		    return React.createElement(
		      'div',
		      _extends({}, this.getKnownDivProps(), { className: className, style: style }, events, { ref: function ref(node) {
		          _this2.node = node;
		        } }),
		      cellActions,
		      cellContent,
		      dragHandle,
		      tooltip
		    );
		  };

		  return Cell;
		}(React.Component);

		Cell.propTypes = {
		  rowIdx: _propTypes2['default'].number.isRequired,
		  idx: _propTypes2['default'].number.isRequired,
		  selected: _propTypes2['default'].shape({
		    idx: _propTypes2['default'].number.isRequired
		  }),
		  selectedColumn: _propTypes2['default'].object,
		  height: _propTypes2['default'].number,
		  tabIndex: _propTypes2['default'].number,
		  column: _propTypes2['default'].shape(ExcelColumn).isRequired,
		  value: _propTypes2['default'].oneOfType([_propTypes2['default'].string, _propTypes2['default'].number, _propTypes2['default'].object, _propTypes2['default'].bool]),
		  isExpanded: _propTypes2['default'].bool,
		  isRowSelected: _propTypes2['default'].bool,
		  cellMetaData: _propTypes2['default'].shape(CellMetaDataShape).isRequired,
		  handleDragStart: _propTypes2['default'].func,
		  className: _propTypes2['default'].string,
		  cellControls: _propTypes2['default'].any,
		  rowData: _propTypes2['default'].object.isRequired,
		  forceUpdate: _propTypes2['default'].bool,
		  expandableOptions: _propTypes2['default'].object.isRequired,
		  isScrolling: _propTypes2['default'].bool.isRequired,
		  tooltip: _propTypes2['default'].string,
		  isCellValueChanging: _propTypes2['default'].func,
		  children: _propTypes2['default'].oneOfType([_propTypes2['default'].arrayOf(_propTypes2['default'].node), _propTypes2['default'].node])
		};
		Cell.defaultProps = {
		  tabIndex: -1,
		  isExpanded: false,
		  value: '',
		  isCellValueChanging: function isCellValueChanging(value, nextValue) {
		    return value !== nextValue;
		  }
		};


		module.exports = Cell;

	/***/ }),
	/* 62 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		var _propTypes = __webpack_require__(3);

		var _propTypes2 = _interopRequireDefault(_propTypes);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

		var React = __webpack_require__(2);
		var ReactDOM = __webpack_require__(5);
		var joinClasses = __webpack_require__(8);
		var ExcelColumn = __webpack_require__(12);
		var ResizeHandle = __webpack_require__(196);
		__webpack_require__(19);

		function simpleCellRenderer(objArgs) {
		  var headerText = objArgs.column.rowType === 'header' ? objArgs.column.name : '';
		  return React.createElement(
		    'div',
		    { className: 'widget-HeaderCell__value' },
		    headerText
		  );
		}

		var HeaderCell = function (_React$Component) {
		  _inherits(HeaderCell, _React$Component);

		  function HeaderCell() {
		    var _temp, _this, _ret;

		    _classCallCheck(this, HeaderCell);

		    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
		      args[_key] = arguments[_key];
		    }

		    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = { resizing: false }, _this.onDragStart = function (e) {
		      _this.setState({ resizing: true });
		      // need to set dummy data for FF
		      if (e && e.dataTransfer && e.dataTransfer.setData) e.dataTransfer.setData('text/plain', 'dummy');
		    }, _this.onDrag = function (e) {
		      var resize = _this.props.onResize || null; // for flows sake, doesnt recognise a null check direct
		      if (resize) {
		        var _width = _this.getWidthFromMouseEvent(e);
		        if (_width > 0) {
		          resize(_this.props.column, _width);
		        }
		      }
		    }, _this.onDragEnd = function (e) {
		      var width = _this.getWidthFromMouseEvent(e);
		      _this.props.onResizeEnd(_this.props.column, width);
		      _this.setState({ resizing: false });
		    }, _this.getWidthFromMouseEvent = function (e) {
		      var right = e.pageX || e.touches && e.touches[0] && e.touches[0].pageX || e.changedTouches && e.changedTouches[e.changedTouches.length - 1].pageX;
		      var left = ReactDOM.findDOMNode(_this).getBoundingClientRect().left;
		      return right - left;
		    }, _this.getCell = function () {
		      if (React.isValidElement(_this.props.renderer)) {
		        // if it is a string, it's an HTML element, and column is not a valid property, so only pass height
		        if (typeof _this.props.renderer.type === 'string') {
		          return React.cloneElement(_this.props.renderer, { height: _this.props.height });
		        }
		        return React.cloneElement(_this.props.renderer, { column: _this.props.column, height: _this.props.height });
		      }
		      return _this.props.renderer({ column: _this.props.column });
		    }, _this.getStyle = function () {
		      return {
		        width: _this.props.column.width,
		        left: _this.props.column.left,
		        display: 'inline-block',
		        position: 'absolute',
		        height: _this.props.height,
		        margin: 0,
		        textOverflow: 'ellipsis',
		        whiteSpace: 'nowrap'
		      };
		    }, _this.setScrollLeft = function (scrollLeft) {
		      var node = ReactDOM.findDOMNode(_this);
		      node.style.webkitTransform = 'translate3d(' + scrollLeft + 'px, 0px, 0px)';
		      node.style.transform = 'translate3d(' + scrollLeft + 'px, 0px, 0px)';
		    }, _this.removeScroll = function () {
		      var node = ReactDOM.findDOMNode(_this);
		      if (node) {
		        var transform = 'none';
		        node.style.webkitTransform = transform;
		        node.style.transform = transform;
		      }
		    }, _temp), _possibleConstructorReturn(_this, _ret);
		  }

		  HeaderCell.prototype.render = function render() {
		    var resizeHandle = void 0;
		    if (this.props.column.resizable) {
		      resizeHandle = React.createElement(ResizeHandle, {
		        onDrag: this.onDrag,
		        onDragStart: this.onDragStart,
		        onDragEnd: this.onDragEnd
		      });
		    }
		    var className = joinClasses({
		      'react-grid-HeaderCell': true,
		      'react-grid-HeaderCell--resizing': this.state.resizing,
		      'react-grid-HeaderCell--locked': this.props.column.locked
		    });
		    className = joinClasses(className, this.props.className, this.props.column.cellClass);
		    var cell = this.getCell();
		    return React.createElement(
		      'div',
		      { className: className, style: this.getStyle() },
		      cell,
		      resizeHandle
		    );
		  };

		  return HeaderCell;
		}(React.Component);

		HeaderCell.propTypes = {
		  renderer: _propTypes2['default'].oneOfType([_propTypes2['default'].func, _propTypes2['default'].element]).isRequired,
		  column: _propTypes2['default'].shape(ExcelColumn).isRequired,
		  onResize: _propTypes2['default'].func.isRequired,
		  height: _propTypes2['default'].number.isRequired,
		  onResizeEnd: _propTypes2['default'].func.isRequired,
		  className: _propTypes2['default'].string
		};
		HeaderCell.defaultProps = {
		  renderer: simpleCellRenderer
		};


		module.exports = HeaderCell;

	/***/ }),
	/* 63 */
	/***/ (function(module, exports) {

		'use strict';

		var KeyboardHandlerMixin = {
		  onKeyDown: function onKeyDown(e) {
		    if (this.isCtrlKeyHeldDown(e)) {
		      this.checkAndCall('onPressKeyWithCtrl', e);
		    } else if (this.isKeyExplicitlyHandled(e.key)) {
		      // break up individual keyPress events to have their own specific callbacks
		      // this allows multiple mixins to listen to onKeyDown events and somewhat reduces methodName clashing
		      var callBack = 'onPress' + e.key;
		      this.checkAndCall(callBack, e);
		    } else if (this.isKeyPrintable(e.keyCode)) {
		      this.checkAndCall('onPressChar', e);
		    }

		    // Track which keys are currently down for shift clicking etc
		    this._keysDown = this._keysDown || {};
		    this._keysDown[e.keyCode] = true;
		    if (this.props.onGridKeyDown && typeof this.props.onGridKeyDown === 'function') {
		      this.props.onGridKeyDown(e);
		    }
		  },
		  onKeyUp: function onKeyUp(e) {
		    // Track which keys are currently down for shift clicking etc
		    this._keysDown = this._keysDown || {};
		    delete this._keysDown[e.keyCode];

		    if (this.props.onGridKeyUp && typeof this.props.onGridKeyUp === 'function') {
		      this.props.onGridKeyUp(e);
		    }
		  },
		  isKeyDown: function isKeyDown(keyCode) {
		    if (!this._keysDown) return false;
		    return keyCode in this._keysDown;
		  },
		  isSingleKeyDown: function isSingleKeyDown(keyCode) {
		    if (!this._keysDown) return false;
		    return keyCode in this._keysDown && Object.keys(this._keysDown).length === 1;
		  },


		  // taken from http://stackoverflow.com/questions/12467240/determine-if-javascript-e-keycode-is-a-printable-non-control-character
		  isKeyPrintable: function isKeyPrintable(keycode) {
		    var valid = keycode > 47 && keycode < 58 || // number keys
		    keycode === 32 || keycode === 13 || // spacebar & return key(s) (if you want to allow carriage returns)
		    keycode > 64 && keycode < 91 || // letter keys
		    keycode > 95 && keycode < 112 || // numpad keys
		    keycode > 185 && keycode < 193 || // ;=,-./` (in order)
		    keycode > 218 && keycode < 223; // [\]' (in order)

		    return valid;
		  },
		  isKeyExplicitlyHandled: function isKeyExplicitlyHandled(key) {
		    return typeof this['onPress' + key] === 'function';
		  },
		  isCtrlKeyHeldDown: function isCtrlKeyHeldDown(e) {
		    return (e.ctrlKey === true || e.metaKey === true) && e.key !== 'Control';
		  },
		  checkAndCall: function checkAndCall(methodName, args) {
		    if (typeof this[methodName] === 'function') {
		      this[methodName](args);
		    }
		  }
		};

		module.exports = KeyboardHandlerMixin;

	/***/ }),
	/* 64 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		exports.__esModule = true;
		exports.shouldRowUpdate = undefined;

		var _ColumnMetrics = __webpack_require__(35);

		var _ColumnMetrics2 = _interopRequireDefault(_ColumnMetrics);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		function doesRowContainSelectedCell(props) {
		  var selected = props.cellMetaData.selected;
		  if (selected && selected.rowIdx === props.idx) {
		    return true;
		  }
		  return false;
		}

		function willRowBeDraggedOver(props) {
		  var dragged = props.cellMetaData.dragged;
		  return dragged != null && (dragged.rowIdx >= 0 || dragged.complete === true);
		}

		function hasRowBeenCopied(props) {
		  var copied = props.cellMetaData.copied;
		  return copied != null && copied.rowIdx === props.idx;
		}

		var shouldRowUpdate = exports.shouldRowUpdate = function shouldRowUpdate(nextProps, currentProps) {
		  return !_ColumnMetrics2['default'].sameColumns(currentProps.columns, nextProps.columns, _ColumnMetrics2['default'].sameColumn) || doesRowContainSelectedCell(currentProps) || doesRowContainSelectedCell(nextProps) || willRowBeDraggedOver(nextProps) || nextProps.row !== currentProps.row || currentProps.colDisplayStart !== nextProps.colDisplayStart || currentProps.colDisplayEnd !== nextProps.colDisplayEnd || currentProps.colVisibleStart !== nextProps.colVisibleStart || currentProps.colVisibleEnd !== nextProps.colVisibleEnd || hasRowBeenCopied(currentProps) || currentProps.isSelected !== nextProps.isSelected || nextProps.height !== currentProps.height || currentProps.isOver !== nextProps.isOver || currentProps.expandedRows !== nextProps.expandedRows || currentProps.canDrop !== nextProps.canDrop || currentProps.forceUpdate === true || currentProps.extraClasses !== nextProps.extraClasses;
		};

		exports['default'] = shouldRowUpdate;

	/***/ }),
	/* 65 */
	/***/ (function(module, exports) {

		'use strict';

		var RowUtils = {
		  get: function get(row, property) {
		    if (typeof row.get === 'function') {
		      return row.get(property);
		    }

		    return row[property];
		  },
		  isRowSelected: function isRowSelected(keys, indexes, isSelectedKey, rowData, rowIdx) {
		    if (indexes && Object.prototype.toString.call(indexes) === '[object Array]') {
		      return indexes.indexOf(rowIdx) > -1;
		    } else if (keys && keys.rowKey && keys.values && Object.prototype.toString.call(keys.values) === '[object Array]') {
		      return keys.values.indexOf(rowData[keys.rowKey]) > -1;
		    } else if (isSelectedKey && rowData && typeof isSelectedKey === 'string') {
		      return rowData[isSelectedKey];
		    }
		    return false;
		  }
		};

		module.exports = RowUtils;

	/***/ }),
	/* 66 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		exports.__esModule = true;
		exports.SimpleRowsContainer = undefined;

		var _react = __webpack_require__(2);

		var _react2 = _interopRequireDefault(_react);

		var _propTypes = __webpack_require__(3);

		var _propTypes2 = _interopRequireDefault(_propTypes);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

		var SimpleRowsContainer = function SimpleRowsContainer(props) {
		  return _react2['default'].createElement(
		    'div',
		    { key: 'rows-container' },
		    props.rows
		  );
		};

		SimpleRowsContainer.propTypes = {
		  width: _propTypes2['default'].number,
		  rows: _propTypes2['default'].array
		};

		var RowsContainer = function (_React$Component) {
		  _inherits(RowsContainer, _React$Component);

		  function RowsContainer(props) {
		    _classCallCheck(this, RowsContainer);

		    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

		    _this.plugins = props.window ? props.window.ReactDataGridPlugins : window.ReactDataGridPlugins;
		    _this.hasContextMenu = _this.hasContextMenu.bind(_this);
		    _this.renderRowsWithContextMenu = _this.renderRowsWithContextMenu.bind(_this);
		    _this.getContextMenuContainer = _this.getContextMenuContainer.bind(_this);
		    _this.state = { ContextMenuContainer: _this.getContextMenuContainer(props) };
		    return _this;
		  }

		  RowsContainer.prototype.getContextMenuContainer = function getContextMenuContainer() {
		    if (this.hasContextMenu()) {
		      if (!this.plugins) {
		        throw new Error('You need to include ReactDataGrid UiPlugins in order to initialise context menu');
		      }
		      return this.plugins.Menu.ContextMenuLayer('reactDataGridContextMenu')(SimpleRowsContainer);
		    }
		  };

		  RowsContainer.prototype.hasContextMenu = function hasContextMenu() {
		    return this.props.contextMenu && _react2['default'].isValidElement(this.props.contextMenu);
		  };

		  RowsContainer.prototype.renderRowsWithContextMenu = function renderRowsWithContextMenu() {
		    var ContextMenuRowsContainer = this.state.ContextMenuContainer;
		    var newProps = { rowIdx: this.props.rowIdx, idx: this.props.idx };
		    var contextMenu = _react2['default'].cloneElement(this.props.contextMenu, newProps);
		    // Initialise the context menu if it is available
		    return _react2['default'].createElement(
		      'div',
		      null,
		      _react2['default'].createElement(ContextMenuRowsContainer, this.props),
		      contextMenu
		    );
		  };

		  RowsContainer.prototype.render = function render() {
		    return this.hasContextMenu() ? this.renderRowsWithContextMenu() : _react2['default'].createElement(SimpleRowsContainer, this.props);
		  };

		  return RowsContainer;
		}(_react2['default'].Component);

		RowsContainer.propTypes = {
		  contextMenu: _propTypes2['default'].element,
		  rowIdx: _propTypes2['default'].number,
		  idx: _propTypes2['default'].number,
		  window: _propTypes2['default'].object
		};

		exports['default'] = RowsContainer;
		exports.SimpleRowsContainer = SimpleRowsContainer;

	/***/ }),
	/* 67 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		var _propTypes = __webpack_require__(3);

		var _propTypes2 = _interopRequireDefault(_propTypes);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

		var React = __webpack_require__(2);

		__webpack_require__(73);

		var CheckboxEditor = function (_React$Component) {
		  _inherits(CheckboxEditor, _React$Component);

		  function CheckboxEditor() {
		    var _temp, _this, _ret;

		    _classCallCheck(this, CheckboxEditor);

		    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
		      args[_key] = arguments[_key];
		    }

		    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.handleChange = function (e) {
		      _this.props.column.onCellChange(_this.props.rowIdx, _this.props.column.key, _this.props.dependentValues, e);
		    }, _temp), _possibleConstructorReturn(_this, _ret);
		  }

		  CheckboxEditor.prototype.render = function render() {
		    var checked = this.props.value != null ? this.props.value : false;
		    var checkboxName = 'checkbox' + this.props.rowIdx;
		    return React.createElement(
		      'div',
		      { className: 'react-grid-checkbox-container checkbox-align', onClick: this.handleChange },
		      React.createElement('input', { className: 'react-grid-checkbox', type: 'checkbox', name: checkboxName, checked: checked }),
		      React.createElement('label', { htmlFor: checkboxName, className: 'react-grid-checkbox-label' })
		    );
		  };

		  return CheckboxEditor;
		}(React.Component);

		CheckboxEditor.propTypes = {
		  value: _propTypes2['default'].bool,
		  rowIdx: _propTypes2['default'].number,
		  column: _propTypes2['default'].shape({
		    key: _propTypes2['default'].string,
		    onCellChange: _propTypes2['default'].func
		  }),
		  dependentValues: _propTypes2['default'].object
		};


		module.exports = CheckboxEditor;

	/***/ }),
	/* 68 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		var _propTypes = __webpack_require__(3);

		var _propTypes2 = _interopRequireDefault(_propTypes);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

		var React = __webpack_require__(2);
		var ReactDOM = __webpack_require__(5);
		var ExcelColumn = __webpack_require__(12);

		var EditorBase = function (_React$Component) {
		  _inherits(EditorBase, _React$Component);

		  function EditorBase() {
		    _classCallCheck(this, EditorBase);

		    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
		  }

		  EditorBase.prototype.getStyle = function getStyle() {
		    return {
		      width: '100%'
		    };
		  };

		  EditorBase.prototype.getValue = function getValue() {
		    var updated = {};
		    updated[this.props.column.key] = this.getInputNode().value;
		    return updated;
		  };

		  EditorBase.prototype.getInputNode = function getInputNode() {
		    var domNode = ReactDOM.findDOMNode(this);
		    if (domNode.tagName === 'INPUT') {
		      return domNode;
		    }

		    return domNode.querySelector('input:not([type=hidden])');
		  };

		  EditorBase.prototype.inheritContainerStyles = function inheritContainerStyles() {
		    return true;
		  };

		  return EditorBase;
		}(React.Component);

		EditorBase.propTypes = {
		  onKeyDown: _propTypes2['default'].func.isRequired,
		  value: _propTypes2['default'].any.isRequired,
		  onBlur: _propTypes2['default'].func.isRequired,
		  column: _propTypes2['default'].shape(ExcelColumn).isRequired,
		  commit: _propTypes2['default'].func.isRequired
		};

		module.exports = EditorBase;

	/***/ }),
	/* 69 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

		var React = __webpack_require__(2);
		var EditorBase = __webpack_require__(68);

		var SimpleTextEditor = function (_EditorBase) {
		  _inherits(SimpleTextEditor, _EditorBase);

		  function SimpleTextEditor() {
		    _classCallCheck(this, SimpleTextEditor);

		    return _possibleConstructorReturn(this, _EditorBase.apply(this, arguments));
		  }

		  SimpleTextEditor.prototype.render = function render() {
		    var _this2 = this;

		    return React.createElement('input', { ref: function ref(node) {
		        return _this2.input = node;
		      }, type: 'text', onBlur: this.props.onBlur, className: 'form-control', defaultValue: this.props.value });
		  };

		  return SimpleTextEditor;
		}(EditorBase);

		module.exports = SimpleTextEditor;

	/***/ }),
	/* 70 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		var _propTypes = __webpack_require__(3);

		var _propTypes2 = _interopRequireDefault(_propTypes);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

		var React = __webpack_require__(2);

		var SimpleCellFormatter = function (_React$Component) {
		  _inherits(SimpleCellFormatter, _React$Component);

		  function SimpleCellFormatter() {
		    _classCallCheck(this, SimpleCellFormatter);

		    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
		  }

		  SimpleCellFormatter.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
		    return nextProps.value !== this.props.value;
		  };

		  SimpleCellFormatter.prototype.render = function render() {
		    return React.createElement(
		      'div',
		      { title: this.props.value },
		      this.props.value
		    );
		  };

		  return SimpleCellFormatter;
		}(React.Component);

		SimpleCellFormatter.propTypes = {
		  value: _propTypes2['default'].oneOfType([_propTypes2['default'].string, _propTypes2['default'].number, _propTypes2['default'].object, _propTypes2['default'].bool]).isRequired
		};


		module.exports = SimpleCellFormatter;

	/***/ }),
	/* 71 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

		var _immutable = __webpack_require__(20);

		module.exports = {
		  isEmptyArray: __webpack_require__(210),
		  isEmptyObject: __webpack_require__(211),
		  isFunction: __webpack_require__(24),
		  isImmutableCollection: __webpack_require__(212),
		  getMixedTypeValueRetriever: __webpack_require__(214),
		  isColumnsImmutable: __webpack_require__(72),
		  isImmutableMap: __webpack_require__(213),
		  last: function last(arrayOrList) {
		    if (arrayOrList == null) {
		      throw new Error('arrayOrCollection is null');
		    }

		    if (_immutable.List.isList(arrayOrList)) {
		      return arrayOrList.last();
		    }

		    if (Array.isArray(arrayOrList)) {
		      return arrayOrList[arrayOrList.length - 1];
		    }

		    throw new Error('Cant get last of: ' + (typeof arrayOrList === 'undefined' ? 'undefined' : _typeof(arrayOrList)));
		  }
		};

	/***/ }),
	/* 72 */
	/***/ (function(module, exports) {

		'use strict';

		module.exports = function isColumnsImmutable(columns) {
		  return typeof Immutable !== 'undefined' && columns instanceof Immutable.List;
		};

	/***/ }),
	/* 73 */
	19,
	/* 74 */,
	/* 75 */
	/***/ (function(module, exports) {

		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule shallowEqual
		 * @typechecks
		 * 
		 */

		'use strict';

		var hasOwnProperty = Object.prototype.hasOwnProperty;

		/**
		 * Performs equality by iterating through keys on an object and returning false
		 * when any key has values which are not strictly equal between the arguments.
		 * Returns true when the values of all keys are strictly equal.
		 */
		function shallowEqual(objA, objB) {
		  if (objA === objB) {
		    return true;
		  }

		  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
		    return false;
		  }

		  var keysA = Object.keys(objA);
		  var keysB = Object.keys(objB);

		  if (keysA.length !== keysB.length) {
		    return false;
		  }

		  // Test for A's keys different from B.
		  var bHasOwnProperty = hasOwnProperty.bind(objB);
		  for (var i = 0; i < keysA.length; i++) {
		    if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
		      return false;
		    }
		  }

		  return true;
		}

		module.exports = shallowEqual;

	/***/ }),
	/* 76 */,
	/* 77 */,
	/* 78 */,
	/* 79 */,
	/* 80 */,
	/* 81 */,
	/* 82 */,
	/* 83 */,
	/* 84 */,
	/* 85 */,
	/* 86 */,
	/* 87 */,
	/* 88 */,
	/* 89 */,
	/* 90 */,
	/* 91 */,
	/* 92 */,
	/* 93 */,
	/* 94 */,
	/* 95 */,
	/* 96 */,
	/* 97 */,
	/* 98 */,
	/* 99 */,
	/* 100 */,
	/* 101 */,
	/* 102 */
	/***/ (function(module, exports, __webpack_require__) {

		var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.8.3
		//     http://underscorejs.org
		//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
		//     Underscore may be freely distributed under the MIT license.

		(function() {

		  // Baseline setup
		  // --------------

		  // Establish the root object, `window` in the browser, or `exports` on the server.
		  var root = this;

		  // Save the previous value of the `_` variable.
		  var previousUnderscore = root._;

		  // Save bytes in the minified (but not gzipped) version:
		  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

		  // Create quick reference variables for speed access to core prototypes.
		  var
		    push             = ArrayProto.push,
		    slice            = ArrayProto.slice,
		    toString         = ObjProto.toString,
		    hasOwnProperty   = ObjProto.hasOwnProperty;

		  // All **ECMAScript 5** native function implementations that we hope to use
		  // are declared here.
		  var
		    nativeIsArray      = Array.isArray,
		    nativeKeys         = Object.keys,
		    nativeBind         = FuncProto.bind,
		    nativeCreate       = Object.create;

		  // Naked function reference for surrogate-prototype-swapping.
		  var Ctor = function(){};

		  // Create a safe reference to the Underscore object for use below.
		  var _ = function(obj) {
		    if (obj instanceof _) return obj;
		    if (!(this instanceof _)) return new _(obj);
		    this._wrapped = obj;
		  };

		  // Export the Underscore object for **Node.js**, with
		  // backwards-compatibility for the old `require()` API. If we're in
		  // the browser, add `_` as a global object.
		  if (true) {
		    if (typeof module !== 'undefined' && module.exports) {
		      exports = module.exports = _;
		    }
		    exports._ = _;
		  } else {
		    root._ = _;
		  }

		  // Current version.
		  _.VERSION = '1.8.3';

		  // Internal function that returns an efficient (for current engines) version
		  // of the passed-in callback, to be repeatedly applied in other Underscore
		  // functions.
		  var optimizeCb = function(func, context, argCount) {
		    if (context === void 0) return func;
		    switch (argCount == null ? 3 : argCount) {
		      case 1: return function(value) {
		        return func.call(context, value);
		      };
		      case 2: return function(value, other) {
		        return func.call(context, value, other);
		      };
		      case 3: return function(value, index, collection) {
		        return func.call(context, value, index, collection);
		      };
		      case 4: return function(accumulator, value, index, collection) {
		        return func.call(context, accumulator, value, index, collection);
		      };
		    }
		    return function() {
		      return func.apply(context, arguments);
		    };
		  };

		  // A mostly-internal function to generate callbacks that can be applied
		  // to each element in a collection, returning the desired result â€” either
		  // identity, an arbitrary callback, a property matcher, or a property accessor.
		  var cb = function(value, context, argCount) {
		    if (value == null) return _.identity;
		    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
		    if (_.isObject(value)) return _.matcher(value);
		    return _.property(value);
		  };
		  _.iteratee = function(value, context) {
		    return cb(value, context, Infinity);
		  };

		  // An internal function for creating assigner functions.
		  var createAssigner = function(keysFunc, undefinedOnly) {
		    return function(obj) {
		      var length = arguments.length;
		      if (length < 2 || obj == null) return obj;
		      for (var index = 1; index < length; index++) {
		        var source = arguments[index],
		            keys = keysFunc(source),
		            l = keys.length;
		        for (var i = 0; i < l; i++) {
		          var key = keys[i];
		          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
		        }
		      }
		      return obj;
		    };
		  };

		  // An internal function for creating a new object that inherits from another.
		  var baseCreate = function(prototype) {
		    if (!_.isObject(prototype)) return {};
		    if (nativeCreate) return nativeCreate(prototype);
		    Ctor.prototype = prototype;
		    var result = new Ctor;
		    Ctor.prototype = null;
		    return result;
		  };

		  var property = function(key) {
		    return function(obj) {
		      return obj == null ? void 0 : obj[key];
		    };
		  };

		  // Helper for collection methods to determine whether a collection
		  // should be iterated as an array or as an object
		  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
		  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
		  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
		  var getLength = property('length');
		  var isArrayLike = function(collection) {
		    var length = getLength(collection);
		    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
		  };

		  // Collection Functions
		  // --------------------

		  // The cornerstone, an `each` implementation, aka `forEach`.
		  // Handles raw objects in addition to array-likes. Treats all
		  // sparse array-likes as if they were dense.
		  _.each = _.forEach = function(obj, iteratee, context) {
		    iteratee = optimizeCb(iteratee, context);
		    var i, length;
		    if (isArrayLike(obj)) {
		      for (i = 0, length = obj.length; i < length; i++) {
		        iteratee(obj[i], i, obj);
		      }
		    } else {
		      var keys = _.keys(obj);
		      for (i = 0, length = keys.length; i < length; i++) {
		        iteratee(obj[keys[i]], keys[i], obj);
		      }
		    }
		    return obj;
		  };

		  // Return the results of applying the iteratee to each element.
		  _.map = _.collect = function(obj, iteratee, context) {
		    iteratee = cb(iteratee, context);
		    var keys = !isArrayLike(obj) && _.keys(obj),
		        length = (keys || obj).length,
		        results = Array(length);
		    for (var index = 0; index < length; index++) {
		      var currentKey = keys ? keys[index] : index;
		      results[index] = iteratee(obj[currentKey], currentKey, obj);
		    }
		    return results;
		  };

		  // Create a reducing function iterating left or right.
		  function createReduce(dir) {
		    // Optimized iterator function as using arguments.length
		    // in the main function will deoptimize the, see #1991.
		    function iterator(obj, iteratee, memo, keys, index, length) {
		      for (; index >= 0 && index < length; index += dir) {
		        var currentKey = keys ? keys[index] : index;
		        memo = iteratee(memo, obj[currentKey], currentKey, obj);
		      }
		      return memo;
		    }

		    return function(obj, iteratee, memo, context) {
		      iteratee = optimizeCb(iteratee, context, 4);
		      var keys = !isArrayLike(obj) && _.keys(obj),
		          length = (keys || obj).length,
		          index = dir > 0 ? 0 : length - 1;
		      // Determine the initial value if none is provided.
		      if (arguments.length < 3) {
		        memo = obj[keys ? keys[index] : index];
		        index += dir;
		      }
		      return iterator(obj, iteratee, memo, keys, index, length);
		    };
		  }

		  // **Reduce** builds up a single result from a list of values, aka `inject`,
		  // or `foldl`.
		  _.reduce = _.foldl = _.inject = createReduce(1);

		  // The right-associative version of reduce, also known as `foldr`.
		  _.reduceRight = _.foldr = createReduce(-1);

		  // Return the first value which passes a truth test. Aliased as `detect`.
		  _.find = _.detect = function(obj, predicate, context) {
		    var key;
		    if (isArrayLike(obj)) {
		      key = _.findIndex(obj, predicate, context);
		    } else {
		      key = _.findKey(obj, predicate, context);
		    }
		    if (key !== void 0 && key !== -1) return obj[key];
		  };

		  // Return all the elements that pass a truth test.
		  // Aliased as `select`.
		  _.filter = _.select = function(obj, predicate, context) {
		    var results = [];
		    predicate = cb(predicate, context);
		    _.each(obj, function(value, index, list) {
		      if (predicate(value, index, list)) results.push(value);
		    });
		    return results;
		  };

		  // Return all the elements for which a truth test fails.
		  _.reject = function(obj, predicate, context) {
		    return _.filter(obj, _.negate(cb(predicate)), context);
		  };

		  // Determine whether all of the elements match a truth test.
		  // Aliased as `all`.
		  _.every = _.all = function(obj, predicate, context) {
		    predicate = cb(predicate, context);
		    var keys = !isArrayLike(obj) && _.keys(obj),
		        length = (keys || obj).length;
		    for (var index = 0; index < length; index++) {
		      var currentKey = keys ? keys[index] : index;
		      if (!predicate(obj[currentKey], currentKey, obj)) return false;
		    }
		    return true;
		  };

		  // Determine if at least one element in the object matches a truth test.
		  // Aliased as `any`.
		  _.some = _.any = function(obj, predicate, context) {
		    predicate = cb(predicate, context);
		    var keys = !isArrayLike(obj) && _.keys(obj),
		        length = (keys || obj).length;
		    for (var index = 0; index < length; index++) {
		      var currentKey = keys ? keys[index] : index;
		      if (predicate(obj[currentKey], currentKey, obj)) return true;
		    }
		    return false;
		  };

		  // Determine if the array or object contains a given item (using `===`).
		  // Aliased as `includes` and `include`.
		  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
		    if (!isArrayLike(obj)) obj = _.values(obj);
		    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
		    return _.indexOf(obj, item, fromIndex) >= 0;
		  };

		  // Invoke a method (with arguments) on every item in a collection.
		  _.invoke = function(obj, method) {
		    var args = slice.call(arguments, 2);
		    var isFunc = _.isFunction(method);
		    return _.map(obj, function(value) {
		      var func = isFunc ? method : value[method];
		      return func == null ? func : func.apply(value, args);
		    });
		  };

		  // Convenience version of a common use case of `map`: fetching a property.
		  _.pluck = function(obj, key) {
		    return _.map(obj, _.property(key));
		  };

		  // Convenience version of a common use case of `filter`: selecting only objects
		  // containing specific `key:value` pairs.
		  _.where = function(obj, attrs) {
		    return _.filter(obj, _.matcher(attrs));
		  };

		  // Convenience version of a common use case of `find`: getting the first object
		  // containing specific `key:value` pairs.
		  _.findWhere = function(obj, attrs) {
		    return _.find(obj, _.matcher(attrs));
		  };

		  // Return the maximum element (or element-based computation).
		  _.max = function(obj, iteratee, context) {
		    var result = -Infinity, lastComputed = -Infinity,
		        value, computed;
		    if (iteratee == null && obj != null) {
		      obj = isArrayLike(obj) ? obj : _.values(obj);
		      for (var i = 0, length = obj.length; i < length; i++) {
		        value = obj[i];
		        if (value > result) {
		          result = value;
		        }
		      }
		    } else {
		      iteratee = cb(iteratee, context);
		      _.each(obj, function(value, index, list) {
		        computed = iteratee(value, index, list);
		        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
		          result = value;
		          lastComputed = computed;
		        }
		      });
		    }
		    return result;
		  };

		  // Return the minimum element (or element-based computation).
		  _.min = function(obj, iteratee, context) {
		    var result = Infinity, lastComputed = Infinity,
		        value, computed;
		    if (iteratee == null && obj != null) {
		      obj = isArrayLike(obj) ? obj : _.values(obj);
		      for (var i = 0, length = obj.length; i < length; i++) {
		        value = obj[i];
		        if (value < result) {
		          result = value;
		        }
		      }
		    } else {
		      iteratee = cb(iteratee, context);
		      _.each(obj, function(value, index, list) {
		        computed = iteratee(value, index, list);
		        if (computed < lastComputed || computed === Infinity && result === Infinity) {
		          result = value;
		          lastComputed = computed;
		        }
		      });
		    }
		    return result;
		  };

		  // Shuffle a collection, using the modern version of the
		  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisherâ€“Yates_shuffle).
		  _.shuffle = function(obj) {
		    var set = isArrayLike(obj) ? obj : _.values(obj);
		    var length = set.length;
		    var shuffled = Array(length);
		    for (var index = 0, rand; index < length; index++) {
		      rand = _.random(0, index);
		      if (rand !== index) shuffled[index] = shuffled[rand];
		      shuffled[rand] = set[index];
		    }
		    return shuffled;
		  };

		  // Sample **n** random values from a collection.
		  // If **n** is not specified, returns a single random element.
		  // The internal `guard` argument allows it to work with `map`.
		  _.sample = function(obj, n, guard) {
		    if (n == null || guard) {
		      if (!isArrayLike(obj)) obj = _.values(obj);
		      return obj[_.random(obj.length - 1)];
		    }
		    return _.shuffle(obj).slice(0, Math.max(0, n));
		  };

		  // Sort the object's values by a criterion produced by an iteratee.
		  _.sortBy = function(obj, iteratee, context) {
		    iteratee = cb(iteratee, context);
		    return _.pluck(_.map(obj, function(value, index, list) {
		      return {
		        value: value,
		        index: index,
		        criteria: iteratee(value, index, list)
		      };
		    }).sort(function(left, right) {
		      var a = left.criteria;
		      var b = right.criteria;
		      if (a !== b) {
		        if (a > b || a === void 0) return 1;
		        if (a < b || b === void 0) return -1;
		      }
		      return left.index - right.index;
		    }), 'value');
		  };

		  // An internal function used for aggregate "group by" operations.
		  var group = function(behavior) {
		    return function(obj, iteratee, context) {
		      var result = {};
		      iteratee = cb(iteratee, context);
		      _.each(obj, function(value, index) {
		        var key = iteratee(value, index, obj);
		        behavior(result, value, key);
		      });
		      return result;
		    };
		  };

		  // Groups the object's values by a criterion. Pass either a string attribute
		  // to group by, or a function that returns the criterion.
		  _.groupBy = group(function(result, value, key) {
		    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
		  });

		  // Indexes the object's values by a criterion, similar to `groupBy`, but for
		  // when you know that your index values will be unique.
		  _.indexBy = group(function(result, value, key) {
		    result[key] = value;
		  });

		  // Counts instances of an object that group by a certain criterion. Pass
		  // either a string attribute to count by, or a function that returns the
		  // criterion.
		  _.countBy = group(function(result, value, key) {
		    if (_.has(result, key)) result[key]++; else result[key] = 1;
		  });

		  // Safely create a real, live array from anything iterable.
		  _.toArray = function(obj) {
		    if (!obj) return [];
		    if (_.isArray(obj)) return slice.call(obj);
		    if (isArrayLike(obj)) return _.map(obj, _.identity);
		    return _.values(obj);
		  };

		  // Return the number of elements in an object.
		  _.size = function(obj) {
		    if (obj == null) return 0;
		    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
		  };

		  // Split a collection into two arrays: one whose elements all satisfy the given
		  // predicate, and one whose elements all do not satisfy the predicate.
		  _.partition = function(obj, predicate, context) {
		    predicate = cb(predicate, context);
		    var pass = [], fail = [];
		    _.each(obj, function(value, key, obj) {
		      (predicate(value, key, obj) ? pass : fail).push(value);
		    });
		    return [pass, fail];
		  };

		  // Array Functions
		  // ---------------

		  // Get the first element of an array. Passing **n** will return the first N
		  // values in the array. Aliased as `head` and `take`. The **guard** check
		  // allows it to work with `_.map`.
		  _.first = _.head = _.take = function(array, n, guard) {
		    if (array == null) return void 0;
		    if (n == null || guard) return array[0];
		    return _.initial(array, array.length - n);
		  };

		  // Returns everything but the last entry of the array. Especially useful on
		  // the arguments object. Passing **n** will return all the values in
		  // the array, excluding the last N.
		  _.initial = function(array, n, guard) {
		    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
		  };

		  // Get the last element of an array. Passing **n** will return the last N
		  // values in the array.
		  _.last = function(array, n, guard) {
		    if (array == null) return void 0;
		    if (n == null || guard) return array[array.length - 1];
		    return _.rest(array, Math.max(0, array.length - n));
		  };

		  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
		  // Especially useful on the arguments object. Passing an **n** will return
		  // the rest N values in the array.
		  _.rest = _.tail = _.drop = function(array, n, guard) {
		    return slice.call(array, n == null || guard ? 1 : n);
		  };

		  // Trim out all falsy values from an array.
		  _.compact = function(array) {
		    return _.filter(array, _.identity);
		  };

		  // Internal implementation of a recursive `flatten` function.
		  var flatten = function(input, shallow, strict, startIndex) {
		    var output = [], idx = 0;
		    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
		      var value = input[i];
		      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
		        //flatten current level of array or arguments object
		        if (!shallow) value = flatten(value, shallow, strict);
		        var j = 0, len = value.length;
		        output.length += len;
		        while (j < len) {
		          output[idx++] = value[j++];
		        }
		      } else if (!strict) {
		        output[idx++] = value;
		      }
		    }
		    return output;
		  };

		  // Flatten out an array, either recursively (by default), or just one level.
		  _.flatten = function(array, shallow) {
		    return flatten(array, shallow, false);
		  };

		  // Return a version of the array that does not contain the specified value(s).
		  _.without = function(array) {
		    return _.difference(array, slice.call(arguments, 1));
		  };

		  // Produce a duplicate-free version of the array. If the array has already
		  // been sorted, you have the option of using a faster algorithm.
		  // Aliased as `unique`.
		  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
		    if (!_.isBoolean(isSorted)) {
		      context = iteratee;
		      iteratee = isSorted;
		      isSorted = false;
		    }
		    if (iteratee != null) iteratee = cb(iteratee, context);
		    var result = [];
		    var seen = [];
		    for (var i = 0, length = getLength(array); i < length; i++) {
		      var value = array[i],
		          computed = iteratee ? iteratee(value, i, array) : value;
		      if (isSorted) {
		        if (!i || seen !== computed) result.push(value);
		        seen = computed;
		      } else if (iteratee) {
		        if (!_.contains(seen, computed)) {
		          seen.push(computed);
		          result.push(value);
		        }
		      } else if (!_.contains(result, value)) {
		        result.push(value);
		      }
		    }
		    return result;
		  };

		  // Produce an array that contains the union: each distinct element from all of
		  // the passed-in arrays.
		  _.union = function() {
		    return _.uniq(flatten(arguments, true, true));
		  };

		  // Produce an array that contains every item shared between all the
		  // passed-in arrays.
		  _.intersection = function(array) {
		    var result = [];
		    var argsLength = arguments.length;
		    for (var i = 0, length = getLength(array); i < length; i++) {
		      var item = array[i];
		      if (_.contains(result, item)) continue;
		      for (var j = 1; j < argsLength; j++) {
		        if (!_.contains(arguments[j], item)) break;
		      }
		      if (j === argsLength) result.push(item);
		    }
		    return result;
		  };

		  // Take the difference between one array and a number of other arrays.
		  // Only the elements present in just the first array will remain.
		  _.difference = function(array) {
		    var rest = flatten(arguments, true, true, 1);
		    return _.filter(array, function(value){
		      return !_.contains(rest, value);
		    });
		  };

		  // Zip together multiple lists into a single array -- elements that share
		  // an index go together.
		  _.zip = function() {
		    return _.unzip(arguments);
		  };

		  // Complement of _.zip. Unzip accepts an array of arrays and groups
		  // each array's elements on shared indices
		  _.unzip = function(array) {
		    var length = array && _.max(array, getLength).length || 0;
		    var result = Array(length);

		    for (var index = 0; index < length; index++) {
		      result[index] = _.pluck(array, index);
		    }
		    return result;
		  };

		  // Converts lists into objects. Pass either a single array of `[key, value]`
		  // pairs, or two parallel arrays of the same length -- one of keys, and one of
		  // the corresponding values.
		  _.object = function(list, values) {
		    var result = {};
		    for (var i = 0, length = getLength(list); i < length; i++) {
		      if (values) {
		        result[list[i]] = values[i];
		      } else {
		        result[list[i][0]] = list[i][1];
		      }
		    }
		    return result;
		  };

		  // Generator function to create the findIndex and findLastIndex functions
		  function createPredicateIndexFinder(dir) {
		    return function(array, predicate, context) {
		      predicate = cb(predicate, context);
		      var length = getLength(array);
		      var index = dir > 0 ? 0 : length - 1;
		      for (; index >= 0 && index < length; index += dir) {
		        if (predicate(array[index], index, array)) return index;
		      }
		      return -1;
		    };
		  }

		  // Returns the first index on an array-like that passes a predicate test
		  _.findIndex = createPredicateIndexFinder(1);
		  _.findLastIndex = createPredicateIndexFinder(-1);

		  // Use a comparator function to figure out the smallest index at which
		  // an object should be inserted so as to maintain order. Uses binary search.
		  _.sortedIndex = function(array, obj, iteratee, context) {
		    iteratee = cb(iteratee, context, 1);
		    var value = iteratee(obj);
		    var low = 0, high = getLength(array);
		    while (low < high) {
		      var mid = Math.floor((low + high) / 2);
		      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
		    }
		    return low;
		  };

		  // Generator function to create the indexOf and lastIndexOf functions
		  function createIndexFinder(dir, predicateFind, sortedIndex) {
		    return function(array, item, idx) {
		      var i = 0, length = getLength(array);
		      if (typeof idx == 'number') {
		        if (dir > 0) {
		            i = idx >= 0 ? idx : Math.max(idx + length, i);
		        } else {
		            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
		        }
		      } else if (sortedIndex && idx && length) {
		        idx = sortedIndex(array, item);
		        return array[idx] === item ? idx : -1;
		      }
		      if (item !== item) {
		        idx = predicateFind(slice.call(array, i, length), _.isNaN);
		        return idx >= 0 ? idx + i : -1;
		      }
		      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
		        if (array[idx] === item) return idx;
		      }
		      return -1;
		    };
		  }

		  // Return the position of the first occurrence of an item in an array,
		  // or -1 if the item is not included in the array.
		  // If the array is large and already in sort order, pass `true`
		  // for **isSorted** to use binary search.
		  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
		  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

		  // Generate an integer Array containing an arithmetic progression. A port of
		  // the native Python `range()` function. See
		  // [the Python documentation](http://docs.python.org/library/functions.html#range).
		  _.range = function(start, stop, step) {
		    if (stop == null) {
		      stop = start || 0;
		      start = 0;
		    }
		    step = step || 1;

		    var length = Math.max(Math.ceil((stop - start) / step), 0);
		    var range = Array(length);

		    for (var idx = 0; idx < length; idx++, start += step) {
		      range[idx] = start;
		    }

		    return range;
		  };

		  // Function (ahem) Functions
		  // ------------------

		  // Determines whether to execute a function as a constructor
		  // or a normal function with the provided arguments
		  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
		    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
		    var self = baseCreate(sourceFunc.prototype);
		    var result = sourceFunc.apply(self, args);
		    if (_.isObject(result)) return result;
		    return self;
		  };

		  // Create a function bound to a given object (assigning `this`, and arguments,
		  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
		  // available.
		  _.bind = function(func, context) {
		    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
		    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
		    var args = slice.call(arguments, 2);
		    var bound = function() {
		      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
		    };
		    return bound;
		  };

		  // Partially apply a function by creating a version that has had some of its
		  // arguments pre-filled, without changing its dynamic `this` context. _ acts
		  // as a placeholder, allowing any combination of arguments to be pre-filled.
		  _.partial = function(func) {
		    var boundArgs = slice.call(arguments, 1);
		    var bound = function() {
		      var position = 0, length = boundArgs.length;
		      var args = Array(length);
		      for (var i = 0; i < length; i++) {
		        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
		      }
		      while (position < arguments.length) args.push(arguments[position++]);
		      return executeBound(func, bound, this, this, args);
		    };
		    return bound;
		  };

		  // Bind a number of an object's methods to that object. Remaining arguments
		  // are the method names to be bound. Useful for ensuring that all callbacks
		  // defined on an object belong to it.
		  _.bindAll = function(obj) {
		    var i, length = arguments.length, key;
		    if (length <= 1) throw new Error('bindAll must be passed function names');
		    for (i = 1; i < length; i++) {
		      key = arguments[i];
		      obj[key] = _.bind(obj[key], obj);
		    }
		    return obj;
		  };

		  // Memoize an expensive function by storing its results.
		  _.memoize = function(func, hasher) {
		    var memoize = function(key) {
		      var cache = memoize.cache;
		      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
		      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
		      return cache[address];
		    };
		    memoize.cache = {};
		    return memoize;
		  };

		  // Delays a function for the given number of milliseconds, and then calls
		  // it with the arguments supplied.
		  _.delay = function(func, wait) {
		    var args = slice.call(arguments, 2);
		    return setTimeout(function(){
		      return func.apply(null, args);
		    }, wait);
		  };

		  // Defers a function, scheduling it to run after the current call stack has
		  // cleared.
		  _.defer = _.partial(_.delay, _, 1);

		  // Returns a function, that, when invoked, will only be triggered at most once
		  // during a given window of time. Normally, the throttled function will run
		  // as much as it can, without ever going more than once per `wait` duration;
		  // but if you'd like to disable the execution on the leading edge, pass
		  // `{leading: false}`. To disable execution on the trailing edge, ditto.
		  _.throttle = function(func, wait, options) {
		    var context, args, result;
		    var timeout = null;
		    var previous = 0;
		    if (!options) options = {};
		    var later = function() {
		      previous = options.leading === false ? 0 : _.now();
		      timeout = null;
		      result = func.apply(context, args);
		      if (!timeout) context = args = null;
		    };
		    return function() {
		      var now = _.now();
		      if (!previous && options.leading === false) previous = now;
		      var remaining = wait - (now - previous);
		      context = this;
		      args = arguments;
		      if (remaining <= 0 || remaining > wait) {
		        if (timeout) {
		          clearTimeout(timeout);
		          timeout = null;
		        }
		        previous = now;
		        result = func.apply(context, args);
		        if (!timeout) context = args = null;
		      } else if (!timeout && options.trailing !== false) {
		        timeout = setTimeout(later, remaining);
		      }
		      return result;
		    };
		  };

		  // Returns a function, that, as long as it continues to be invoked, will not
		  // be triggered. The function will be called after it stops being called for
		  // N milliseconds. If `immediate` is passed, trigger the function on the
		  // leading edge, instead of the trailing.
		  _.debounce = function(func, wait, immediate) {
		    var timeout, args, context, timestamp, result;

		    var later = function() {
		      var last = _.now() - timestamp;

		      if (last < wait && last >= 0) {
		        timeout = setTimeout(later, wait - last);
		      } else {
		        timeout = null;
		        if (!immediate) {
		          result = func.apply(context, args);
		          if (!timeout) context = args = null;
		        }
		      }
		    };

		    return function() {
		      context = this;
		      args = arguments;
		      timestamp = _.now();
		      var callNow = immediate && !timeout;
		      if (!timeout) timeout = setTimeout(later, wait);
		      if (callNow) {
		        result = func.apply(context, args);
		        context = args = null;
		      }

		      return result;
		    };
		  };

		  // Returns the first function passed as an argument to the second,
		  // allowing you to adjust arguments, run code before and after, and
		  // conditionally execute the original function.
		  _.wrap = function(func, wrapper) {
		    return _.partial(wrapper, func);
		  };

		  // Returns a negated version of the passed-in predicate.
		  _.negate = function(predicate) {
		    return function() {
		      return !predicate.apply(this, arguments);
		    };
		  };

		  // Returns a function that is the composition of a list of functions, each
		  // consuming the return value of the function that follows.
		  _.compose = function() {
		    var args = arguments;
		    var start = args.length - 1;
		    return function() {
		      var i = start;
		      var result = args[start].apply(this, arguments);
		      while (i--) result = args[i].call(this, result);
		      return result;
		    };
		  };

		  // Returns a function that will only be executed on and after the Nth call.
		  _.after = function(times, func) {
		    return function() {
		      if (--times < 1) {
		        return func.apply(this, arguments);
		      }
		    };
		  };

		  // Returns a function that will only be executed up to (but not including) the Nth call.
		  _.before = function(times, func) {
		    var memo;
		    return function() {
		      if (--times > 0) {
		        memo = func.apply(this, arguments);
		      }
		      if (times <= 1) func = null;
		      return memo;
		    };
		  };

		  // Returns a function that will be executed at most one time, no matter how
		  // often you call it. Useful for lazy initialization.
		  _.once = _.partial(_.before, 2);

		  // Object Functions
		  // ----------------

		  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
		  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
		  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
		                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

		  function collectNonEnumProps(obj, keys) {
		    var nonEnumIdx = nonEnumerableProps.length;
		    var constructor = obj.constructor;
		    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

		    // Constructor is a special case.
		    var prop = 'constructor';
		    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

		    while (nonEnumIdx--) {
		      prop = nonEnumerableProps[nonEnumIdx];
		      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
		        keys.push(prop);
		      }
		    }
		  }

		  // Retrieve the names of an object's own properties.
		  // Delegates to **ECMAScript 5**'s native `Object.keys`
		  _.keys = function(obj) {
		    if (!_.isObject(obj)) return [];
		    if (nativeKeys) return nativeKeys(obj);
		    var keys = [];
		    for (var key in obj) if (_.has(obj, key)) keys.push(key);
		    // Ahem, IE < 9.
		    if (hasEnumBug) collectNonEnumProps(obj, keys);
		    return keys;
		  };

		  // Retrieve all the property names of an object.
		  _.allKeys = function(obj) {
		    if (!_.isObject(obj)) return [];
		    var keys = [];
		    for (var key in obj) keys.push(key);
		    // Ahem, IE < 9.
		    if (hasEnumBug) collectNonEnumProps(obj, keys);
		    return keys;
		  };

		  // Retrieve the values of an object's properties.
		  _.values = function(obj) {
		    var keys = _.keys(obj);
		    var length = keys.length;
		    var values = Array(length);
		    for (var i = 0; i < length; i++) {
		      values[i] = obj[keys[i]];
		    }
		    return values;
		  };

		  // Returns the results of applying the iteratee to each element of the object
		  // In contrast to _.map it returns an object
		  _.mapObject = function(obj, iteratee, context) {
		    iteratee = cb(iteratee, context);
		    var keys =  _.keys(obj),
		          length = keys.length,
		          results = {},
		          currentKey;
		      for (var index = 0; index < length; index++) {
		        currentKey = keys[index];
		        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
		      }
		      return results;
		  };

		  // Convert an object into a list of `[key, value]` pairs.
		  _.pairs = function(obj) {
		    var keys = _.keys(obj);
		    var length = keys.length;
		    var pairs = Array(length);
		    for (var i = 0; i < length; i++) {
		      pairs[i] = [keys[i], obj[keys[i]]];
		    }
		    return pairs;
		  };

		  // Invert the keys and values of an object. The values must be serializable.
		  _.invert = function(obj) {
		    var result = {};
		    var keys = _.keys(obj);
		    for (var i = 0, length = keys.length; i < length; i++) {
		      result[obj[keys[i]]] = keys[i];
		    }
		    return result;
		  };

		  // Return a sorted list of the function names available on the object.
		  // Aliased as `methods`
		  _.functions = _.methods = function(obj) {
		    var names = [];
		    for (var key in obj) {
		      if (_.isFunction(obj[key])) names.push(key);
		    }
		    return names.sort();
		  };

		  // Extend a given object with all the properties in passed-in object(s).
		  _.extend = createAssigner(_.allKeys);

		  // Assigns a given object with all the own properties in the passed-in object(s)
		  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
		  _.extendOwn = _.assign = createAssigner(_.keys);

		  // Returns the first key on an object that passes a predicate test
		  _.findKey = function(obj, predicate, context) {
		    predicate = cb(predicate, context);
		    var keys = _.keys(obj), key;
		    for (var i = 0, length = keys.length; i < length; i++) {
		      key = keys[i];
		      if (predicate(obj[key], key, obj)) return key;
		    }
		  };

		  // Return a copy of the object only containing the whitelisted properties.
		  _.pick = function(object, oiteratee, context) {
		    var result = {}, obj = object, iteratee, keys;
		    if (obj == null) return result;
		    if (_.isFunction(oiteratee)) {
		      keys = _.allKeys(obj);
		      iteratee = optimizeCb(oiteratee, context);
		    } else {
		      keys = flatten(arguments, false, false, 1);
		      iteratee = function(value, key, obj) { return key in obj; };
		      obj = Object(obj);
		    }
		    for (var i = 0, length = keys.length; i < length; i++) {
		      var key = keys[i];
		      var value = obj[key];
		      if (iteratee(value, key, obj)) result[key] = value;
		    }
		    return result;
		  };

		   // Return a copy of the object without the blacklisted properties.
		  _.omit = function(obj, iteratee, context) {
		    if (_.isFunction(iteratee)) {
		      iteratee = _.negate(iteratee);
		    } else {
		      var keys = _.map(flatten(arguments, false, false, 1), String);
		      iteratee = function(value, key) {
		        return !_.contains(keys, key);
		      };
		    }
		    return _.pick(obj, iteratee, context);
		  };

		  // Fill in a given object with default properties.
		  _.defaults = createAssigner(_.allKeys, true);

		  // Creates an object that inherits from the given prototype object.
		  // If additional properties are provided then they will be added to the
		  // created object.
		  _.create = function(prototype, props) {
		    var result = baseCreate(prototype);
		    if (props) _.extendOwn(result, props);
		    return result;
		  };

		  // Create a (shallow-cloned) duplicate of an object.
		  _.clone = function(obj) {
		    if (!_.isObject(obj)) return obj;
		    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
		  };

		  // Invokes interceptor with the obj, and then returns obj.
		  // The primary purpose of this method is to "tap into" a method chain, in
		  // order to perform operations on intermediate results within the chain.
		  _.tap = function(obj, interceptor) {
		    interceptor(obj);
		    return obj;
		  };

		  // Returns whether an object has a given set of `key:value` pairs.
		  _.isMatch = function(object, attrs) {
		    var keys = _.keys(attrs), length = keys.length;
		    if (object == null) return !length;
		    var obj = Object(object);
		    for (var i = 0; i < length; i++) {
		      var key = keys[i];
		      if (attrs[key] !== obj[key] || !(key in obj)) return false;
		    }
		    return true;
		  };


		  // Internal recursive comparison function for `isEqual`.
		  var eq = function(a, b, aStack, bStack) {
		    // Identical objects are equal. `0 === -0`, but they aren't identical.
		    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
		    if (a === b) return a !== 0 || 1 / a === 1 / b;
		    // A strict comparison is necessary because `null == undefined`.
		    if (a == null || b == null) return a === b;
		    // Unwrap any wrapped objects.
		    if (a instanceof _) a = a._wrapped;
		    if (b instanceof _) b = b._wrapped;
		    // Compare `[[Class]]` names.
		    var className = toString.call(a);
		    if (className !== toString.call(b)) return false;
		    switch (className) {
		      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
		      case '[object RegExp]':
		      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
		      case '[object String]':
		        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
		        // equivalent to `new String("5")`.
		        return '' + a === '' + b;
		      case '[object Number]':
		        // `NaN`s are equivalent, but non-reflexive.
		        // Object(NaN) is equivalent to NaN
		        if (+a !== +a) return +b !== +b;
		        // An `egal` comparison is performed for other numeric values.
		        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
		      case '[object Date]':
		      case '[object Boolean]':
		        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
		        // millisecond representations. Note that invalid dates with millisecond representations
		        // of `NaN` are not equivalent.
		        return +a === +b;
		    }

		    var areArrays = className === '[object Array]';
		    if (!areArrays) {
		      if (typeof a != 'object' || typeof b != 'object') return false;

		      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
		      // from different frames are.
		      var aCtor = a.constructor, bCtor = b.constructor;
		      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
		                               _.isFunction(bCtor) && bCtor instanceof bCtor)
		                          && ('constructor' in a && 'constructor' in b)) {
		        return false;
		      }
		    }
		    // Assume equality for cyclic structures. The algorithm for detecting cyclic
		    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

		    // Initializing stack of traversed objects.
		    // It's done here since we only need them for objects and arrays comparison.
		    aStack = aStack || [];
		    bStack = bStack || [];
		    var length = aStack.length;
		    while (length--) {
		      // Linear search. Performance is inversely proportional to the number of
		      // unique nested structures.
		      if (aStack[length] === a) return bStack[length] === b;
		    }

		    // Add the first object to the stack of traversed objects.
		    aStack.push(a);
		    bStack.push(b);

		    // Recursively compare objects and arrays.
		    if (areArrays) {
		      // Compare array lengths to determine if a deep comparison is necessary.
		      length = a.length;
		      if (length !== b.length) return false;
		      // Deep compare the contents, ignoring non-numeric properties.
		      while (length--) {
		        if (!eq(a[length], b[length], aStack, bStack)) return false;
		      }
		    } else {
		      // Deep compare objects.
		      var keys = _.keys(a), key;
		      length = keys.length;
		      // Ensure that both objects contain the same number of properties before comparing deep equality.
		      if (_.keys(b).length !== length) return false;
		      while (length--) {
		        // Deep compare each member
		        key = keys[length];
		        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
		      }
		    }
		    // Remove the first object from the stack of traversed objects.
		    aStack.pop();
		    bStack.pop();
		    return true;
		  };

		  // Perform a deep comparison to check if two objects are equal.
		  _.isEqual = function(a, b) {
		    return eq(a, b);
		  };

		  // Is a given array, string, or object empty?
		  // An "empty" object has no enumerable own-properties.
		  _.isEmpty = function(obj) {
		    if (obj == null) return true;
		    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
		    return _.keys(obj).length === 0;
		  };

		  // Is a given value a DOM element?
		  _.isElement = function(obj) {
		    return !!(obj && obj.nodeType === 1);
		  };

		  // Is a given value an array?
		  // Delegates to ECMA5's native Array.isArray
		  _.isArray = nativeIsArray || function(obj) {
		    return toString.call(obj) === '[object Array]';
		  };

		  // Is a given variable an object?
		  _.isObject = function(obj) {
		    var type = typeof obj;
		    return type === 'function' || type === 'object' && !!obj;
		  };

		  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
		  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
		    _['is' + name] = function(obj) {
		      return toString.call(obj) === '[object ' + name + ']';
		    };
		  });

		  // Define a fallback version of the method in browsers (ahem, IE < 9), where
		  // there isn't any inspectable "Arguments" type.
		  if (!_.isArguments(arguments)) {
		    _.isArguments = function(obj) {
		      return _.has(obj, 'callee');
		    };
		  }

		  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
		  // IE 11 (#1621), and in Safari 8 (#1929).
		  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
		    _.isFunction = function(obj) {
		      return typeof obj == 'function' || false;
		    };
		  }

		  // Is a given object a finite number?
		  _.isFinite = function(obj) {
		    return isFinite(obj) && !isNaN(parseFloat(obj));
		  };

		  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
		  _.isNaN = function(obj) {
		    return _.isNumber(obj) && obj !== +obj;
		  };

		  // Is a given value a boolean?
		  _.isBoolean = function(obj) {
		    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
		  };

		  // Is a given value equal to null?
		  _.isNull = function(obj) {
		    return obj === null;
		  };

		  // Is a given variable undefined?
		  _.isUndefined = function(obj) {
		    return obj === void 0;
		  };

		  // Shortcut function for checking if an object has a given property directly
		  // on itself (in other words, not on a prototype).
		  _.has = function(obj, key) {
		    return obj != null && hasOwnProperty.call(obj, key);
		  };

		  // Utility Functions
		  // -----------------

		  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
		  // previous owner. Returns a reference to the Underscore object.
		  _.noConflict = function() {
		    root._ = previousUnderscore;
		    return this;
		  };

		  // Keep the identity function around for default iteratees.
		  _.identity = function(value) {
		    return value;
		  };

		  // Predicate-generating functions. Often useful outside of Underscore.
		  _.constant = function(value) {
		    return function() {
		      return value;
		    };
		  };

		  _.noop = function(){};

		  _.property = property;

		  // Generates a function for a given object that returns a given property.
		  _.propertyOf = function(obj) {
		    return obj == null ? function(){} : function(key) {
		      return obj[key];
		    };
		  };

		  // Returns a predicate for checking whether an object has a given set of
		  // `key:value` pairs.
		  _.matcher = _.matches = function(attrs) {
		    attrs = _.extendOwn({}, attrs);
		    return function(obj) {
		      return _.isMatch(obj, attrs);
		    };
		  };

		  // Run a function **n** times.
		  _.times = function(n, iteratee, context) {
		    var accum = Array(Math.max(0, n));
		    iteratee = optimizeCb(iteratee, context, 1);
		    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
		    return accum;
		  };

		  // Return a random integer between min and max (inclusive).
		  _.random = function(min, max) {
		    if (max == null) {
		      max = min;
		      min = 0;
		    }
		    return min + Math.floor(Math.random() * (max - min + 1));
		  };

		  // A (possibly faster) way to get the current timestamp as an integer.
		  _.now = Date.now || function() {
		    return new Date().getTime();
		  };

		   // List of HTML entities for escaping.
		  var escapeMap = {
		    '&': '&amp;',
		    '<': '&lt;',
		    '>': '&gt;',
		    '"': '&quot;',
		    "'": '&#x27;',
		    '`': '&#x60;'
		  };
		  var unescapeMap = _.invert(escapeMap);

		  // Functions for escaping and unescaping strings to/from HTML interpolation.
		  var createEscaper = function(map) {
		    var escaper = function(match) {
		      return map[match];
		    };
		    // Regexes for identifying a key that needs to be escaped
		    var source = '(?:' + _.keys(map).join('|') + ')';
		    var testRegexp = RegExp(source);
		    var replaceRegexp = RegExp(source, 'g');
		    return function(string) {
		      string = string == null ? '' : '' + string;
		      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
		    };
		  };
		  _.escape = createEscaper(escapeMap);
		  _.unescape = createEscaper(unescapeMap);

		  // If the value of the named `property` is a function then invoke it with the
		  // `object` as context; otherwise, return it.
		  _.result = function(object, property, fallback) {
		    var value = object == null ? void 0 : object[property];
		    if (value === void 0) {
		      value = fallback;
		    }
		    return _.isFunction(value) ? value.call(object) : value;
		  };

		  // Generate a unique integer id (unique within the entire client session).
		  // Useful for temporary DOM ids.
		  var idCounter = 0;
		  _.uniqueId = function(prefix) {
		    var id = ++idCounter + '';
		    return prefix ? prefix + id : id;
		  };

		  // By default, Underscore uses ERB-style template delimiters, change the
		  // following template settings to use alternative delimiters.
		  _.templateSettings = {
		    evaluate    : /<%([\s\S]+?)%>/g,
		    interpolate : /<%=([\s\S]+?)%>/g,
		    escape      : /<%-([\s\S]+?)%>/g
		  };

		  // When customizing `templateSettings`, if you don't want to define an
		  // interpolation, evaluation or escaping regex, we need one that is
		  // guaranteed not to match.
		  var noMatch = /(.)^/;

		  // Certain characters need to be escaped so that they can be put into a
		  // string literal.
		  var escapes = {
		    "'":      "'",
		    '\\':     '\\',
		    '\r':     'r',
		    '\n':     'n',
		    '\u2028': 'u2028',
		    '\u2029': 'u2029'
		  };

		  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

		  var escapeChar = function(match) {
		    return '\\' + escapes[match];
		  };

		  // JavaScript micro-templating, similar to John Resig's implementation.
		  // Underscore templating handles arbitrary delimiters, preserves whitespace,
		  // and correctly escapes quotes within interpolated code.
		  // NB: `oldSettings` only exists for backwards compatibility.
		  _.template = function(text, settings, oldSettings) {
		    if (!settings && oldSettings) settings = oldSettings;
		    settings = _.defaults({}, settings, _.templateSettings);

		    // Combine delimiters into one regular expression via alternation.
		    var matcher = RegExp([
		      (settings.escape || noMatch).source,
		      (settings.interpolate || noMatch).source,
		      (settings.evaluate || noMatch).source
		    ].join('|') + '|$', 'g');

		    // Compile the template source, escaping string literals appropriately.
		    var index = 0;
		    var source = "__p+='";
		    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
		      source += text.slice(index, offset).replace(escaper, escapeChar);
		      index = offset + match.length;

		      if (escape) {
		        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
		      } else if (interpolate) {
		        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
		      } else if (evaluate) {
		        source += "';\n" + evaluate + "\n__p+='";
		      }

		      // Adobe VMs need the match returned to produce the correct offest.
		      return match;
		    });
		    source += "';\n";

		    // If a variable is not specified, place data values in local scope.
		    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

		    source = "var __t,__p='',__j=Array.prototype.join," +
		      "print=function(){__p+=__j.call(arguments,'');};\n" +
		      source + 'return __p;\n';

		    try {
		      var render = new Function(settings.variable || 'obj', '_', source);
		    } catch (e) {
		      e.source = source;
		      throw e;
		    }

		    var template = function(data) {
		      return render.call(this, data, _);
		    };

		    // Provide the compiled source as a convenience for precompilation.
		    var argument = settings.variable || 'obj';
		    template.source = 'function(' + argument + '){\n' + source + '}';

		    return template;
		  };

		  // Add a "chain" function. Start chaining a wrapped Underscore object.
		  _.chain = function(obj) {
		    var instance = _(obj);
		    instance._chain = true;
		    return instance;
		  };

		  // OOP
		  // ---------------
		  // If Underscore is called as a function, it returns a wrapped object that
		  // can be used OO-style. This wrapper holds altered versions of all the
		  // underscore functions. Wrapped objects may be chained.

		  // Helper function to continue chaining intermediate results.
		  var result = function(instance, obj) {
		    return instance._chain ? _(obj).chain() : obj;
		  };

		  // Add your own custom functions to the Underscore object.
		  _.mixin = function(obj) {
		    _.each(_.functions(obj), function(name) {
		      var func = _[name] = obj[name];
		      _.prototype[name] = function() {
		        var args = [this._wrapped];
		        push.apply(args, arguments);
		        return result(this, func.apply(_, args));
		      };
		    });
		  };

		  // Add all of the Underscore functions to the wrapper object.
		  _.mixin(_);

		  // Add all mutator Array functions to the wrapper.
		  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
		    var method = ArrayProto[name];
		    _.prototype[name] = function() {
		      var obj = this._wrapped;
		      method.apply(obj, arguments);
		      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
		      return result(this, obj);
		    };
		  });

		  // Add all accessor Array functions to the wrapper.
		  _.each(['concat', 'join', 'slice'], function(name) {
		    var method = ArrayProto[name];
		    _.prototype[name] = function() {
		      return result(this, method.apply(this._wrapped, arguments));
		    };
		  });

		  // Extracts the result from a wrapped and chained object.
		  _.prototype.value = function() {
		    return this._wrapped;
		  };

		  // Provide unwrapping proxy for some methods used in engine operations
		  // such as arithmetic and JSON stringification.
		  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

		  _.prototype.toString = function() {
		    return '' + this._wrapped;
		  };

		  // AMD registration happens at the end for compatibility with AMD loaders
		  // that may not enforce next-turn semantics on modules. Even though general
		  // practice for AMD registration is to be anonymous, underscore registers
		  // as a named module because, like jQuery, it is a base library that is
		  // popular enough to be bundled in a third party lib, but not be part of
		  // an AMD load request. Those cases could generate an error when an
		  // anonymous define() is called outside of a loader request.
		  if (true) {
		    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
		      return _;
		    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		  }
		}.call(this));


	/***/ }),
	/* 103 */,
	/* 104 */
	/***/ (function(module, exports, __webpack_require__) {

		/**
		 * Copyright (c) 2013-present, Facebook, Inc.
		 *
		 * This source code is licensed under the MIT license found in the
		 * LICENSE file in the root directory of this source tree.
		 *
		 */

		'use strict';

		var _assign = __webpack_require__(107);

		var emptyObject = __webpack_require__(105);
		var _invariant = __webpack_require__(106);

		if (false) {
		  var warning = require('fbjs/lib/warning');
		}

		var MIXINS_KEY = 'mixins';

		// Helper function to allow the creation of anonymous functions which do not
		// have .name set to the name of the variable being assigned to.
		function identity(fn) {
		  return fn;
		}

		var ReactPropTypeLocationNames;
		if (false) {
		  ReactPropTypeLocationNames = {
		    prop: 'prop',
		    context: 'context',
		    childContext: 'child context'
		  };
		} else {
		  ReactPropTypeLocationNames = {};
		}

		function factory(ReactComponent, isValidElement, ReactNoopUpdateQueue) {
		  /**
		   * Policies that describe methods in `ReactClassInterface`.
		   */

		  var injectedMixins = [];

		  /**
		   * Composite components are higher-level components that compose other composite
		   * or host components.
		   *
		   * To create a new type of `ReactClass`, pass a specification of
		   * your new class to `React.createClass`. The only requirement of your class
		   * specification is that you implement a `render` method.
		   *
		   *   var MyComponent = React.createClass({
		   *     render: function() {
		   *       return <div>Hello World</div>;
		   *     }
		   *   });
		   *
		   * The class specification supports a specific protocol of methods that have
		   * special meaning (e.g. `render`). See `ReactClassInterface` for
		   * more the comprehensive protocol. Any other properties and methods in the
		   * class specification will be available on the prototype.
		   *
		   * @interface ReactClassInterface
		   * @internal
		   */
		  var ReactClassInterface = {
		    /**
		     * An array of Mixin objects to include when defining your component.
		     *
		     * @type {array}
		     * @optional
		     */
		    mixins: 'DEFINE_MANY',

		    /**
		     * An object containing properties and methods that should be defined on
		     * the component's constructor instead of its prototype (static methods).
		     *
		     * @type {object}
		     * @optional
		     */
		    statics: 'DEFINE_MANY',

		    /**
		     * Definition of prop types for this component.
		     *
		     * @type {object}
		     * @optional
		     */
		    propTypes: 'DEFINE_MANY',

		    /**
		     * Definition of context types for this component.
		     *
		     * @type {object}
		     * @optional
		     */
		    contextTypes: 'DEFINE_MANY',

		    /**
		     * Definition of context types this component sets for its children.
		     *
		     * @type {object}
		     * @optional
		     */
		    childContextTypes: 'DEFINE_MANY',

		    // ==== Definition methods ====

		    /**
		     * Invoked when the component is mounted. Values in the mapping will be set on
		     * `this.props` if that prop is not specified (i.e. using an `in` check).
		     *
		     * This method is invoked before `getInitialState` and therefore cannot rely
		     * on `this.state` or use `this.setState`.
		     *
		     * @return {object}
		     * @optional
		     */
		    getDefaultProps: 'DEFINE_MANY_MERGED',

		    /**
		     * Invoked once before the component is mounted. The return value will be used
		     * as the initial value of `this.state`.
		     *
		     *   getInitialState: function() {
		     *     return {
		     *       isOn: false,
		     *       fooBaz: new BazFoo()
		     *     }
		     *   }
		     *
		     * @return {object}
		     * @optional
		     */
		    getInitialState: 'DEFINE_MANY_MERGED',

		    /**
		     * @return {object}
		     * @optional
		     */
		    getChildContext: 'DEFINE_MANY_MERGED',

		    /**
		     * Uses props from `this.props` and state from `this.state` to render the
		     * structure of the component.
		     *
		     * No guarantees are made about when or how often this method is invoked, so
		     * it must not have side effects.
		     *
		     *   render: function() {
		     *     var name = this.props.name;
		     *     return <div>Hello, {name}!</div>;
		     *   }
		     *
		     * @return {ReactComponent}
		     * @required
		     */
		    render: 'DEFINE_ONCE',

		    // ==== Delegate methods ====

		    /**
		     * Invoked when the component is initially created and about to be mounted.
		     * This may have side effects, but any external subscriptions or data created
		     * by this method must be cleaned up in `componentWillUnmount`.
		     *
		     * @optional
		     */
		    componentWillMount: 'DEFINE_MANY',

		    /**
		     * Invoked when the component has been mounted and has a DOM representation.
		     * However, there is no guarantee that the DOM node is in the document.
		     *
		     * Use this as an opportunity to operate on the DOM when the component has
		     * been mounted (initialized and rendered) for the first time.
		     *
		     * @param {DOMElement} rootNode DOM element representing the component.
		     * @optional
		     */
		    componentDidMount: 'DEFINE_MANY',

		    /**
		     * Invoked before the component receives new props.
		     *
		     * Use this as an opportunity to react to a prop transition by updating the
		     * state using `this.setState`. Current props are accessed via `this.props`.
		     *
		     *   componentWillReceiveProps: function(nextProps, nextContext) {
		     *     this.setState({
		     *       likesIncreasing: nextProps.likeCount > this.props.likeCount
		     *     });
		     *   }
		     *
		     * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
		     * transition may cause a state change, but the opposite is not true. If you
		     * need it, you are probably looking for `componentWillUpdate`.
		     *
		     * @param {object} nextProps
		     * @optional
		     */
		    componentWillReceiveProps: 'DEFINE_MANY',

		    /**
		     * Invoked while deciding if the component should be updated as a result of
		     * receiving new props, state and/or context.
		     *
		     * Use this as an opportunity to `return false` when you're certain that the
		     * transition to the new props/state/context will not require a component
		     * update.
		     *
		     *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
		     *     return !equal(nextProps, this.props) ||
		     *       !equal(nextState, this.state) ||
		     *       !equal(nextContext, this.context);
		     *   }
		     *
		     * @param {object} nextProps
		     * @param {?object} nextState
		     * @param {?object} nextContext
		     * @return {boolean} True if the component should update.
		     * @optional
		     */
		    shouldComponentUpdate: 'DEFINE_ONCE',

		    /**
		     * Invoked when the component is about to update due to a transition from
		     * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
		     * and `nextContext`.
		     *
		     * Use this as an opportunity to perform preparation before an update occurs.
		     *
		     * NOTE: You **cannot** use `this.setState()` in this method.
		     *
		     * @param {object} nextProps
		     * @param {?object} nextState
		     * @param {?object} nextContext
		     * @param {ReactReconcileTransaction} transaction
		     * @optional
		     */
		    componentWillUpdate: 'DEFINE_MANY',

		    /**
		     * Invoked when the component's DOM representation has been updated.
		     *
		     * Use this as an opportunity to operate on the DOM when the component has
		     * been updated.
		     *
		     * @param {object} prevProps
		     * @param {?object} prevState
		     * @param {?object} prevContext
		     * @param {DOMElement} rootNode DOM element representing the component.
		     * @optional
		     */
		    componentDidUpdate: 'DEFINE_MANY',

		    /**
		     * Invoked when the component is about to be removed from its parent and have
		     * its DOM representation destroyed.
		     *
		     * Use this as an opportunity to deallocate any external resources.
		     *
		     * NOTE: There is no `componentDidUnmount` since your component will have been
		     * destroyed by that point.
		     *
		     * @optional
		     */
		    componentWillUnmount: 'DEFINE_MANY',

		    // ==== Advanced methods ====

		    /**
		     * Updates the component's currently mounted DOM representation.
		     *
		     * By default, this implements React's rendering and reconciliation algorithm.
		     * Sophisticated clients may wish to override this.
		     *
		     * @param {ReactReconcileTransaction} transaction
		     * @internal
		     * @overridable
		     */
		    updateComponent: 'OVERRIDE_BASE'
		  };

		  /**
		   * Mapping from class specification keys to special processing functions.
		   *
		   * Although these are declared like instance properties in the specification
		   * when defining classes using `React.createClass`, they are actually static
		   * and are accessible on the constructor instead of the prototype. Despite
		   * being static, they must be defined outside of the "statics" key under
		   * which all other static methods are defined.
		   */
		  var RESERVED_SPEC_KEYS = {
		    displayName: function(Constructor, displayName) {
		      Constructor.displayName = displayName;
		    },
		    mixins: function(Constructor, mixins) {
		      if (mixins) {
		        for (var i = 0; i < mixins.length; i++) {
		          mixSpecIntoComponent(Constructor, mixins[i]);
		        }
		      }
		    },
		    childContextTypes: function(Constructor, childContextTypes) {
		      if (false) {
		        validateTypeDef(Constructor, childContextTypes, 'childContext');
		      }
		      Constructor.childContextTypes = _assign(
		        {},
		        Constructor.childContextTypes,
		        childContextTypes
		      );
		    },
		    contextTypes: function(Constructor, contextTypes) {
		      if (false) {
		        validateTypeDef(Constructor, contextTypes, 'context');
		      }
		      Constructor.contextTypes = _assign(
		        {},
		        Constructor.contextTypes,
		        contextTypes
		      );
		    },
		    /**
		     * Special case getDefaultProps which should move into statics but requires
		     * automatic merging.
		     */
		    getDefaultProps: function(Constructor, getDefaultProps) {
		      if (Constructor.getDefaultProps) {
		        Constructor.getDefaultProps = createMergedResultFunction(
		          Constructor.getDefaultProps,
		          getDefaultProps
		        );
		      } else {
		        Constructor.getDefaultProps = getDefaultProps;
		      }
		    },
		    propTypes: function(Constructor, propTypes) {
		      if (false) {
		        validateTypeDef(Constructor, propTypes, 'prop');
		      }
		      Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
		    },
		    statics: function(Constructor, statics) {
		      mixStaticSpecIntoComponent(Constructor, statics);
		    },
		    autobind: function() {}
		  };

		  function validateTypeDef(Constructor, typeDef, location) {
		    for (var propName in typeDef) {
		      if (typeDef.hasOwnProperty(propName)) {
		        // use a warning instead of an _invariant so components
		        // don't show up in prod but only in __DEV__
		        if (false) {
		          warning(
		            typeof typeDef[propName] === 'function',
		            '%s: %s type `%s` is invalid; it must be a function, usually from ' +
		              'React.PropTypes.',
		            Constructor.displayName || 'ReactClass',
		            ReactPropTypeLocationNames[location],
		            propName
		          );
		        }
		      }
		    }
		  }

		  function validateMethodOverride(isAlreadyDefined, name) {
		    var specPolicy = ReactClassInterface.hasOwnProperty(name)
		      ? ReactClassInterface[name]
		      : null;

		    // Disallow overriding of base class methods unless explicitly allowed.
		    if (ReactClassMixin.hasOwnProperty(name)) {
		      _invariant(
		        specPolicy === 'OVERRIDE_BASE',
		        'ReactClassInterface: You are attempting to override ' +
		          '`%s` from your class specification. Ensure that your method names ' +
		          'do not overlap with React methods.',
		        name
		      );
		    }

		    // Disallow defining methods more than once unless explicitly allowed.
		    if (isAlreadyDefined) {
		      _invariant(
		        specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED',
		        'ReactClassInterface: You are attempting to define ' +
		          '`%s` on your component more than once. This conflict may be due ' +
		          'to a mixin.',
		        name
		      );
		    }
		  }

		  /**
		   * Mixin helper which handles policy validation and reserved
		   * specification keys when building React classes.
		   */
		  function mixSpecIntoComponent(Constructor, spec) {
		    if (!spec) {
		      if (false) {
		        var typeofSpec = typeof spec;
		        var isMixinValid = typeofSpec === 'object' && spec !== null;

		        if (process.env.NODE_ENV !== 'production') {
		          warning(
		            isMixinValid,
		            "%s: You're attempting to include a mixin that is either null " +
		              'or not an object. Check the mixins included by the component, ' +
		              'as well as any mixins they include themselves. ' +
		              'Expected object but got %s.',
		            Constructor.displayName || 'ReactClass',
		            spec === null ? null : typeofSpec
		          );
		        }
		      }

		      return;
		    }

		    _invariant(
		      typeof spec !== 'function',
		      "ReactClass: You're attempting to " +
		        'use a component class or function as a mixin. Instead, just use a ' +
		        'regular object.'
		    );
		    _invariant(
		      !isValidElement(spec),
		      "ReactClass: You're attempting to " +
		        'use a component as a mixin. Instead, just use a regular object.'
		    );

		    var proto = Constructor.prototype;
		    var autoBindPairs = proto.__reactAutoBindPairs;

		    // By handling mixins before any other properties, we ensure the same
		    // chaining order is applied to methods with DEFINE_MANY policy, whether
		    // mixins are listed before or after these methods in the spec.
		    if (spec.hasOwnProperty(MIXINS_KEY)) {
		      RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
		    }

		    for (var name in spec) {
		      if (!spec.hasOwnProperty(name)) {
		        continue;
		      }

		      if (name === MIXINS_KEY) {
		        // We have already handled mixins in a special case above.
		        continue;
		      }

		      var property = spec[name];
		      var isAlreadyDefined = proto.hasOwnProperty(name);
		      validateMethodOverride(isAlreadyDefined, name);

		      if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
		        RESERVED_SPEC_KEYS[name](Constructor, property);
		      } else {
		        // Setup methods on prototype:
		        // The following member methods should not be automatically bound:
		        // 1. Expected ReactClass methods (in the "interface").
		        // 2. Overridden methods (that were mixed in).
		        var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
		        var isFunction = typeof property === 'function';
		        var shouldAutoBind =
		          isFunction &&
		          !isReactClassMethod &&
		          !isAlreadyDefined &&
		          spec.autobind !== false;

		        if (shouldAutoBind) {
		          autoBindPairs.push(name, property);
		          proto[name] = property;
		        } else {
		          if (isAlreadyDefined) {
		            var specPolicy = ReactClassInterface[name];

		            // These cases should already be caught by validateMethodOverride.
		            _invariant(
		              isReactClassMethod &&
		                (specPolicy === 'DEFINE_MANY_MERGED' ||
		                  specPolicy === 'DEFINE_MANY'),
		              'ReactClass: Unexpected spec policy %s for key %s ' +
		                'when mixing in component specs.',
		              specPolicy,
		              name
		            );

		            // For methods which are defined more than once, call the existing
		            // methods before calling the new property, merging if appropriate.
		            if (specPolicy === 'DEFINE_MANY_MERGED') {
		              proto[name] = createMergedResultFunction(proto[name], property);
		            } else if (specPolicy === 'DEFINE_MANY') {
		              proto[name] = createChainedFunction(proto[name], property);
		            }
		          } else {
		            proto[name] = property;
		            if (false) {
		              // Add verbose displayName to the function, which helps when looking
		              // at profiling tools.
		              if (typeof property === 'function' && spec.displayName) {
		                proto[name].displayName = spec.displayName + '_' + name;
		              }
		            }
		          }
		        }
		      }
		    }
		  }

		  function mixStaticSpecIntoComponent(Constructor, statics) {
		    if (!statics) {
		      return;
		    }
		    for (var name in statics) {
		      var property = statics[name];
		      if (!statics.hasOwnProperty(name)) {
		        continue;
		      }

		      var isReserved = name in RESERVED_SPEC_KEYS;
		      _invariant(
		        !isReserved,
		        'ReactClass: You are attempting to define a reserved ' +
		          'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' +
		          'as an instance property instead; it will still be accessible on the ' +
		          'constructor.',
		        name
		      );

		      var isInherited = name in Constructor;
		      _invariant(
		        !isInherited,
		        'ReactClass: You are attempting to define ' +
		          '`%s` on your component more than once. This conflict may be ' +
		          'due to a mixin.',
		        name
		      );
		      Constructor[name] = property;
		    }
		  }

		  /**
		   * Merge two objects, but throw if both contain the same key.
		   *
		   * @param {object} one The first object, which is mutated.
		   * @param {object} two The second object
		   * @return {object} one after it has been mutated to contain everything in two.
		   */
		  function mergeIntoWithNoDuplicateKeys(one, two) {
		    _invariant(
		      one && two && typeof one === 'object' && typeof two === 'object',
		      'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.'
		    );

		    for (var key in two) {
		      if (two.hasOwnProperty(key)) {
		        _invariant(
		          one[key] === undefined,
		          'mergeIntoWithNoDuplicateKeys(): ' +
		            'Tried to merge two objects with the same key: `%s`. This conflict ' +
		            'may be due to a mixin; in particular, this may be caused by two ' +
		            'getInitialState() or getDefaultProps() methods returning objects ' +
		            'with clashing keys.',
		          key
		        );
		        one[key] = two[key];
		      }
		    }
		    return one;
		  }

		  /**
		   * Creates a function that invokes two functions and merges their return values.
		   *
		   * @param {function} one Function to invoke first.
		   * @param {function} two Function to invoke second.
		   * @return {function} Function that invokes the two argument functions.
		   * @private
		   */
		  function createMergedResultFunction(one, two) {
		    return function mergedResult() {
		      var a = one.apply(this, arguments);
		      var b = two.apply(this, arguments);
		      if (a == null) {
		        return b;
		      } else if (b == null) {
		        return a;
		      }
		      var c = {};
		      mergeIntoWithNoDuplicateKeys(c, a);
		      mergeIntoWithNoDuplicateKeys(c, b);
		      return c;
		    };
		  }

		  /**
		   * Creates a function that invokes two functions and ignores their return vales.
		   *
		   * @param {function} one Function to invoke first.
		   * @param {function} two Function to invoke second.
		   * @return {function} Function that invokes the two argument functions.
		   * @private
		   */
		  function createChainedFunction(one, two) {
		    return function chainedFunction() {
		      one.apply(this, arguments);
		      two.apply(this, arguments);
		    };
		  }

		  /**
		   * Binds a method to the component.
		   *
		   * @param {object} component Component whose method is going to be bound.
		   * @param {function} method Method to be bound.
		   * @return {function} The bound method.
		   */
		  function bindAutoBindMethod(component, method) {
		    var boundMethod = method.bind(component);
		    if (false) {
		      boundMethod.__reactBoundContext = component;
		      boundMethod.__reactBoundMethod = method;
		      boundMethod.__reactBoundArguments = null;
		      var componentName = component.constructor.displayName;
		      var _bind = boundMethod.bind;
		      boundMethod.bind = function(newThis) {
		        for (
		          var _len = arguments.length,
		            args = Array(_len > 1 ? _len - 1 : 0),
		            _key = 1;
		          _key < _len;
		          _key++
		        ) {
		          args[_key - 1] = arguments[_key];
		        }

		        // User is trying to bind() an autobound method; we effectively will
		        // ignore the value of "this" that the user is trying to use, so
		        // let's warn.
		        if (newThis !== component && newThis !== null) {
		          if (process.env.NODE_ENV !== 'production') {
		            warning(
		              false,
		              'bind(): React component methods may only be bound to the ' +
		                'component instance. See %s',
		              componentName
		            );
		          }
		        } else if (!args.length) {
		          if (process.env.NODE_ENV !== 'production') {
		            warning(
		              false,
		              'bind(): You are binding a component method to the component. ' +
		                'React does this for you automatically in a high-performance ' +
		                'way, so you can safely remove this call. See %s',
		              componentName
		            );
		          }
		          return boundMethod;
		        }
		        var reboundMethod = _bind.apply(boundMethod, arguments);
		        reboundMethod.__reactBoundContext = component;
		        reboundMethod.__reactBoundMethod = method;
		        reboundMethod.__reactBoundArguments = args;
		        return reboundMethod;
		      };
		    }
		    return boundMethod;
		  }

		  /**
		   * Binds all auto-bound methods in a component.
		   *
		   * @param {object} component Component whose method is going to be bound.
		   */
		  function bindAutoBindMethods(component) {
		    var pairs = component.__reactAutoBindPairs;
		    for (var i = 0; i < pairs.length; i += 2) {
		      var autoBindKey = pairs[i];
		      var method = pairs[i + 1];
		      component[autoBindKey] = bindAutoBindMethod(component, method);
		    }
		  }

		  var IsMountedPreMixin = {
		    componentDidMount: function() {
		      this.__isMounted = true;
		    }
		  };

		  var IsMountedPostMixin = {
		    componentWillUnmount: function() {
		      this.__isMounted = false;
		    }
		  };

		  /**
		   * Add more to the ReactClass base class. These are all legacy features and
		   * therefore not already part of the modern ReactComponent.
		   */
		  var ReactClassMixin = {
		    /**
		     * TODO: This will be deprecated because state should always keep a consistent
		     * type signature and the only use case for this, is to avoid that.
		     */
		    replaceState: function(newState, callback) {
		      this.updater.enqueueReplaceState(this, newState, callback);
		    },

		    /**
		     * Checks whether or not this composite component is mounted.
		     * @return {boolean} True if mounted, false otherwise.
		     * @protected
		     * @final
		     */
		    isMounted: function() {
		      if (false) {
		        warning(
		          this.__didWarnIsMounted,
		          '%s: isMounted is deprecated. Instead, make sure to clean up ' +
		            'subscriptions and pending requests in componentWillUnmount to ' +
		            'prevent memory leaks.',
		          (this.constructor && this.constructor.displayName) ||
		            this.name ||
		            'Component'
		        );
		        this.__didWarnIsMounted = true;
		      }
		      return !!this.__isMounted;
		    }
		  };

		  var ReactClassComponent = function() {};
		  _assign(
		    ReactClassComponent.prototype,
		    ReactComponent.prototype,
		    ReactClassMixin
		  );

		  /**
		   * Creates a composite component class given a class specification.
		   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
		   *
		   * @param {object} spec Class specification (which must define `render`).
		   * @return {function} Component constructor function.
		   * @public
		   */
		  function createClass(spec) {
		    // To keep our warnings more understandable, we'll use a little hack here to
		    // ensure that Constructor.name !== 'Constructor'. This makes sure we don't
		    // unnecessarily identify a class without displayName as 'Constructor'.
		    var Constructor = identity(function(props, context, updater) {
		      // This constructor gets overridden by mocks. The argument is used
		      // by mocks to assert on what gets mounted.

		      if (false) {
		        warning(
		          this instanceof Constructor,
		          'Something is calling a React component directly. Use a factory or ' +
		            'JSX instead. See: https://fb.me/react-legacyfactory'
		        );
		      }

		      // Wire up auto-binding
		      if (this.__reactAutoBindPairs.length) {
		        bindAutoBindMethods(this);
		      }

		      this.props = props;
		      this.context = context;
		      this.refs = emptyObject;
		      this.updater = updater || ReactNoopUpdateQueue;

		      this.state = null;

		      // ReactClasses doesn't have constructors. Instead, they use the
		      // getInitialState and componentWillMount methods for initialization.

		      var initialState = this.getInitialState ? this.getInitialState() : null;
		      if (false) {
		        // We allow auto-mocks to proceed as if they're returning null.
		        if (
		          initialState === undefined &&
		          this.getInitialState._isMockFunction
		        ) {
		          // This is probably bad practice. Consider warning here and
		          // deprecating this convenience.
		          initialState = null;
		        }
		      }
		      _invariant(
		        typeof initialState === 'object' && !Array.isArray(initialState),
		        '%s.getInitialState(): must return an object or null',
		        Constructor.displayName || 'ReactCompositeComponent'
		      );

		      this.state = initialState;
		    });
		    Constructor.prototype = new ReactClassComponent();
		    Constructor.prototype.constructor = Constructor;
		    Constructor.prototype.__reactAutoBindPairs = [];

		    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

		    mixSpecIntoComponent(Constructor, IsMountedPreMixin);
		    mixSpecIntoComponent(Constructor, spec);
		    mixSpecIntoComponent(Constructor, IsMountedPostMixin);

		    // Initialize the defaultProps property after all mixins have been merged.
		    if (Constructor.getDefaultProps) {
		      Constructor.defaultProps = Constructor.getDefaultProps();
		    }

		    if (false) {
		      // This is a tag to indicate that the use of these method names is ok,
		      // since it's used with createClass. If it's not, then it's likely a
		      // mistake so we'll warn you to use the static property, property
		      // initializer or constructor respectively.
		      if (Constructor.getDefaultProps) {
		        Constructor.getDefaultProps.isReactClassApproved = {};
		      }
		      if (Constructor.prototype.getInitialState) {
		        Constructor.prototype.getInitialState.isReactClassApproved = {};
		      }
		    }

		    _invariant(
		      Constructor.prototype.render,
		      'createClass(...): Class specification must implement a `render` method.'
		    );

		    if (false) {
		      warning(
		        !Constructor.prototype.componentShouldUpdate,
		        '%s has a method called ' +
		          'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' +
		          'The name is phrased as a question because the function is ' +
		          'expected to return a value.',
		        spec.displayName || 'A component'
		      );
		      warning(
		        !Constructor.prototype.componentWillRecieveProps,
		        '%s has a method called ' +
		          'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',
		        spec.displayName || 'A component'
		      );
		    }

		    // Reduce time spent doing lookups by setting these on the prototype.
		    for (var methodName in ReactClassInterface) {
		      if (!Constructor.prototype[methodName]) {
		        Constructor.prototype[methodName] = null;
		      }
		    }

		    return Constructor;
		  }

		  return createClass;
		}

		module.exports = factory;


	/***/ }),
	/* 105 */
	/***/ (function(module, exports, __webpack_require__) {

		/**
		 * Copyright (c) 2013-present, Facebook, Inc.
		 *
		 * This source code is licensed under the MIT license found in the
		 * LICENSE file in the root directory of this source tree.
		 *
		 */

		'use strict';

		var emptyObject = {};

		if (false) {
		  Object.freeze(emptyObject);
		}

		module.exports = emptyObject;

	/***/ }),
	/* 106 */
	/***/ (function(module, exports, __webpack_require__) {

		/**
		 * Copyright (c) 2013-present, Facebook, Inc.
		 *
		 * This source code is licensed under the MIT license found in the
		 * LICENSE file in the root directory of this source tree.
		 *
		 */

		'use strict';

		/**
		 * Use invariant() to assert state which your program assumes to be true.
		 *
		 * Provide sprintf-style format (only %s is supported) and arguments
		 * to provide information about what broke and what you were
		 * expecting.
		 *
		 * The invariant message will be stripped in production, but the invariant
		 * will remain to ensure logic does not differ in production.
		 */

		var validateFormat = function validateFormat(format) {};

		if (false) {
		  validateFormat = function validateFormat(format) {
		    if (format === undefined) {
		      throw new Error('invariant requires an error message argument');
		    }
		  };
		}

		function invariant(condition, format, a, b, c, d, e, f) {
		  validateFormat(format);

		  if (!condition) {
		    var error;
		    if (format === undefined) {
		      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
		    } else {
		      var args = [a, b, c, d, e, f];
		      var argIndex = 0;
		      error = new Error(format.replace(/%s/g, function () {
		        return args[argIndex++];
		      }));
		      error.name = 'Invariant Violation';
		    }

		    error.framesToPop = 1; // we don't care about invariant's own frame
		    throw error;
		  }
		}

		module.exports = invariant;

	/***/ }),
	/* 107 */
	/***/ (function(module, exports) {

		/*
		object-assign
		(c) Sindre Sorhus
		@license MIT
		*/

		'use strict';
		/* eslint-disable no-unused-vars */
		var getOwnPropertySymbols = Object.getOwnPropertySymbols;
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		var propIsEnumerable = Object.prototype.propertyIsEnumerable;

		function toObject(val) {
			if (val === null || val === undefined) {
				throw new TypeError('Object.assign cannot be called with null or undefined');
			}

			return Object(val);
		}

		function shouldUseNative() {
			try {
				if (!Object.assign) {
					return false;
				}

				// Detect buggy property enumeration order in older V8 versions.

				// https://bugs.chromium.org/p/v8/issues/detail?id=4118
				var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
				test1[5] = 'de';
				if (Object.getOwnPropertyNames(test1)[0] === '5') {
					return false;
				}

				// https://bugs.chromium.org/p/v8/issues/detail?id=3056
				var test2 = {};
				for (var i = 0; i < 10; i++) {
					test2['_' + String.fromCharCode(i)] = i;
				}
				var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
					return test2[n];
				});
				if (order2.join('') !== '0123456789') {
					return false;
				}

				// https://bugs.chromium.org/p/v8/issues/detail?id=3056
				var test3 = {};
				'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
					test3[letter] = letter;
				});
				if (Object.keys(Object.assign({}, test3)).join('') !==
						'abcdefghijklmnopqrst') {
					return false;
				}

				return true;
			} catch (err) {
				// We don't expect any of the above to throw, but better to be safe.
				return false;
			}
		}

		module.exports = shouldUseNative() ? Object.assign : function (target, source) {
			var from;
			var to = toObject(target);
			var symbols;

			for (var s = 1; s < arguments.length; s++) {
				from = Object(arguments[s]);

				for (var key in from) {
					if (hasOwnProperty.call(from, key)) {
						to[key] = from[key];
					}
				}

				if (getOwnPropertySymbols) {
					symbols = getOwnPropertySymbols(from);
					for (var i = 0; i < symbols.length; i++) {
						if (propIsEnumerable.call(from, symbols[i])) {
							to[symbols[i]] = from[symbols[i]];
						}
					}
				}
			}

			return to;
		};


	/***/ }),
	/* 108 */
	/***/ (function(module, exports, __webpack_require__) {

		/**
		 * Copyright (c) 2013-present, Facebook, Inc.
		 *
		 * This source code is licensed under the MIT license found in the
		 * LICENSE file in the root directory of this source tree.
		 */

		'use strict';

		var emptyFunction = __webpack_require__(110);
		var invariant = __webpack_require__(111);
		var ReactPropTypesSecret = __webpack_require__(109);

		module.exports = function() {
		  function shim(props, propName, componentName, location, propFullName, secret) {
		    if (secret === ReactPropTypesSecret) {
		      // It is still safe when called from React.
		      return;
		    }
		    invariant(
		      false,
		      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
		      'Use PropTypes.checkPropTypes() to call them. ' +
		      'Read more at http://fb.me/use-check-prop-types'
		    );
		  };
		  shim.isRequired = shim;
		  function getShim() {
		    return shim;
		  };
		  // Important!
		  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
		  var ReactPropTypes = {
		    array: shim,
		    bool: shim,
		    func: shim,
		    number: shim,
		    object: shim,
		    string: shim,
		    symbol: shim,

		    any: shim,
		    arrayOf: getShim,
		    element: shim,
		    instanceOf: getShim,
		    node: shim,
		    objectOf: getShim,
		    oneOf: getShim,
		    oneOfType: getShim,
		    shape: getShim,
		    exact: getShim
		  };

		  ReactPropTypes.checkPropTypes = emptyFunction;
		  ReactPropTypes.PropTypes = ReactPropTypes;

		  return ReactPropTypes;
		};


	/***/ }),
	/* 109 */
	/***/ (function(module, exports) {

		/**
		 * Copyright (c) 2013-present, Facebook, Inc.
		 *
		 * This source code is licensed under the MIT license found in the
		 * LICENSE file in the root directory of this source tree.
		 */

		'use strict';

		var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

		module.exports = ReactPropTypesSecret;


	/***/ }),
	/* 110 */
	/***/ (function(module, exports) {

		"use strict";

		/**
		 * Copyright (c) 2013-present, Facebook, Inc.
		 *
		 * This source code is licensed under the MIT license found in the
		 * LICENSE file in the root directory of this source tree.
		 *
		 * 
		 */

		function makeEmptyFunction(arg) {
		  return function () {
		    return arg;
		  };
		}

		/**
		 * This function accepts and discards inputs; it has no side effects. This is
		 * primarily useful idiomatically for overridable function endpoints which
		 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
		 */
		var emptyFunction = function emptyFunction() {};

		emptyFunction.thatReturns = makeEmptyFunction;
		emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
		emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
		emptyFunction.thatReturnsNull = makeEmptyFunction(null);
		emptyFunction.thatReturnsThis = function () {
		  return this;
		};
		emptyFunction.thatReturnsArgument = function (arg) {
		  return arg;
		};

		module.exports = emptyFunction;

	/***/ }),
	/* 111 */
	106,
	/* 112 */,
	/* 113 */,
	/* 114 */,
	/* 115 */,
	/* 116 */,
	/* 117 */,
	/* 118 */,
	/* 119 */,
	/* 120 */,
	/* 121 */,
	/* 122 */,
	/* 123 */,
	/* 124 */,
	/* 125 */,
	/* 126 */,
	/* 127 */,
	/* 128 */,
	/* 129 */,
	/* 130 */,
	/* 131 */,
	/* 132 */,
	/* 133 */,
	/* 134 */,
	/* 135 */,
	/* 136 */,
	/* 137 */,
	/* 138 */,
	/* 139 */,
	/* 140 */,
	/* 141 */,
	/* 142 */,
	/* 143 */,
	/* 144 */,
	/* 145 */,
	/* 146 */,
	/* 147 */,
	/* 148 */,
	/* 149 */,
	/* 150 */,
	/* 151 */,
	/* 152 */,
	/* 153 */,
	/* 154 */,
	/* 155 */,
	/* 156 */,
	/* 157 */,
	/* 158 */,
	/* 159 */,
	/* 160 */,
	/* 161 */,
	/* 162 */,
	/* 163 */,
	/* 164 */,
	/* 165 */,
	/* 166 */,
	/* 167 */,
	/* 168 */,
	/* 169 */,
	/* 170 */,
	/* 171 */,
	/* 172 */,
	/* 173 */,
	/* 174 */,
	/* 175 */,
	/* 176 */,
	/* 177 */,
	/* 178 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

		var _propTypes = __webpack_require__(3);

		var _propTypes2 = _interopRequireDefault(_propTypes);

		var _shallowEqual = __webpack_require__(75);

		var _shallowEqual2 = _interopRequireDefault(_shallowEqual);

		var _RowsContainer = __webpack_require__(66);

		var _RowsContainer2 = _interopRequireDefault(_RowsContainer);

		var _RowGroup = __webpack_require__(197);

		var _RowGroup2 = _interopRequireDefault(_RowGroup);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		var React = __webpack_require__(2);
		var createReactClass = __webpack_require__(10);
		var ReactDOM = __webpack_require__(5);
		var joinClasses = __webpack_require__(8);

		var ScrollShim = __webpack_require__(198);
		var Row = __webpack_require__(36);
		var cellMetaDataShape = __webpack_require__(11);
		var RowUtils = __webpack_require__(65);
		__webpack_require__(26);

		var Canvas = createReactClass({
		  displayName: 'Canvas',
		  mixins: [ScrollShim],

		  propTypes: {
		    rowRenderer: _propTypes2['default'].oneOfType([_propTypes2['default'].func, _propTypes2['default'].element]),
		    rowHeight: _propTypes2['default'].number.isRequired,
		    height: _propTypes2['default'].number.isRequired,
		    width: _propTypes2['default'].number,
		    totalWidth: _propTypes2['default'].oneOfType([_propTypes2['default'].number, _propTypes2['default'].string]),
		    style: _propTypes2['default'].string,
		    className: _propTypes2['default'].string,
		    displayStart: _propTypes2['default'].number.isRequired,
		    displayEnd: _propTypes2['default'].number.isRequired,
		    visibleStart: _propTypes2['default'].number.isRequired,
		    visibleEnd: _propTypes2['default'].number.isRequired,
		    colVisibleStart: _propTypes2['default'].number.isRequired,
		    colVisibleEnd: _propTypes2['default'].number.isRequired,
		    colDisplayStart: _propTypes2['default'].number.isRequired,
		    colDisplayEnd: _propTypes2['default'].number.isRequired,
		    rowsCount: _propTypes2['default'].number.isRequired,
		    rowGetter: _propTypes2['default'].oneOfType([_propTypes2['default'].func.isRequired, _propTypes2['default'].array.isRequired]),
		    expandedRows: _propTypes2['default'].array,
		    onRows: _propTypes2['default'].func,
		    onScroll: _propTypes2['default'].func,
		    columns: _propTypes2['default'].oneOfType([_propTypes2['default'].object, _propTypes2['default'].array]).isRequired,
		    cellMetaData: _propTypes2['default'].shape(cellMetaDataShape).isRequired,
		    selectedRows: _propTypes2['default'].array,
		    rowKey: _propTypes2['default'].string,
		    rowScrollTimeout: _propTypes2['default'].number,
		    scrollToRowIndex: _propTypes2['default'].number,
		    contextMenu: _propTypes2['default'].element,
		    getSubRowDetails: _propTypes2['default'].func,
		    rowSelection: _propTypes2['default'].oneOfType([_propTypes2['default'].shape({
		      indexes: _propTypes2['default'].arrayOf(_propTypes2['default'].number).isRequired
		    }), _propTypes2['default'].shape({
		      isSelectedKey: _propTypes2['default'].string.isRequired
		    }), _propTypes2['default'].shape({
		      keys: _propTypes2['default'].shape({
		        values: _propTypes2['default'].array.isRequired,
		        rowKey: _propTypes2['default'].string.isRequired
		      }).isRequired
		    })]),
		    rowGroupRenderer: _propTypes2['default'].func,
		    isScrolling: _propTypes2['default'].bool
		  },

		  getDefaultProps: function getDefaultProps() {
		    return {
		      rowRenderer: Row,
		      onRows: function onRows() {},
		      selectedRows: [],
		      rowScrollTimeout: 0
		    };
		  },
		  getInitialState: function getInitialState() {
		    return {
		      displayStart: this.props.displayStart,
		      displayEnd: this.props.displayEnd,
		      scrollingTimeout: null
		    };
		  },
		  componentWillMount: function componentWillMount() {
		    this.rows = [];
		    this._currentRowsLength = 0;
		    this._currentRowsRange = { start: 0, end: 0 };
		    this._scroll = { scrollTop: 0, scrollLeft: 0 };
		  },
		  componentDidMount: function componentDidMount() {
		    this.onRows();
		  },
		  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
		    if (nextProps.displayStart !== this.state.displayStart || nextProps.displayEnd !== this.state.displayEnd) {
		      this.setState({
		        displayStart: nextProps.displayStart,
		        displayEnd: nextProps.displayEnd
		      });
		    }
		  },
		  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
		    var shouldUpdate = nextState.displayStart !== this.state.displayStart || nextState.displayEnd !== this.state.displayEnd || nextState.scrollingTimeout !== this.state.scrollingTimeout || this.props.scrollToRowIndex !== nextProps.scrollToRowIndex || nextProps.rowsCount !== this.props.rowsCount || nextProps.rowHeight !== this.props.rowHeight || nextProps.columns !== this.props.columns || nextProps.width !== this.props.width || nextProps.height !== this.props.height || nextProps.cellMetaData !== this.props.cellMetaData || this.props.colDisplayStart !== nextProps.colDisplayStart || this.props.colDisplayEnd !== nextProps.colDisplayEnd || this.props.colVisibleStart !== nextProps.colVisibleStart || this.props.colVisibleEnd !== nextProps.colVisibleEnd || !(0, _shallowEqual2['default'])(nextProps.style, this.props.style);
		    return shouldUpdate;
		  },
		  componentWillUnmount: function componentWillUnmount() {
		    this._currentRowsLength = 0;
		    this._currentRowsRange = { start: 0, end: 0 };
		    this._scroll = { scrollTop: 0, scrollLeft: 0 };
		  },
		  componentDidUpdate: function componentDidUpdate() {
		    if (this._scroll.scrollTop !== 0 && this._scroll.scrollLeft !== 0) {
		      this.setScrollLeft(this._scroll.scrollLeft);
		    }
		    if (this.props.scrollToRowIndex !== 0) {
		      this.div.scrollTop = Math.min(this.props.scrollToRowIndex * this.props.rowHeight, this.props.rowsCount * this.props.rowHeight - this.props.height);
		    }
		    this.onRows();
		  },
		  onRows: function onRows() {
		    if (this._currentRowsRange !== { start: 0, end: 0 }) {
		      this.props.onRows(this._currentRowsRange);
		      this._currentRowsRange = { start: 0, end: 0 };
		    }
		  },
		  onScroll: function onScroll(e) {
		    if (ReactDOM.findDOMNode(this) !== e.target) {
		      return;
		    }
		    this.appendScrollShim();
		    var scrollLeft = e.target.scrollLeft;
		    var scrollTop = e.target.scrollTop;
		    var scroll = { scrollTop: scrollTop, scrollLeft: scrollLeft };
		    this._scroll = scroll;
		    this.props.onScroll(scroll);
		  },
		  getRows: function getRows(displayStart, displayEnd) {
		    this._currentRowsRange = { start: displayStart, end: displayEnd };
		    if (Array.isArray(this.props.rowGetter)) {
		      return this.props.rowGetter.slice(displayStart, displayEnd);
		    }
		    var rows = [];
		    var i = displayStart;
		    while (i < displayEnd) {
		      var row = this.props.rowGetter(i);
		      var subRowDetails = {};
		      if (this.props.getSubRowDetails) {
		        subRowDetails = this.props.getSubRowDetails(row);
		      }
		      rows.push({ row: row, subRowDetails: subRowDetails });
		      i++;
		    }
		    return rows;
		  },
		  getScrollbarWidth: function getScrollbarWidth() {
		    var scrollbarWidth = 0;
		    // Get the scrollbar width
		    var canvas = ReactDOM.findDOMNode(this);
		    scrollbarWidth = canvas.offsetWidth - canvas.clientWidth;
		    return scrollbarWidth;
		  },
		  getScroll: function getScroll() {
		    var _ReactDOM$findDOMNode = ReactDOM.findDOMNode(this),
		        scrollTop = _ReactDOM$findDOMNode.scrollTop,
		        scrollLeft = _ReactDOM$findDOMNode.scrollLeft;

		    return { scrollTop: scrollTop, scrollLeft: scrollLeft };
		  },
		  isRowSelected: function isRowSelected(idx, row) {
		    var _this = this;

		    // Use selectedRows if set
		    if (this.props.selectedRows !== null) {
		      var selectedRows = this.props.selectedRows.filter(function (r) {
		        var rowKeyValue = row.get ? row.get(_this.props.rowKey) : row[_this.props.rowKey];
		        return r[_this.props.rowKey] === rowKeyValue;
		      });
		      return selectedRows.length > 0 && selectedRows[0].isSelected;
		    }

		    // Else use new rowSelection props
		    if (this.props.rowSelection) {
		      var _props$rowSelection = this.props.rowSelection,
		          keys = _props$rowSelection.keys,
		          indexes = _props$rowSelection.indexes,
		          isSelectedKey = _props$rowSelection.isSelectedKey;

		      return RowUtils.isRowSelected(keys, indexes, isSelectedKey, row, idx);
		    }

		    return false;
		  },


		  _currentRowsLength: 0,
		  _currentRowsRange: { start: 0, end: 0 },
		  _scroll: { scrollTop: 0, scrollLeft: 0 },

		  setScrollLeft: function setScrollLeft(scrollLeft) {
		    if (this._currentRowsLength !== 0) {
		      if (!this.rows) return;
		      for (var i = 0, len = this._currentRowsLength; i < len; i++) {
		        if (this.rows[i]) {
		          var row = this.getRowByRef(i);
		          if (row && row.setScrollLeft) {
		            row.setScrollLeft(scrollLeft);
		          }
		        }
		      }
		    }
		  },
		  getRowByRef: function getRowByRef(i) {
		    // check if wrapped with React DND drop target
		    var wrappedRow = this.rows[i].getDecoratedComponentInstance ? this.rows[i].getDecoratedComponentInstance(i) : null;
		    if (wrappedRow) {
		      return wrappedRow.row;
		    }
		    return this.rows[i];
		  },
		  renderRow: function renderRow(props) {
		    var row = props.row;
		    if (row.__metaData && row.__metaData.getRowRenderer) {
		      return row.__metaData.getRowRenderer(this.props, props.idx);
		    }
		    if (row.__metaData && row.__metaData.isGroup) {
		      return React.createElement(_RowGroup2['default'], _extends({}, props, row.__metaData, {
		        name: row.name,
		        renderer: this.props.rowGroupRenderer }));
		    }
		    var RowsRenderer = this.props.rowRenderer;
		    if (typeof RowsRenderer === 'function') {
		      return React.createElement(RowsRenderer, props);
		    }

		    if (React.isValidElement(this.props.rowRenderer)) {
		      return React.cloneElement(this.props.rowRenderer, props);
		    }
		  },
		  renderPlaceholder: function renderPlaceholder(key, height) {
		    // just renders empty cells
		    // if we wanted to show gridlines, we'd need classes and position as with renderScrollingPlaceholder
		    return React.createElement(
		      'div',
		      { key: key, style: { height: height } },
		      this.props.columns.map(function (column, idx) {
		        return React.createElement('div', { style: { width: column.width }, key: idx });
		      })
		    );
		  },
		  render: function render() {
		    var _this2 = this;

		    var _state = this.state,
		        displayStart = _state.displayStart,
		        displayEnd = _state.displayEnd;
		    var _props = this.props,
		        rowHeight = _props.rowHeight,
		        rowsCount = _props.rowsCount;


		    var rows = this.getRows(displayStart, displayEnd).map(function (r, idx) {
		      return _this2.renderRow({
		        key: 'row-' + (displayStart + idx),
		        ref: function ref(node) {
		          return _this2.rows[idx] = node;
		        },
		        idx: displayStart + idx,
		        visibleStart: _this2.props.visibleStart,
		        visibleEnd: _this2.props.visibleEnd,
		        row: r.row,
		        height: rowHeight,
		        onMouseOver: _this2.onMouseOver,
		        columns: _this2.props.columns,
		        isSelected: _this2.isRowSelected(displayStart + idx, r.row, displayStart, displayEnd),
		        expandedRows: _this2.props.expandedRows,
		        cellMetaData: _this2.props.cellMetaData,
		        subRowDetails: r.subRowDetails,
		        colVisibleStart: _this2.props.colVisibleStart,
		        colVisibleEnd: _this2.props.colVisibleEnd,
		        colDisplayStart: _this2.props.colDisplayStart,
		        colDisplayEnd: _this2.props.colDisplayEnd,
		        isScrolling: _this2.props.isScrolling
		      });
		    });

		    this._currentRowsLength = rows.length;

		    if (displayStart > 0) {
		      rows.unshift(this.renderPlaceholder('top', displayStart * rowHeight));
		    }

		    if (rowsCount - displayEnd > 0) {
		      rows.push(this.renderPlaceholder('bottom', (rowsCount - displayEnd) * rowHeight));
		    }

		    var style = {
		      position: 'absolute',
		      top: 0,
		      left: 0,
		      overflowX: 'auto',
		      overflowY: 'scroll',
		      width: this.props.totalWidth,
		      height: this.props.height
		    };

		    return React.createElement(
		      'div',
		      {
		        ref: function ref(div) {
		          _this2.div = div;
		        },
		        style: style,
		        onScroll: this.onScroll,
		        className: joinClasses('react-grid-Canvas', this.props.className, { opaque: this.props.cellMetaData.selected && this.props.cellMetaData.selected.active }) },
		      React.createElement(_RowsContainer2['default'], {
		        width: this.props.width,
		        rows: rows,
		        contextMenu: this.props.contextMenu,
		        rowIdx: this.props.cellMetaData.selected.rowIdx,
		        idx: this.props.cellMetaData.selected.idx })
		    );
		  }
		});

		module.exports = Canvas;

	/***/ }),
	/* 179 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		exports.__esModule = true;

		var _classnames = __webpack_require__(8);

		var _classnames2 = _interopRequireDefault(_classnames);

		var _react = __webpack_require__(2);

		var _react2 = _interopRequireDefault(_react);

		var _propTypes = __webpack_require__(3);

		var _propTypes2 = _interopRequireDefault(_propTypes);

		var _CellActionShape = __webpack_require__(193);

		var _CellActionShape2 = _interopRequireDefault(_CellActionShape);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

		var CellAction = function (_React$Component) {
		  _inherits(CellAction, _React$Component);

		  function CellAction() {
		    var _temp, _this, _ret;

		    _classCallCheck(this, CellAction);

		    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
		      args[_key] = arguments[_key];
		    }

		    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = { isMenuOpen: false }, _this.onToggleMenu = function () {
		      _this.setState(function (prevState) {
		        return { isMenuOpen: !prevState.isMenuOpen };
		      });
		    }, _this.onHideMenu = function () {
		      _this.setState({ isMenuOpen: false });
		    }, _this.onGetMenuOptions = function () {
		      return _this.props.action.actions.map(function (action) {
		        return _react2['default'].createElement(
		          'span',
		          { onClick: action.callback },
		          action.text
		        );
		      });
		    }, _this.isActionMenu = function () {
		      return !_this.props.action.callback && _this.props.action.actions && _this.props.action.actions.length;
		    }, _this.onActionButtonBlur = function () {
		      if (_this.isActionMenu()) {
		        _this.onHideMenu();
		      }
		    }, _this.onActionIconClick = function () {
		      if (!_this.isActionMenu()) {
		        _this.props.action.callback();
		      } else if (_this.props.action.actions && _this.props.action.actions.length) {
		        _this.onToggleMenu();
		      }
		    }, _temp), _possibleConstructorReturn(_this, _ret);
		  }

		  CellAction.prototype.render = function render() {
		    var isActionMenu = this.isActionMenu();

		    var cellActionClasses = (0, _classnames2['default'])('rdg-cell-action', {
		      'rdg-cell-action-last': this.props.isFirst
		    });

		    var actionButtonClasses = (0, _classnames2['default'])('rdg-cell-action-button', {
		      'rdg-cell-action-button-toggled': this.state.isMenuOpen
		    });

		    return _react2['default'].createElement(
		      'div',
		      { className: cellActionClasses, onMouseLeave: this.onActionButtonBlur },
		      _react2['default'].createElement(
		        'div',
		        { className: actionButtonClasses, onClick: this.onActionIconClick },
		        _react2['default'].createElement('span', { className: this.props.action.icon })
		      ),
		      isActionMenu && this.state.isMenuOpen && _react2['default'].createElement(
		        'div',
		        { className: 'rdg-cell-action-menu' },
		        this.onGetMenuOptions()
		      )
		    );
		  };

		  return CellAction;
		}(_react2['default'].Component);

		CellAction.propTypes = {
		  action: _propTypes2['default'].shape(_CellActionShape2['default']).isRequired,
		  isFirst: _propTypes2['default'].bool.isRequired
		};
		exports['default'] = CellAction;

	/***/ }),
	/* 180 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		exports.__esModule = true;

		var _react = __webpack_require__(2);

		var _react2 = _interopRequireDefault(_react);

		var _propTypes = __webpack_require__(3);

		var _propTypes2 = _interopRequireDefault(_propTypes);

		var _AppConstants = __webpack_require__(34);

		var _AppConstants2 = _interopRequireDefault(_AppConstants);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

		var CellExpand = function (_React$Component) {
		  _inherits(CellExpand, _React$Component);

		  function CellExpand(props) {
		    _classCallCheck(this, CellExpand);

		    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));

		    _this.onCellExpand = function (e) {
		      _this.setState({ expanded: !_this.state.expanded });
		      _this.props.onCellExpand(e);
		    };

		    var expanded = props.expandableOptions && props.expandableOptions.expanded;
		    _this.state = { expanded: expanded };
		    return _this;
		  }

		  CellExpand.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
		    var expanded = nextProps.expandableOptions && nextProps.expandableOptions.expanded;
		    if (this.state.expanded !== expanded) {
		      this.setState({ expanded: expanded });
		    }
		  };

		  CellExpand.prototype.render = function render() {
		    return _react2['default'].createElement(
		      'span',
		      { className: 'rdg-cell-expand', onClick: this.onCellExpand },
		      this.state.expanded ? _AppConstants2['default'].CellExpand.DOWN_TRIANGLE : _AppConstants2['default'].CellExpand.RIGHT_TRIANGLE
		    );
		  };

		  return CellExpand;
		}(_react2['default'].Component);

		CellExpand.propTypes = {
		  expandableOptions: _propTypes2['default'].object.isRequired,
		  onCellExpand: _propTypes2['default'].func.isRequired
		};
		exports['default'] = CellExpand;

	/***/ }),
	/* 181 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		exports.__esModule = true;

		var _react = __webpack_require__(2);

		var _react2 = _interopRequireDefault(_react);

		var _classnames = __webpack_require__(8);

		var _classnames2 = _interopRequireDefault(_classnames);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		var ChildRowDeleteButton = function ChildRowDeleteButton(_ref) {
		  var treeDepth = _ref.treeDepth,
		      cellHeight = _ref.cellHeight,
		      siblingIndex = _ref.siblingIndex,
		      numberSiblings = _ref.numberSiblings,
		      onDeleteSubRow = _ref.onDeleteSubRow,
		      isDeleteSubRowEnabled = _ref.isDeleteSubRowEnabled,
		      _ref$allowAddChildRow = _ref.allowAddChildRow,
		      allowAddChildRow = _ref$allowAddChildRow === undefined ? true : _ref$allowAddChildRow;

		  var lastSibling = siblingIndex === numberSiblings - 1;
		  var className = (0, _classnames2['default'])({ 'rdg-child-row-action-cross': allowAddChildRow === true || !lastSibling }, { 'rdg-child-row-action-cross-last': allowAddChildRow === false && (lastSibling || numberSiblings === 1) });
		  var height = 12;
		  var width = 12;
		  var left = treeDepth * 15;
		  var top = (cellHeight - 12) / 2;
		  return _react2['default'].createElement(
		    'div',
		    null,
		    _react2['default'].createElement('div', { className: className }),
		    isDeleteSubRowEnabled && _react2['default'].createElement(
		      'div',
		      { style: { left: left, top: top, width: width, height: height }, className: 'rdg-child-row-btn', onClick: onDeleteSubRow },
		      _react2['default'].createElement('div', { className: 'glyphicon glyphicon-remove-sign' })
		    )
		  );
		};

		exports['default'] = ChildRowDeleteButton;

	/***/ }),
	/* 182 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		var isValidElement = __webpack_require__(2).isValidElement;

		module.exports = function sameColumn(a, b) {
		  var k = void 0;

		  for (k in a) {
		    if (a.hasOwnProperty(k)) {
		      if (typeof a[k] === 'function' && typeof b[k] === 'function' || isValidElement(a[k]) && isValidElement(b[k])) {
		        continue;
		      }
		      if (!b.hasOwnProperty(k) || a[k] !== b[k]) {
		        return false;
		      }
		    }
		  }

		  for (k in b) {
		    if (b.hasOwnProperty(k) && !a.hasOwnProperty(k)) {
		      return false;
		    }
		  }

		  return true;
		};

	/***/ }),
	/* 183 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		var _propTypes = __webpack_require__(3);

		var _propTypes2 = _interopRequireDefault(_propTypes);

		var _reactDom = __webpack_require__(5);

		var _reactDom2 = _interopRequireDefault(_reactDom);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

		var ColumnMetrics = __webpack_require__(35);
		var DOMMetrics = __webpack_require__(23);
		Object.assign = __webpack_require__(39);

		var ColumnUtils = __webpack_require__(9);

		var Column = function Column() {
		  _classCallCheck(this, Column);
		};

		module.exports = {
		  mixins: [DOMMetrics.MetricsMixin],

		  propTypes: {
		    columns: _propTypes2['default'].arrayOf(Column),
		    minColumnWidth: _propTypes2['default'].number,
		    columnEquality: _propTypes2['default'].func,
		    onColumnResize: _propTypes2['default'].func
		  },

		  DOMMetrics: {
		    gridWidth: function gridWidth() {
		      return _reactDom2['default'].findDOMNode(this).parentElement.offsetWidth;
		    }
		  },

		  getDefaultProps: function getDefaultProps() {
		    return {
		      minColumnWidth: 80,
		      columnEquality: ColumnMetrics.sameColumn
		    };
		  },
		  componentWillMount: function componentWillMount() {
		    this._mounted = true;
		  },
		  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
		    if (nextProps.columns) {
		      if (!ColumnMetrics.sameColumns(this.props.columns, nextProps.columns, this.props.columnEquality) || nextProps.minWidth !== this.props.minWidth) {
		        var columnMetrics = this.createColumnMetrics(nextProps);
		        this.setState({ columnMetrics: columnMetrics });
		      }
		    }
		  },
		  getTotalWidth: function getTotalWidth() {
		    var totalWidth = 0;
		    if (this._mounted) {
		      totalWidth = this.DOMMetrics.gridWidth();
		    } else {
		      totalWidth = ColumnUtils.getSize(this.props.columns) * this.props.minColumnWidth;
		    }
		    return totalWidth;
		  },
		  getColumnMetricsType: function getColumnMetricsType(metrics) {
		    var totalWidth = metrics.totalWidth || this.getTotalWidth();
		    var currentMetrics = {
		      columns: metrics.columns,
		      totalWidth: totalWidth,
		      minColumnWidth: metrics.minColumnWidth
		    };
		    var updatedMetrics = ColumnMetrics.recalculate(currentMetrics);
		    return updatedMetrics;
		  },
		  getColumn: function getColumn(idx) {
		    var columns = this.state.columnMetrics.columns;
		    if (Array.isArray(columns)) {
		      return columns[idx];
		    } else if (typeof Immutable !== 'undefined') {
		      return columns.get(idx);
		    }
		  },
		  getSize: function getSize() {
		    var columns = this.state.columnMetrics.columns;
		    if (Array.isArray(columns)) {
		      return columns.length;
		    } else if (typeof Immutable !== 'undefined') {
		      return columns.size;
		    }
		  },
		  metricsUpdated: function metricsUpdated() {
		    var columnMetrics = this.createColumnMetrics();
		    this.setState({ columnMetrics: columnMetrics });
		  },
		  createColumnMetrics: function createColumnMetrics() {
		    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;

		    var gridColumns = this.setupGridColumns(props);
		    return this.getColumnMetricsType({
		      columns: gridColumns,
		      minColumnWidth: this.props.minColumnWidth,
		      totalWidth: props.minWidth
		    });
		  },
		  onColumnResize: function onColumnResize(index, width) {
		    var columnMetrics = ColumnMetrics.resizeColumn(this.state.columnMetrics, index, width);
		    this.setState({ columnMetrics: columnMetrics });
		    if (this.props.onColumnResize) {
		      this.props.onColumnResize(index, width);
		    }
		  }
		};

	/***/ }),
	/* 184 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

		var _propTypes = __webpack_require__(3);

		var _propTypes2 = _interopRequireDefault(_propTypes);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

		var React = __webpack_require__(2);

		var createObjectWithProperties = __webpack_require__(18);
		__webpack_require__(19);

		// The list of the propTypes that we want to include in the Draggable div
		var knownDivPropertyKeys = ['onDragStart', 'onDragEnd', 'onDrag', 'style'];

		var Draggable = function (_React$Component) {
		  _inherits(Draggable, _React$Component);

		  function Draggable() {
		    var _temp, _this, _ret;

		    _classCallCheck(this, Draggable);

		    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
		      args[_key] = arguments[_key];
		    }

		    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
		      drag: null
		    }, _this.onMouseDown = function (e) {
		      var drag = _this.props.onDragStart(e);

		      if (drag === null && e.button !== 0) {
		        return;
		      }

		      window.addEventListener('mouseup', _this.onMouseUp);
		      window.addEventListener('mousemove', _this.onMouseMove);
		      window.addEventListener('touchend', _this.onMouseUp);
		      window.addEventListener('touchmove', _this.onMouseMove);

		      _this.setState({ drag: drag });
		    }, _this.onMouseMove = function (e) {
		      if (_this.state.drag === null) {
		        return;
		      }

		      if (e.preventDefault) {
		        e.preventDefault();
		      }

		      _this.props.onDrag(e);
		    }, _this.onMouseUp = function (e) {
		      _this.cleanUp();
		      _this.props.onDragEnd(e, _this.state.drag);
		      _this.setState({ drag: null });
		    }, _this.cleanUp = function () {
		      window.removeEventListener('mouseup', _this.onMouseUp);
		      window.removeEventListener('mousemove', _this.onMouseMove);
		      window.removeEventListener('touchend', _this.onMouseUp);
		      window.removeEventListener('touchmove', _this.onMouseMove);
		    }, _this.getKnownDivProps = function () {
		      return createObjectWithProperties(_this.props, knownDivPropertyKeys);
		    }, _temp), _possibleConstructorReturn(_this, _ret);
		  }

		  Draggable.prototype.componentWillUnmount = function componentWillUnmount() {
		    this.cleanUp();
		  };

		  Draggable.prototype.render = function render() {
		    return React.createElement('div', _extends({}, this.getKnownDivProps(), {
		      onMouseDown: this.onMouseDown,
		      onTouchStart: this.onMouseDown,
		      className: 'react-grid-HeaderCell__draggable' }));
		  };

		  return Draggable;
		}(React.Component);

		Draggable.propTypes = {
		  onDragStart: _propTypes2['default'].func,
		  onDragEnd: _propTypes2['default'].func,
		  onDrag: _propTypes2['default'].func,
		  component: _propTypes2['default'].oneOfType([_propTypes2['default'].func, _propTypes2['default'].constructor]),
		  style: _propTypes2['default'].object
		};
		Draggable.defaultProps = {
		  onDragStart: function onDragStart() {
		    return true;
		  },
		  onDragEnd: function onDragEnd() {},
		  onDrag: function onDrag() {}
		};


		module.exports = Draggable;

	/***/ }),
	/* 185 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		exports.__esModule = true;

		var _react = __webpack_require__(2);

		var _react2 = _interopRequireDefault(_react);

		var _propTypes = __webpack_require__(3);

		var _propTypes2 = _interopRequireDefault(_propTypes);

		var _ColumnUtils = __webpack_require__(9);

		var _ColumnUtils2 = _interopRequireDefault(_ColumnUtils);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

		var EmptyChildRow = function (_React$Component) {
		  _inherits(EmptyChildRow, _React$Component);

		  function EmptyChildRow() {
		    _classCallCheck(this, EmptyChildRow);

		    var _this = _possibleConstructorReturn(this, _React$Component.call(this));

		    _this.onAddSubRow = _this.onAddSubRow.bind(_this);
		    return _this;
		  }

		  EmptyChildRow.prototype.onAddSubRow = function onAddSubRow() {
		    this.props.onAddSubRow(this.props.parentRowId);
		  };

		  EmptyChildRow.prototype.getFixedColumnsWidth = function getFixedColumnsWidth() {
		    var fixedWidth = 0;
		    var size = _ColumnUtils2['default'].getSize(this.props.columns);
		    for (var i = 0; i < size; i++) {
		      var column = _ColumnUtils2['default'].getColumn(this.props.columns, i);
		      if (column) {
		        if (_ColumnUtils2['default'].getValue(column, 'locked')) {
		          fixedWidth += _ColumnUtils2['default'].getValue(column, 'width');
		        }
		      }
		    }
		    return fixedWidth;
		  };

		  EmptyChildRow.prototype.render = function render() {
		    var _this2 = this;

		    var _props = this.props,
		        cellHeight = _props.cellHeight,
		        treeDepth = _props.treeDepth;

		    var height = 12;
		    var width = 12;
		    var left = treeDepth * 15;
		    var top = (cellHeight - 12) / 2;
		    var style = {
		      height: cellHeight,
		      borderBottom: '1px solid #dddddd'
		    };
		    var expandColumn = _ColumnUtils2['default'].getColumn(this.props.columns.filter(function (c) {
		      return c.key === _this2.props.expandColumnKey;
		    }), 0);

		    var cellLeft = expandColumn ? expandColumn.left : 0;
		    return _react2['default'].createElement(
		      'div',
		      { className: 'react-grid-Row rdg-add-child-row-container', style: style },
		      _react2['default'].createElement(
		        'div',
		        { className: 'react-grid-Cell', style: { position: 'absolute', height: cellHeight, width: '100%', left: cellLeft } },
		        _react2['default'].createElement(
		          'div',
		          { className: 'rdg-empty-child-row', style: { marginLeft: '30px', lineHeight: cellHeight + 'px' } },
		          _react2['default'].createElement('div', { className: '\'rdg-child-row-action-cross rdg-child-row-action-cross-last' }),
		          _react2['default'].createElement(
		            'div',
		            { style: { left: left, top: top, width: width, height: height }, className: 'rdg-child-row-btn', onClick: this.onAddSubRow },
		            _react2['default'].createElement('div', { className: 'glyphicon glyphicon-plus-sign' })
		          )
		        )
		      )
		    );
		  };

		  return EmptyChildRow;
		}(_react2['default'].Component);

		EmptyChildRow.propTypes = {
		  treeDepth: _propTypes2['default'].number.isRequired,
		  cellHeight: _propTypes2['default'].number.isRequired,
		  onAddSubRow: _propTypes2['default'].func.isRequired,
		  parentRowId: _propTypes2['default'].number,
		  columns: _propTypes2['default'].array.isRequired,
		  expandColumnKey: _propTypes2['default'].string.isRequired
		};

		exports['default'] = EmptyChildRow;

	/***/ }),
	/* 186 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		var _propTypes = __webpack_require__(3);

		var _propTypes2 = _interopRequireDefault(_propTypes);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		var React = __webpack_require__(2);

		var createReactClass = __webpack_require__(10);
		var Header = __webpack_require__(188);
		var Viewport = __webpack_require__(199);
		var GridScrollMixin = __webpack_require__(187);
		var DOMMetrics = __webpack_require__(23);
		var cellMetaDataShape = __webpack_require__(11);
		__webpack_require__(26);

		var Grid = createReactClass({
		  displayName: 'Grid',

		  propTypes: {
		    rowGetter: _propTypes2['default'].oneOfType([_propTypes2['default'].array, _propTypes2['default'].func]).isRequired,
		    columns: _propTypes2['default'].oneOfType([_propTypes2['default'].array, _propTypes2['default'].object]),
		    tabIndex: _propTypes2['default'].number,
		    columnMetrics: _propTypes2['default'].object,
		    minHeight: _propTypes2['default'].number,
		    totalWidth: _propTypes2['default'].oneOfType([_propTypes2['default'].number, _propTypes2['default'].string]),
		    headerRows: _propTypes2['default'].oneOfType([_propTypes2['default'].array, _propTypes2['default'].func]),
		    rowHeight: _propTypes2['default'].number,
		    rowRenderer: _propTypes2['default'].oneOfType([_propTypes2['default'].element, _propTypes2['default'].func]),
		    emptyRowsView: _propTypes2['default'].func,
		    expandedRows: _propTypes2['default'].oneOfType([_propTypes2['default'].array, _propTypes2['default'].func]),
		    selectedRows: _propTypes2['default'].oneOfType([_propTypes2['default'].array, _propTypes2['default'].func]),
		    rowSelection: _propTypes2['default'].oneOfType([_propTypes2['default'].shape({
		      indexes: _propTypes2['default'].arrayOf(_propTypes2['default'].number).isRequired
		    }), _propTypes2['default'].shape({
		      isSelectedKey: _propTypes2['default'].string.isRequired
		    }), _propTypes2['default'].shape({
		      keys: _propTypes2['default'].shape({
		        values: _propTypes2['default'].array.isRequired,
		        rowKey: _propTypes2['default'].string.isRequired
		      }).isRequired
		    })]),
		    rowsCount: _propTypes2['default'].number,
		    onRows: _propTypes2['default'].func,
		    sortColumn: _propTypes2['default'].string,
		    sortDirection: _propTypes2['default'].oneOf(['ASC', 'DESC', 'NONE']),
		    rowOffsetHeight: _propTypes2['default'].number.isRequired,
		    onViewportKeydown: _propTypes2['default'].func.isRequired,
		    onViewportKeyup: _propTypes2['default'].func,
		    onViewportDragStart: _propTypes2['default'].func.isRequired,
		    onViewportDragEnd: _propTypes2['default'].func.isRequired,
		    onViewportClick: _propTypes2['default'].func.isRequired,
		    onViewportDoubleClick: _propTypes2['default'].func.isRequired,
		    onColumnResize: _propTypes2['default'].func,
		    onSort: _propTypes2['default'].func,
		    onHeaderDrop: _propTypes2['default'].func,
		    cellMetaData: _propTypes2['default'].shape(cellMetaDataShape),
		    rowKey: _propTypes2['default'].string.isRequired,
		    rowScrollTimeout: _propTypes2['default'].number,
		    scrollToRowIndex: _propTypes2['default'].number,
		    contextMenu: _propTypes2['default'].element,
		    getSubRowDetails: _propTypes2['default'].func,
		    draggableHeaderCell: _propTypes2['default'].func,
		    getValidFilterValues: _propTypes2['default'].func,
		    rowGroupRenderer: _propTypes2['default'].func,
		    overScan: _propTypes2['default'].object
		  },

		  mixins: [GridScrollMixin, DOMMetrics.MetricsComputatorMixin],

		  getDefaultProps: function getDefaultProps() {
		    return {
		      rowHeight: 35,
		      minHeight: 350,
		      tabIndex: 0
		    };
		  },


		  getStyle: function getStyle() {
		    return {
		      overflow: 'hidden',
		      outline: 0,
		      position: 'relative',
		      minHeight: this.props.minHeight
		    };
		  },

		  render: function render() {
		    var _this = this;

		    var headerRows = this.props.headerRows || [{ ref: function ref(node) {
		        return _this.row = node;
		      } }];
		    var EmptyRowsView = this.props.emptyRowsView;

		    return React.createElement(
		      'div',
		      { style: this.getStyle(), className: 'react-grid-Grid' },
		      React.createElement(Header, {
		        ref: function ref(input) {
		          _this.header = input;
		        },
		        columnMetrics: this.props.columnMetrics,
		        onColumnResize: this.props.onColumnResize,
		        height: this.props.rowHeight,
		        totalWidth: this.props.totalWidth,
		        headerRows: headerRows,
		        sortColumn: this.props.sortColumn,
		        sortDirection: this.props.sortDirection,
		        draggableHeaderCell: this.props.draggableHeaderCell,
		        onSort: this.props.onSort,
		        onHeaderDrop: this.props.onHeaderDrop,
		        onScroll: this.onHeaderScroll,
		        getValidFilterValues: this.props.getValidFilterValues,
		        cellMetaData: this.props.cellMetaData
		      }),
		      this.props.rowsCount >= 1 || this.props.rowsCount === 0 && !this.props.emptyRowsView ? React.createElement(
		        'div',
		        {
		          ref: function ref(node) {
		            _this.viewPortContainer = node;
		          },
		          tabIndex: this.props.tabIndex,
		          onKeyDown: this.props.onViewportKeydown,
		          onKeyUp: this.props.onViewportKeyup,
		          onClick: this.props.onViewportClick,
		          onDoubleClick: this.props.onViewportDoubleClick,
		          onDragStart: this.props.onViewportDragStart,
		          onDragEnd: this.props.onViewportDragEnd },
		        React.createElement(Viewport, {
		          ref: function ref(node) {
		            _this.viewport = node;
		          },
		          rowKey: this.props.rowKey,
		          width: this.props.columnMetrics.width,
		          rowHeight: this.props.rowHeight,
		          rowRenderer: this.props.rowRenderer,
		          rowGetter: this.props.rowGetter,
		          rowsCount: this.props.rowsCount,
		          selectedRows: this.props.selectedRows,
		          expandedRows: this.props.expandedRows,
		          columnMetrics: this.props.columnMetrics,
		          totalWidth: this.props.totalWidth,
		          onScroll: this.onScroll,
		          onRows: this.props.onRows,
		          cellMetaData: this.props.cellMetaData,
		          rowOffsetHeight: this.props.rowOffsetHeight || this.props.rowHeight * headerRows.length,
		          minHeight: this.props.minHeight,
		          rowScrollTimeout: this.props.rowScrollTimeout,
		          scrollToRowIndex: this.props.scrollToRowIndex,
		          contextMenu: this.props.contextMenu,
		          rowSelection: this.props.rowSelection,
		          getSubRowDetails: this.props.getSubRowDetails,
		          rowGroupRenderer: this.props.rowGroupRenderer,
		          overScan: this.props.overScan
		        })
		      ) : React.createElement(
		        'div',
		        { ref: function ref(node) {
		            _this.emptyView = node;
		          }, className: 'react-grid-Empty' },
		        React.createElement(EmptyRowsView, null)
		      )
		    );
		  }
		});

		module.exports = Grid;

	/***/ }),
	/* 187 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		var ReactDOM = __webpack_require__(5);

		module.exports = {
		  componentDidMount: function componentDidMount() {
		    this._scrollLeft = this.viewport ? this.viewport.getScroll().scrollLeft : 0;
		    this._onScroll();
		  },
		  componentDidUpdate: function componentDidUpdate() {
		    this._onScroll();
		  },
		  componentWillMount: function componentWillMount() {
		    this._scrollLeft = undefined;
		  },
		  componentWillUnmount: function componentWillUnmount() {
		    this._scrollLeft = undefined;
		  },
		  onScroll: function onScroll(props) {
		    if (this._scrollLeft !== props.scrollLeft) {
		      this._scrollLeft = props.scrollLeft;
		      this._onScroll();
		    }
		  },
		  onHeaderScroll: function onHeaderScroll(e) {
		    var scrollLeft = e.target.scrollLeft;
		    if (this._scrollLeft !== scrollLeft) {
		      this._scrollLeft = scrollLeft;
		      this.header.setScrollLeft(scrollLeft);
		      var canvas = ReactDOM.findDOMNode(this.viewport.canvas);
		      canvas.scrollLeft = scrollLeft;
		      this.viewport.canvas.setScrollLeft(scrollLeft);
		    }
		  },
		  _onScroll: function _onScroll() {
		    if (this._scrollLeft !== undefined) {
		      this.header.setScrollLeft(this._scrollLeft);
		      if (this.viewport) {
		        this.viewport.setScrollLeft(this._scrollLeft);
		      }
		    }
		  }
		};

	/***/ }),
	/* 188 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

		var _propTypes = __webpack_require__(3);

		var _propTypes2 = _interopRequireDefault(_propTypes);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

		var React = __webpack_require__(2);
		var ReactDOM = __webpack_require__(5);
		var joinClasses = __webpack_require__(8);
		var shallowCloneObject = __webpack_require__(38);
		var ColumnMetrics = __webpack_require__(35);
		var ColumnUtils = __webpack_require__(9);
		var HeaderRow = __webpack_require__(190);
		var getScrollbarSize = __webpack_require__(37);

		var createObjectWithProperties = __webpack_require__(18);
		var cellMetaDataShape = __webpack_require__(11);
		__webpack_require__(19);

		// The list of the propTypes that we want to include in the Header div
		var knownDivPropertyKeys = ['height', 'onScroll'];

		var Header = function (_React$Component) {
		  _inherits(Header, _React$Component);

		  function Header() {
		    var _temp, _this, _ret;

		    _classCallCheck(this, Header);

		    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
		      args[_key] = arguments[_key];
		    }

		    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = { resizing: null }, _this.onColumnResize = function (column, width) {
		      var state = _this.state.resizing || _this.props;

		      var pos = _this.getColumnPosition(column);

		      if (pos != null) {
		        var _resizing = {
		          columnMetrics: shallowCloneObject(state.columnMetrics)
		        };
		        _resizing.columnMetrics = ColumnMetrics.resizeColumn(_resizing.columnMetrics, pos, width);

		        // we don't want to influence scrollLeft while resizing
		        if (_resizing.columnMetrics.totalWidth < state.columnMetrics.totalWidth) {
		          _resizing.columnMetrics.totalWidth = state.columnMetrics.totalWidth;
		        }

		        _resizing.column = ColumnUtils.getColumn(_resizing.columnMetrics.columns, pos);
		        _this.setState({ resizing: _resizing });
		      }
		    }, _this.onColumnResizeEnd = function (column, width) {
		      var pos = _this.getColumnPosition(column);
		      if (pos !== null && _this.props.onColumnResize) {
		        _this.props.onColumnResize(pos, width || column.width);
		      }
		    }, _this.getHeaderRows = function () {
		      var columnMetrics = _this.getColumnMetrics();
		      var resizeColumn = void 0;
		      if (_this.state.resizing) {
		        resizeColumn = _this.state.resizing.column;
		      }
		      var headerRows = [];
		      _this.props.headerRows.forEach(function (row, index) {
		        // To allow header filters to be visible
		        var rowHeight = 'auto';
		        if (row.rowType === 'filter') {
		          rowHeight = '500px';
		        }
		        var scrollbarSize = getScrollbarSize() > 0 ? getScrollbarSize() : 0;
		        var updatedWidth = isNaN(_this.props.totalWidth - scrollbarSize) ? _this.props.totalWidth : _this.props.totalWidth - scrollbarSize;
		        var headerRowStyle = {
		          position: 'absolute',
		          top: _this.getCombinedHeaderHeights(index),
		          left: 0,
		          width: updatedWidth,
		          overflowX: 'hidden',
		          minHeight: rowHeight
		        };

		        headerRows.push(React.createElement(HeaderRow, {
		          key: row.ref,
		          ref: function ref(node) {
		            return row.rowType === 'filter' ? _this.filterRow = node : _this.row = node;
		          },
		          rowType: row.rowType,
		          style: headerRowStyle,
		          onColumnResize: _this.onColumnResize,
		          onColumnResizeEnd: _this.onColumnResizeEnd,
		          width: columnMetrics.width,
		          height: row.height || _this.props.height,
		          columns: columnMetrics.columns,
		          resizing: resizeColumn,
		          draggableHeaderCell: _this.props.draggableHeaderCell,
		          filterable: row.filterable,
		          onFilterChange: row.onFilterChange,
		          onHeaderDrop: _this.props.onHeaderDrop,
		          sortColumn: _this.props.sortColumn,
		          sortDirection: _this.props.sortDirection,
		          onSort: _this.props.onSort,
		          onScroll: _this.props.onScroll,
		          getValidFilterValues: _this.props.getValidFilterValues
		        }));
		      });
		      return headerRows;
		    }, _this.getColumnMetrics = function () {
		      var columnMetrics = void 0;
		      if (_this.state.resizing) {
		        columnMetrics = _this.state.resizing.columnMetrics;
		      } else {
		        columnMetrics = _this.props.columnMetrics;
		      }
		      return columnMetrics;
		    }, _this.getColumnPosition = function (column) {
		      var columnMetrics = _this.getColumnMetrics();
		      var pos = -1;
		      columnMetrics.columns.forEach(function (c, idx) {
		        if (c.key === column.key) {
		          pos = idx;
		        }
		      });
		      return pos === -1 ? null : pos;
		    }, _this.getCombinedHeaderHeights = function (until) {
		      var stopAt = _this.props.headerRows.length;
		      if (typeof until !== 'undefined') {
		        stopAt = until;
		      }

		      var height = 0;
		      for (var index = 0; index < stopAt; index++) {
		        height += _this.props.headerRows[index].height || _this.props.height;
		      }
		      return height;
		    }, _this.getStyle = function () {
		      return {
		        position: 'relative',
		        height: _this.getCombinedHeaderHeights()
		      };
		    }, _this.setScrollLeft = function (scrollLeft) {
		      var node = ReactDOM.findDOMNode(_this.row);
		      node.scrollLeft = scrollLeft;
		      _this.row.setScrollLeft(scrollLeft);
		      if (_this.filterRow) {
		        var nodeFilters = ReactDOM.findDOMNode(_this.filterRow);
		        nodeFilters.scrollLeft = scrollLeft;
		        _this.filterRow.setScrollLeft(scrollLeft);
		      }
		    }, _this.getKnownDivProps = function () {
		      return createObjectWithProperties(_this.props, knownDivPropertyKeys);
		    }, _this.onHeaderClick = function () {
		      _this.props.cellMetaData.onCellClick({ rowIdx: -1, idx: -1 });
		    }, _temp), _possibleConstructorReturn(_this, _ret);
		  }

		  Header.prototype.componentWillReceiveProps = function componentWillReceiveProps() {
		    this.setState({ resizing: null });
		  };

		  Header.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
		    var update = !ColumnMetrics.sameColumns(this.props.columnMetrics.columns, nextProps.columnMetrics.columns, ColumnMetrics.sameColumn) || this.props.totalWidth !== nextProps.totalWidth || this.props.headerRows.length !== nextProps.headerRows.length || this.state.resizing !== nextState.resizing || this.props.sortColumn !== nextProps.sortColumn || this.props.sortDirection !== nextProps.sortDirection;
		    return update;
		  };

		  // Set the cell selection to -1 x -1 when clicking on the header


		  Header.prototype.render = function render() {
		    var className = joinClasses({
		      'react-grid-Header': true,
		      'react-grid-Header--resizing': !!this.state.resizing
		    });
		    var headerRows = this.getHeaderRows();

		    return React.createElement(
		      'div',
		      _extends({}, this.getKnownDivProps(), { style: this.getStyle(), className: className, onClick: this.onHeaderClick }),
		      headerRows
		    );
		  };

		  return Header;
		}(React.Component);

		Header.propTypes = {
		  columnMetrics: _propTypes2['default'].shape({ width: _propTypes2['default'].number.isRequired, columns: _propTypes2['default'].any }).isRequired,
		  totalWidth: _propTypes2['default'].oneOfType([_propTypes2['default'].number, _propTypes2['default'].string]),
		  height: _propTypes2['default'].number.isRequired,
		  headerRows: _propTypes2['default'].array.isRequired,
		  sortColumn: _propTypes2['default'].string,
		  sortDirection: _propTypes2['default'].oneOf(['ASC', 'DESC', 'NONE']),
		  onSort: _propTypes2['default'].func,
		  onColumnResize: _propTypes2['default'].func,
		  onScroll: _propTypes2['default'].func,
		  onHeaderDrop: _propTypes2['default'].func,
		  draggableHeaderCell: _propTypes2['default'].func,
		  getValidFilterValues: _propTypes2['default'].func,
		  cellMetaData: _propTypes2['default'].shape(cellMetaDataShape)
		};


		module.exports = Header;

	/***/ }),
	/* 189 */
	/***/ (function(module, exports) {

		"use strict";

		var HeaderCellType = {
		  SORTABLE: 0,
		  FILTERABLE: 1,
		  NONE: 2,
		  CHECKBOX: 3
		};

		module.exports = HeaderCellType;

	/***/ }),
	/* 190 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

		var _propTypes = __webpack_require__(3);

		var _propTypes2 = _interopRequireDefault(_propTypes);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		var React = __webpack_require__(2);
		var createReactClass = __webpack_require__(10);
		var shallowEqual = __webpack_require__(75);
		var BaseHeaderCell = __webpack_require__(62);
		var getScrollbarSize = __webpack_require__(37);
		var ExcelColumn = __webpack_require__(12);
		var ColumnUtilsMixin = __webpack_require__(9);
		var SortableHeaderCell = __webpack_require__(202);
		var FilterableHeaderCell = __webpack_require__(201);
		var HeaderCellType = __webpack_require__(189);
		var createObjectWithProperties = __webpack_require__(18);
		__webpack_require__(19);

		var HeaderRowStyle = {
		  overflow: _propTypes2['default'].string,
		  width: _propTypes2['default'].oneOfType([_propTypes2['default'].number, _propTypes2['default'].string]),
		  height: _propTypes2['default'].number,
		  position: _propTypes2['default'].string
		};

		// The list of the propTypes that we want to include in the HeaderRow div
		var knownDivPropertyKeys = ['width', 'height', 'style', 'onScroll'];

		var HeaderRow = createReactClass({
		  displayName: 'HeaderRow',

		  propTypes: {
		    width: _propTypes2['default'].oneOfType([_propTypes2['default'].number, _propTypes2['default'].string]),
		    height: _propTypes2['default'].number.isRequired,
		    columns: _propTypes2['default'].oneOfType([_propTypes2['default'].array, _propTypes2['default'].object]).isRequired,
		    onColumnResize: _propTypes2['default'].func,
		    onSort: _propTypes2['default'].func.isRequired,
		    onColumnResizeEnd: _propTypes2['default'].func,
		    style: _propTypes2['default'].shape(HeaderRowStyle),
		    sortColumn: _propTypes2['default'].string,
		    sortDirection: _propTypes2['default'].oneOf(Object.keys(SortableHeaderCell.DEFINE_SORT)),
		    cellRenderer: _propTypes2['default'].func,
		    headerCellRenderer: _propTypes2['default'].func,
		    filterable: _propTypes2['default'].bool,
		    onFilterChange: _propTypes2['default'].func,
		    resizing: _propTypes2['default'].object,
		    onScroll: _propTypes2['default'].func,
		    rowType: _propTypes2['default'].string,
		    draggableHeaderCell: _propTypes2['default'].func,
		    onHeaderDrop: _propTypes2['default'].func
		  },

		  mixins: [ColumnUtilsMixin],

		  componentWillMount: function componentWillMount() {
		    this.cells = [];
		  },
		  shouldComponentUpdate: function shouldComponentUpdate(nextProps) {
		    return nextProps.width !== this.props.width || nextProps.height !== this.props.height || nextProps.columns !== this.props.columns || !shallowEqual(nextProps.style, this.props.style) || this.props.sortColumn !== nextProps.sortColumn || this.props.sortDirection !== nextProps.sortDirection;
		  },
		  getHeaderCellType: function getHeaderCellType(column) {
		    if (column.filterable) {
		      if (this.props.filterable) return HeaderCellType.FILTERABLE;
		    }

		    if (column.sortable && column.rowType !== 'filter') return HeaderCellType.SORTABLE;

		    return HeaderCellType.NONE;
		  },
		  getFilterableHeaderCell: function getFilterableHeaderCell(column) {
		    var FilterRenderer = FilterableHeaderCell;
		    if (column.filterRenderer !== undefined) {
		      FilterRenderer = column.filterRenderer;
		    }
		    return React.createElement(FilterRenderer, _extends({}, this.props, { onChange: this.props.onFilterChange }));
		  },
		  getSortableHeaderCell: function getSortableHeaderCell(column) {
		    var sortDirection = this.props.sortColumn === column.key ? this.props.sortDirection : SortableHeaderCell.DEFINE_SORT.NONE;
		    return React.createElement(SortableHeaderCell, { columnKey: column.key, onSort: this.props.onSort, sortDirection: sortDirection });
		  },
		  getHeaderRenderer: function getHeaderRenderer(column) {
		    var renderer = void 0;
		    if (column.headerRenderer && !this.props.filterable) {
		      renderer = column.headerRenderer;
		    } else {
		      var headerCellType = this.getHeaderCellType(column);
		      switch (headerCellType) {
		        case HeaderCellType.SORTABLE:
		          renderer = this.getSortableHeaderCell(column);
		          break;
		        case HeaderCellType.FILTERABLE:
		          renderer = this.getFilterableHeaderCell(column);
		          break;
		        default:
		          break;
		      }
		    }
		    return renderer;
		  },
		  getStyle: function getStyle() {
		    return {
		      overflow: 'hidden',
		      width: '100%',
		      height: this.props.height,
		      position: 'absolute'
		    };
		  },
		  getCells: function getCells() {
		    var _this = this;

		    var cells = [];
		    var lockedCells = [];

		    var _loop = function _loop(i, len) {
		      var column = Object.assign({ rowType: _this.props.rowType }, _this.getColumn(_this.props.columns, i));
		      var _renderer = _this.getHeaderRenderer(column);
		      if (column.key === 'select-row' && _this.props.rowType === 'filter') {
		        _renderer = React.createElement('div', null);
		      }
		      var HeaderCell = column.draggable ? _this.props.draggableHeaderCell : BaseHeaderCell;
		      var cell = React.createElement(HeaderCell, {
		        ref: function ref(node) {
		          return _this.cells[i] = node;
		        },
		        key: i,
		        height: _this.props.height,
		        column: column,
		        renderer: _renderer,
		        resizing: _this.props.resizing === column,
		        onResize: _this.props.onColumnResize,
		        onResizeEnd: _this.props.onColumnResizeEnd,
		        onHeaderDrop: _this.props.onHeaderDrop
		      });
		      if (column.locked) {
		        lockedCells.push(cell);
		      } else {
		        cells.push(cell);
		      }
		    };

		    for (var i = 0, len = this.getSize(this.props.columns); i < len; i++) {
		      _loop(i, len);
		    }

		    return cells.concat(lockedCells);
		  },
		  setScrollLeft: function setScrollLeft(scrollLeft) {
		    var _this2 = this;

		    this.props.columns.forEach(function (column, i) {
		      if (column.locked) {
		        _this2.cells[i].setScrollLeft(scrollLeft);
		      } else {
		        if (_this2.cells[i] && _this2.cells[i].removeScroll) {
		          _this2.cells[i].removeScroll();
		        }
		      }
		    });
		  },
		  getKnownDivProps: function getKnownDivProps() {
		    return createObjectWithProperties(this.props, knownDivPropertyKeys);
		  },
		  render: function render() {
		    var cellsStyle = {
		      width: this.props.width ? this.props.width + getScrollbarSize() : '100%',
		      height: this.props.height,
		      whiteSpace: 'nowrap',
		      overflowX: 'hidden',
		      overflowY: 'hidden'
		    };

		    var cells = this.getCells();
		    return React.createElement(
		      'div',
		      _extends({}, this.getKnownDivProps(), { className: 'react-grid-HeaderRow' }),
		      React.createElement(
		        'div',
		        { style: cellsStyle },
		        cells
		      )
		    );
		  }
		});

		module.exports = HeaderRow;

	/***/ }),
	/* 191 */
	/***/ (function(module, exports) {

		"use strict";

		module.exports = {
		  Backspace: 8,
		  Tab: 9,
		  Enter: 13,
		  Shift: 16,
		  Ctrl: 17,
		  Alt: 18,
		  PauseBreak: 19,
		  CapsLock: 20,
		  Escape: 27,
		  PageUp: 33,
		  PageDown: 34,
		  End: 35,
		  Home: 36,
		  LeftArrow: 37,
		  UpArrow: 38,
		  RightArrow: 39,
		  DownArrow: 40,
		  Insert: 45,
		  Delete: 46,
		  0: 48,
		  1: 49,
		  2: 50,
		  3: 51,
		  4: 52,
		  5: 53,
		  6: 54,
		  7: 55,
		  8: 56,
		  9: 57,
		  a: 65,
		  b: 66,
		  c: 67,
		  d: 68,
		  e: 69,
		  f: 70,
		  g: 71,
		  h: 72,
		  i: 73,
		  j: 74,
		  k: 75,
		  l: 76,
		  m: 77,
		  n: 78,
		  o: 79,
		  p: 80,
		  q: 81,
		  r: 82,
		  s: 83,
		  t: 84,
		  u: 85,
		  v: 86,
		  w: 87,
		  x: 88,
		  y: 89,
		  z: 90,
		  LeftWindowKey: 91,
		  RightWindowKey: 92,
		  SelectKey: 93,
		  NumPad0: 96,
		  NumPad1: 97,
		  NumPad2: 98,
		  NumPad3: 99,
		  NumPad4: 100,
		  NumPad5: 101,
		  NumPad6: 102,
		  NumPad7: 103,
		  NumPad8: 104,
		  NumPad9: 105,
		  Multiply: 106,
		  Add: 107,
		  Subtract: 109,
		  DecimalPoint: 110,
		  Divide: 111,
		  F1: 112,
		  F2: 113,
		  F3: 114,
		  F4: 115,
		  F5: 116,
		  F6: 117,
		  F7: 118,
		  F8: 119,
		  F9: 120,
		  F10: 121,
		  F12: 123,
		  NumLock: 144,
		  ScrollLock: 145,
		  SemiColon: 186,
		  EqualSign: 187,
		  Comma: 188,
		  Dash: 189,
		  Period: 190,
		  ForwardSlash: 191,
		  GraveAccent: 192,
		  OpenBracket: 219,
		  BackSlash: 220,
		  CloseBracket: 221,
		  SingleQuote: 222
		};

	/***/ }),
	/* 192 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		exports.__esModule = true;
		exports.OverflowCellComponent = undefined;

		var _react = __webpack_require__(2);

		var _react2 = _interopRequireDefault(_react);

		var _propTypes = __webpack_require__(3);

		var _propTypes2 = _interopRequireDefault(_propTypes);

		var _focusableComponentWrapper = __webpack_require__(205);

		var _focusableComponentWrapper2 = _interopRequireDefault(_focusableComponentWrapper);

		__webpack_require__(40);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

		var OverflowCell = function (_React$Component) {
		  _inherits(OverflowCell, _React$Component);

		  function OverflowCell() {
		    _classCallCheck(this, OverflowCell);

		    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
		  }

		  OverflowCell.prototype.getStyle = function getStyle() {
		    var style = {
		      position: 'absolute',
		      width: this.props.column.width,
		      height: this.props.height,
		      left: this.props.column.left,
		      border: '1px solid #eee'
		    };
		    return style;
		  };

		  OverflowCell.prototype.render = function render() {
		    return _react2['default'].createElement('div', { tabIndex: '-1', style: this.getStyle(), width: '100%', className: 'react-grid-Cell' });
		  };

		  return OverflowCell;
		}(_react2['default'].Component);

		OverflowCell.isSelected = function (props) {
		  var cellMetaData = props.cellMetaData,
		      rowIdx = props.rowIdx,
		      idx = props.idx;

		  if (cellMetaData == null) {
		    return false;
		  }

		  var selected = cellMetaData.selected;


		  return selected && selected.rowIdx === rowIdx && selected.idx === idx;
		};

		OverflowCell.isScrolling = function (props) {
		  return props.cellMetaData.isScrollingHorizontallyWithKeyboard;
		};

		OverflowCell.propTypes = {
		  rowIdx: _propTypes2['default'].number,
		  idx: _propTypes2['default'].number,
		  height: _propTypes2['default'].number,
		  column: _propTypes2['default'].object,
		  cellMetaData: _propTypes2['default'].object
		};

		OverflowCell.displayName = 'Cell';

		var OverflowCellComponent = OverflowCell;
		exports['default'] = (0, _focusableComponentWrapper2['default'])(OverflowCell);
		exports.OverflowCellComponent = OverflowCellComponent;

	/***/ }),
	/* 193 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		exports.__esModule = true;

		var _propTypes = __webpack_require__(3);

		var _propTypes2 = _interopRequireDefault(_propTypes);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		Object.assign = __webpack_require__(39);

		var action = {
		  icon: _propTypes2['default'].string.isRequired,
		  text: _propTypes2['default'].string,
		  callback: _propTypes2['default'].func
		};

		exports['default'] = Object.assign({}, action, { actions: _propTypes2['default'].arrayOf(action) });

	/***/ }),
	/* 194 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		exports.__esModule = true;

		var _ExcelColumn = __webpack_require__(12);

		var _ExcelColumn2 = _interopRequireDefault(_ExcelColumn);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		exports['default'] = { ExcelColumn: _ExcelColumn2['default'] };

	/***/ }),
	/* 195 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

		var _propTypes = __webpack_require__(3);

		var _propTypes2 = _interopRequireDefault(_propTypes);

		var _AppConstants = __webpack_require__(34);

		var _AppConstants2 = _interopRequireDefault(_AppConstants);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		var React = __webpack_require__(2);

		var createReactClass = __webpack_require__(10);
		var ReactDOM = __webpack_require__(5);
		var BaseGrid = __webpack_require__(186);
		var Row = __webpack_require__(36);
		var ExcelColumn = __webpack_require__(12);
		var KeyboardHandlerMixin = __webpack_require__(63);
		var CheckboxEditor = __webpack_require__(67);
		var DOMMetrics = __webpack_require__(23);
		var ColumnMetricsMixin = __webpack_require__(183);
		var RowUtils = __webpack_require__(65);
		var ColumnUtils = __webpack_require__(9);
		var KeyCodes = __webpack_require__(191);
		var isFunction = __webpack_require__(24);

		__webpack_require__(26);
		__webpack_require__(73);

		if (!Object.assign) {
		  Object.assign = __webpack_require__(39);
		}

		var ReactDataGrid = createReactClass({
		  displayName: 'ReactDataGrid',

		  mixins: [ColumnMetricsMixin, DOMMetrics.MetricsComputatorMixin, KeyboardHandlerMixin],

		  propTypes: {
		    rowHeight: _propTypes2['default'].number.isRequired,
		    headerRowHeight: _propTypes2['default'].number,
		    headerFiltersHeight: _propTypes2['default'].number,
		    minHeight: _propTypes2['default'].number.isRequired,
		    minWidth: _propTypes2['default'].number,
		    enableRowSelect: _propTypes2['default'].oneOfType([_propTypes2['default'].bool, _propTypes2['default'].string]),
		    onRowUpdated: _propTypes2['default'].func,
		    rowGetter: _propTypes2['default'].func.isRequired,
		    rowsCount: _propTypes2['default'].number.isRequired,
		    toolbar: _propTypes2['default'].element,
		    enableCellSelect: _propTypes2['default'].bool,
		    columns: _propTypes2['default'].oneOfType([_propTypes2['default'].object, _propTypes2['default'].array]).isRequired,
		    onFilter: _propTypes2['default'].func,
		    onCellCopyPaste: _propTypes2['default'].func,
		    onCellsDragged: _propTypes2['default'].func,
		    getCellActions: _propTypes2['default'].func,
		    onAddFilter: _propTypes2['default'].func,
		    onGridSort: _propTypes2['default'].func,
		    onDragHandleDoubleClick: _propTypes2['default'].func,
		    onGridRowsUpdated: _propTypes2['default'].func,
		    onRowSelect: _propTypes2['default'].func,
		    rowKey: _propTypes2['default'].string,
		    rowScrollTimeout: _propTypes2['default'].number,
		    scrollToRowIndex: _propTypes2['default'].number,
		    onClearFilters: _propTypes2['default'].func,
		    contextMenu: _propTypes2['default'].element,
		    cellNavigationMode: _propTypes2['default'].oneOf(['none', 'loopOverRow', 'changeRow']),
		    onCellSelected: _propTypes2['default'].func,
		    onCellDeSelected: _propTypes2['default'].func,
		    onCellExpand: _propTypes2['default'].func,
		    enableDragAndDrop: _propTypes2['default'].bool,
		    tabIndex: _propTypes2['default'].number,
		    onRowExpandToggle: _propTypes2['default'].func,
		    draggableHeaderCell: _propTypes2['default'].func,
		    getValidFilterValues: _propTypes2['default'].func,
		    rowSelection: _propTypes2['default'].shape({
		      enableShiftSelect: _propTypes2['default'].bool,
		      onRowsSelected: _propTypes2['default'].func,
		      onRowsDeselected: _propTypes2['default'].func,
		      showCheckbox: _propTypes2['default'].bool,
		      selectBy: _propTypes2['default'].oneOfType([_propTypes2['default'].shape({
		        indexes: _propTypes2['default'].arrayOf(_propTypes2['default'].number).isRequired
		      }), _propTypes2['default'].shape({
		        isSelectedKey: _propTypes2['default'].string.isRequired
		      }), _propTypes2['default'].shape({
		        keys: _propTypes2['default'].shape({
		          values: _propTypes2['default'].array.isRequired,
		          rowKey: _propTypes2['default'].string.isRequired
		        }).isRequired
		      })]).isRequired
		    }),
		    onRowClick: _propTypes2['default'].func,
		    onRowDoubleClick: _propTypes2['default'].func,
		    onGridKeyUp: _propTypes2['default'].func,
		    onGridKeyDown: _propTypes2['default'].func,
		    rowGroupRenderer: _propTypes2['default'].func,
		    rowActionsCell: _propTypes2['default'].func,
		    onCheckCellIsEditable: _propTypes2['default'].func,
		    /* called before cell is set active, returns a boolean to determine whether cell is editable */
		    overScan: _propTypes2['default'].object,
		    onDeleteSubRow: _propTypes2['default'].func,
		    onAddSubRow: _propTypes2['default'].func,
		    enableCellAutoFocus: _propTypes2['default'].bool,
		    onBeforeEdit: _propTypes2['default'].func
		  },

		  getDefaultProps: function getDefaultProps() {
		    return {
		      enableCellSelect: false,
		      tabIndex: -1,
		      rowHeight: 35,
		      headerFiltersHeight: 45,
		      enableRowSelect: false,
		      minHeight: 350,
		      rowKey: 'id',
		      rowScrollTimeout: 0,
		      scrollToRowIndex: 0,
		      cellNavigationMode: 'none',
		      overScan: {
		        colsStart: 5,
		        colsEnd: 5,
		        rowsStart: 5,
		        rowsEnd: 5
		      },
		      enableCellAutoFocus: true,
		      onBeforeEdit: function onBeforeEdit() {}
		    };
		  },


		  getInitialState: function getInitialState() {
		    var columnMetrics = this.createColumnMetrics();
		    var initialState = { columnMetrics: columnMetrics, selectedRows: [], copied: null, expandedRows: [], canFilter: false, columnFilters: {}, sortDirection: null, sortColumn: null, dragged: null, scrollOffset: 0, lastRowIdxUiSelected: -1 };
		    if (this.props.enableCellSelect) {
		      initialState.selected = { rowIdx: 0, idx: 0 };
		    } else {
		      initialState.selected = { rowIdx: -1, idx: -1 };
		    }
		    return initialState;
		  },

		  hasSelectedCellChanged: function hasSelectedCellChanged(selected) {
		    var previouslySelected = Object.assign({}, this.state.selected);
		    return previouslySelected.rowIdx !== selected.rowIdx || previouslySelected.idx !== selected.idx || previouslySelected.active === false;
		  },

		  onContextMenuHide: function onContextMenuHide() {
		    document.removeEventListener('click', this.onContextMenuHide);
		    var newSelected = Object.assign({}, this.state.selected, { contextMenuDisplayed: false });
		    this.setState({ selected: newSelected });
		  },

		  onColumnEvent: function onColumnEvent(ev, columnEvent) {
		    var idx = columnEvent.idx,
		        name = columnEvent.name;


		    if (name && typeof idx !== 'undefined') {
		      var column = this.getColumn(idx);

		      if (column && column.events && column.events[name] && typeof column.events[name] === 'function') {
		        var eventArgs = {
		          idx: idx,
		          rowIdx: columnEvent.rowIdx,
		          rowId: columnEvent.rowId,
		          column: column
		        };

		        column.events[name](ev, eventArgs);
		      }
		    }
		  },

		  onSelect: function onSelect(selected) {
		    var _this = this;

		    if (this.state.selected.rowIdx !== selected.rowIdx || this.state.selected.idx !== selected.idx || this.state.selected.active === false) {
		      var _idx = selected.idx;
		      var _rowIdx = selected.rowIdx;
		      if (this.isCellWithinBounds(selected)) {
		        var oldSelection = this.state.selected;
		        this.setState({ selected: selected }, function () {
		          if (typeof _this.props.onCellDeSelected === 'function') {
		            _this.props.onCellDeSelected(oldSelection);
		          }
		          if (typeof _this.props.onCellSelected === 'function') {
		            _this.props.onCellSelected(selected);
		          }
		        });
		      } else if (_rowIdx === -1 && _idx === -1) {
		        // When it's outside of the grid, set rowIdx anyway
		        this.setState({ selected: { idx: _idx, rowIdx: _rowIdx } });
		      }
		    }
		  },

		  onCellClick: function onCellClick(cell, e) {
		    this.onSelect({ rowIdx: cell.rowIdx, idx: cell.idx });

		    if (this.props.onRowClick && typeof this.props.onRowClick === 'function') {
		      this.props.onRowClick(cell.rowIdx, this.props.rowGetter(cell.rowIdx), this.getColumn(cell.idx));
		    }

		    if (e) {
		      e.stopPropagation();
		    }
		  },

		  onCellContextMenu: function onCellContextMenu(cell) {
		    this.onSelect({ rowIdx: cell.rowIdx, idx: cell.idx, contextMenuDisplayed: this.props.contextMenu });
		    if (this.props.contextMenu) {
		      document.addEventListener('click', this.onContextMenuHide);
		    }
		  },

		  onCellDoubleClick: function onCellDoubleClick(cell, e) {
		    this.onSelect({ rowIdx: cell.rowIdx, idx: cell.idx });
		    if (this.props.onRowDoubleClick && typeof this.props.onRowDoubleClick === 'function') {
		      this.props.onRowDoubleClick(cell.rowIdx, this.props.rowGetter(cell.rowIdx), this.getColumn(cell.idx));
		    }
		    this.setActive();
		    if (e) {
		      e.stopPropagation();
		    }
		  },

		  onPressArrowUp: function onPressArrowUp(e) {
		    this.moveSelectedCell(e, -1, 0);
		  },
		  onPressArrowDown: function onPressArrowDown(e) {
		    this.moveSelectedCell(e, 1, 0);
		  },
		  onPressArrowLeft: function onPressArrowLeft(e) {
		    this.moveSelectedCell(e, 0, -1);
		  },
		  onPressArrowRight: function onPressArrowRight(e) {
		    this.moveSelectedCell(e, 0, 1);
		  },
		  isFocusedOnCell: function isFocusedOnCell() {
		    return document.activeElement && document.activeElement.classList && document.activeElement.classList.contains('react-grid-Cell');
		  },
		  isFocusedOnTable: function isFocusedOnTable() {
		    var domNode = this.getDataGridDOMNode();
		    return domNode && domNode.contains(document.activeElement);
		  },
		  exitGrid: function exitGrid(oldSelectedCell, newSelectedValue) {
		    var _this2 = this;

		    this.setState({ selected: newSelectedValue }, function () {
		      if (typeof _this2.props.onCellDeSelected === 'function') {
		        _this2.props.onCellDeSelected(oldSelectedCell);
		      }
		    });
		  },
		  enterGrid: function enterGrid(newSelectedValue) {
		    var _this3 = this;

		    this.setState({ selected: newSelectedValue }, function () {
		      if (typeof _this3.props.onCellSelected === 'function') {
		        _this3.props.onCellSelected(newSelectedValue);
		      }
		    });
		  },
		  onPressTab: function onPressTab(e) {
		    // Scenario 0a: When there are no rows in the grid, pressing tab needs to allow the browser to handle it
		    if (this.props.rowsCount === 0) {
		      return;
		    }
		    // Scenario 0b: When we're editing a cell
		    var idx = this.state.selected.idx;
		    var rowIdx = this.state.selected.rowIdx;
		    if (this.state.selected.active === true) {
		      // if we are in a position to leave the grid, stop editing but stay in that cell
		      if (this.canExitGrid(e)) {
		        this.moveSelectedCell(e, 0, 0);
		        return;
		      }
		      // otherwise move left or right as appropriate
		      this.moveSelectedCell(e, 0, e.shiftKey ? -1 : 1);
		      return;
		    }
		    var shift = e.shiftKey === true;
		    // Scenario 1: we're at a cell where we can exit the grid
		    if (this.canExitGrid(e) && this.isFocusedOnCell()) {
		      if (shift && idx >= 0) {
		        this.exitGrid({ idx: idx, rowIdx: rowIdx }, { idx: -1, rowIdx: rowIdx, exitedLeft: true });
		        return;
		      } else if (!shift && idx >= 0) {
		        this.exitGrid({ idx: idx, rowIdx: rowIdx }, { idx: -1, rowIdx: rowIdx });
		        return;
		      }
		    }
		    // Scenario 2: we're on the div surrounding the grid and press shift+Tab
		    // and we just exited left, so we want to let the browser handle it
		    // KNOWN ISSUE: Focus on the table can come from either side and at this point we can't know how
		    // they user arrived, so it is possible that exitLeft gets set and then the user clicks out of the table
		    // and they won't be able to Shift+Tab around the site to re-enter the table from the right.
		    if (this.isFocusedOnTable() && !this.isFocusedOnCell() && shift && this.state.selected.exitedLeft) {
		      this.enterGrid({ idx: idx, rowIdx: rowIdx });
		      return;
		    }
		    // Scenario 3: we're on the div surrounding the grid and we want to enter the grid
		    if (!this.isFocusedOnCell()) {
		      // Scenario 3A: idx has been set to -1 (eg can happen when clicking into the filter box)
		      // we want to go to the first cell in the row if we press Tab
		      // we want to go to the last cell in the row if we press Shift+Tab
		      if (idx === -1) {
		        this.moveSelectedCell(e, rowIdx === -1 ? 1 : 0, shift ? this.getNbrColumns() : 1);
		        return;
		      }
		      // otherwise, there is a selected cell in the table already, and
		      // we want to trigger it to focus - setting selected in state will update
		      // the cell props, and checkFocus will be called
		      this.enterGrid({ idx: idx, rowIdx: rowIdx, changeSomething: true });
		      // make sure the browser doesn't handle it
		      e.preventDefault();
		      return;
		    }
		    this.moveSelectedCell(e, 0, e.shiftKey ? -1 : 1);
		  },
		  onPressEnter: function onPressEnter(e) {
		    this.setActive(e.key);
		  },
		  onPressDelete: function onPressDelete(e) {
		    this.setActive(e.key);
		  },
		  onPressEscape: function onPressEscape(e) {
		    this.setInactive(e.key);
		    this.handleCancelCopy();
		  },
		  onPressBackspace: function onPressBackspace(e) {
		    this.setActive(e.key);
		  },
		  onPressChar: function onPressChar(e) {
		    if (this.isKeyPrintable(e.keyCode)) {
		      this.setActive(e.keyCode);
		    }
		  },
		  onPressKeyWithCtrl: function onPressKeyWithCtrl(e) {
		    var keys = {
		      KeyCode_c: 99,
		      KeyCode_C: 67,
		      KeyCode_V: 86,
		      KeyCode_v: 118
		    };

		    var rowIdx = this.state.selected.rowIdx;
		    var row = this.props.rowGetter(rowIdx);

		    var idx = this.state.selected.idx;
		    var col = this.getColumn(idx);

		    if (ColumnUtils.canEdit(col, row, this.props.enableCellSelect)) {
		      if (e.keyCode === keys.KeyCode_c || e.keyCode === keys.KeyCode_C) {
		        var _value = this.getSelectedValue();
		        this.handleCopy({ value: _value });
		      } else if (e.keyCode === keys.KeyCode_v || e.keyCode === keys.KeyCode_V) {
		        this.handlePaste();
		      }
		    }
		  },
		  onGridRowsUpdated: function onGridRowsUpdated(cellKey, fromRow, toRow, updated, action, originRow) {
		    var rowIds = [];

		    for (var i = fromRow; i <= toRow; i++) {
		      rowIds.push(this.props.rowGetter(i)[this.props.rowKey]);
		    }

		    var fromRowData = this.props.rowGetter(action === 'COPY_PASTE' ? originRow : fromRow);
		    var fromRowId = fromRowData[this.props.rowKey];
		    var toRowId = this.props.rowGetter(toRow)[this.props.rowKey];
		    this.props.onGridRowsUpdated({ cellKey: cellKey, fromRow: fromRow, toRow: toRow, fromRowId: fromRowId, toRowId: toRowId, rowIds: rowIds, updated: updated, action: action, fromRowData: fromRowData });
		  },
		  onCellCommit: function onCellCommit(commit) {
		    var selected = Object.assign({}, this.state.selected);
		    selected.active = false;
		    var expandedRows = this.state.expandedRows;
		    // if(commit.changed && commit.changed.expandedHeight){
		    //   expandedRows = this.expandRow(commit.rowIdx, commit.changed.expandedHeight);
		    // }
		    this.setState({ selected: selected, expandedRows: expandedRows });

		    if (this.props.onRowUpdated) {
		      this.props.onRowUpdated(commit);
		    }

		    var targetRow = commit.rowIdx;

		    if (this.props.onGridRowsUpdated) {
		      this.onGridRowsUpdated(commit.cellKey, targetRow, targetRow, commit.updated, _AppConstants2['default'].UpdateActions.CELL_UPDATE);
		    }
		  },
		  onDragStart: function onDragStart(e) {
		    var idx = this.state.selected.idx;
		    // To prevent dragging down/up when reordering rows.
		    var isViewportDragging = e && e.target && e.target.className;
		    if (idx > -1 && isViewportDragging) {
		      var _value2 = this.getSelectedValue();
		      this.handleDragStart({ idx: this.state.selected.idx, rowIdx: this.state.selected.rowIdx, value: _value2 });
		      // need to set dummy data for FF
		      if (e && e.dataTransfer) {
		        if (e.dataTransfer.setData) {
		          e.dataTransfer.dropEffect = 'move';
		          e.dataTransfer.effectAllowed = 'move';
		          e.dataTransfer.setData('text/plain', '');
		        }
		      }
		    }
		  },
		  onToggleFilter: function onToggleFilter() {
		    var _this4 = this;

		    // setState() does not immediately mutate this.state but creates a pending state transition.
		    // Therefore if you want to do something after the state change occurs, pass it in as a callback function.
		    this.setState({ canFilter: !this.state.canFilter }, function () {
		      if (_this4.state.canFilter === false && _this4.props.onClearFilters) {
		        _this4.props.onClearFilters();
		      }
		    });
		  },
		  onDragHandleDoubleClick: function onDragHandleDoubleClick(e) {
		    if (this.props.onDragHandleDoubleClick) {
		      this.props.onDragHandleDoubleClick(e);
		    }

		    if (this.props.onGridRowsUpdated) {
		      var _onGridRowsUpdated;

		      var cellKey = this.getColumn(e.idx).key;
		      this.onGridRowsUpdated(cellKey, e.rowIdx, this.props.rowsCount - 1, (_onGridRowsUpdated = {}, _onGridRowsUpdated[cellKey] = e.rowData[cellKey], _onGridRowsUpdated), _AppConstants2['default'].UpdateActions.COLUMN_FILL);
		    }
		  },
		  onCellExpand: function onCellExpand(args) {
		    if (this.props.onCellExpand) {
		      this.props.onCellExpand(args);
		    }
		  },
		  onRowExpandToggle: function onRowExpandToggle(args) {
		    if (typeof this.props.onRowExpandToggle === 'function') {
		      this.props.onRowExpandToggle(args);
		    }
		  },
		  isCellWithinBounds: function isCellWithinBounds(_ref) {
		    var idx = _ref.idx,
		        rowIdx = _ref.rowIdx;

		    return idx >= 0 && rowIdx >= 0 && idx < ColumnUtils.getSize(this.state.columnMetrics.columns) && rowIdx < this.props.rowsCount;
		  },
		  handleDragStart: function handleDragStart(dragged) {
		    if (!this.dragEnabled()) {
		      return;
		    }
		    if (this.isCellWithinBounds(dragged)) {
		      this.setState({ dragged: dragged });
		    }
		  },
		  handleDragEnd: function handleDragEnd() {
		    if (!this.dragEnabled()) {
		      return;
		    }
		    var _state = this.state,
		        selected = _state.selected,
		        dragged = _state.dragged;

		    var column = this.getColumn(this.state.selected.idx);
		    if (selected && dragged && column) {
		      var cellKey = column.key;
		      var fromRow = selected.rowIdx < dragged.overRowIdx ? selected.rowIdx : dragged.overRowIdx;
		      var toRow = selected.rowIdx > dragged.overRowIdx ? selected.rowIdx : dragged.overRowIdx;
		      if (this.props.onCellsDragged) {
		        this.props.onCellsDragged({ cellKey: cellKey, fromRow: fromRow, toRow: toRow, value: dragged.value });
		      }
		      if (this.props.onGridRowsUpdated) {
		        var _onGridRowsUpdated2;

		        this.onGridRowsUpdated(cellKey, fromRow, toRow, (_onGridRowsUpdated2 = {}, _onGridRowsUpdated2[cellKey] = dragged.value, _onGridRowsUpdated2), _AppConstants2['default'].UpdateActions.CELL_DRAG);
		      }
		    }
		    this.setState({ dragged: { complete: true } });
		  },
		  handleDragEnter: function handleDragEnter(row) {
		    if (!this.dragEnabled() || this.state.dragged == null) {
		      return;
		    }
		    var dragged = this.state.dragged;
		    dragged.overRowIdx = row;
		    this.setState({ dragged: dragged });
		  },
		  handleTerminateDrag: function handleTerminateDrag() {
		    if (!this.dragEnabled()) {
		      return;
		    }
		    this.setState({ dragged: null });
		  },
		  handlePaste: function handlePaste() {
		    if (!this.copyPasteEnabled() || !this.state.copied) {
		      return;
		    }
		    var selected = this.state.selected;
		    var cellKey = this.getColumn(this.state.selected.idx).key;
		    var textToCopy = this.state.textToCopy;
		    var fromRow = this.state.copied.rowIdx;
		    var toRow = selected.rowIdx;

		    if (this.props.onCellCopyPaste) {
		      this.props.onCellCopyPaste({ cellKey: cellKey, rowIdx: toRow, value: textToCopy, fromRow: fromRow, toRow: toRow });
		    }

		    if (this.props.onGridRowsUpdated) {
		      var _onGridRowsUpdated3;

		      this.onGridRowsUpdated(cellKey, toRow, toRow, (_onGridRowsUpdated3 = {}, _onGridRowsUpdated3[cellKey] = textToCopy, _onGridRowsUpdated3), _AppConstants2['default'].UpdateActions.COPY_PASTE, fromRow);
		    }
		  },
		  handleCancelCopy: function handleCancelCopy() {
		    this.setState({ copied: null });
		  },
		  handleCopy: function handleCopy(args) {
		    if (!this.copyPasteEnabled()) {
		      return;
		    }
		    var textToCopy = args.value;
		    var selected = this.state.selected;
		    var copied = { idx: selected.idx, rowIdx: selected.rowIdx };
		    this.setState({ textToCopy: textToCopy, copied: copied });
		  },


		  handleSort: function handleSort(columnKey, direction) {
		    this.setState({ sortDirection: direction, sortColumn: columnKey }, function () {
		      this.props.onGridSort(columnKey, direction);
		    });
		  },

		  getSelectedRow: function getSelectedRow(rows, key) {
		    var _this5 = this;

		    var selectedRow = rows.filter(function (r) {
		      if (r[_this5.props.rowKey] === key) {
		        return true;
		      }
		      return false;
		    });
		    if (selectedRow.length > 0) {
		      return selectedRow[0];
		    }
		  },
		  useNewRowSelection: function useNewRowSelection() {
		    return this.props.rowSelection && this.props.rowSelection.selectBy;
		  },


		  // return false if not a shift select so can be handled as normal row selection
		  handleShiftSelect: function handleShiftSelect(rowIdx) {
		    if (this.state.lastRowIdxUiSelected > -1 && this.isSingleKeyDown(KeyCodes.Shift)) {
		      var _props$rowSelection$s = this.props.rowSelection.selectBy,
		          keys = _props$rowSelection$s.keys,
		          indexes = _props$rowSelection$s.indexes,
		          isSelectedKey = _props$rowSelection$s.isSelectedKey;

		      var isPreviouslySelected = RowUtils.isRowSelected(keys, indexes, isSelectedKey, this.props.rowGetter(rowIdx), rowIdx);

		      if (isPreviouslySelected) return false;

		      var handled = false;

		      if (rowIdx > this.state.lastRowIdxUiSelected) {
		        var rowsSelected = [];

		        for (var i = this.state.lastRowIdxUiSelected + 1; i <= rowIdx; i++) {
		          rowsSelected.push({ rowIdx: i, row: this.props.rowGetter(i) });
		        }

		        if (typeof this.props.rowSelection.onRowsSelected === 'function') {
		          this.props.rowSelection.onRowsSelected(rowsSelected);
		        }

		        handled = true;
		      } else if (rowIdx < this.state.lastRowIdxUiSelected) {
		        var _rowsSelected = [];

		        for (var _i = rowIdx; _i <= this.state.lastRowIdxUiSelected - 1; _i++) {
		          _rowsSelected.push({ rowIdx: _i, row: this.props.rowGetter(_i) });
		        }

		        if (typeof this.props.rowSelection.onRowsSelected === 'function') {
		          this.props.rowSelection.onRowsSelected(_rowsSelected);
		        }

		        handled = true;
		      }

		      if (handled) {
		        this.setState({ lastRowIdxUiSelected: rowIdx });
		      }

		      return handled;
		    }

		    return false;
		  },
		  handleNewRowSelect: function handleNewRowSelect(rowIdx, rowData) {
		    if (this.selectAllCheckbox && this.selectAllCheckbox.checked === true) {
		      this.selectAllCheckbox.checked = false;
		    }

		    var _props$rowSelection$s2 = this.props.rowSelection.selectBy,
		        keys = _props$rowSelection$s2.keys,
		        indexes = _props$rowSelection$s2.indexes,
		        isSelectedKey = _props$rowSelection$s2.isSelectedKey;

		    var isPreviouslySelected = RowUtils.isRowSelected(keys, indexes, isSelectedKey, rowData, rowIdx);

		    this.setState({ lastRowIdxUiSelected: isPreviouslySelected ? -1 : rowIdx, selected: { rowIdx: rowIdx, idx: 0 } });

		    if (isPreviouslySelected && typeof this.props.rowSelection.onRowsDeselected === 'function') {
		      this.props.rowSelection.onRowsDeselected([{ rowIdx: rowIdx, row: rowData }]);
		    } else if (!isPreviouslySelected && typeof this.props.rowSelection.onRowsSelected === 'function') {
		      this.props.rowSelection.onRowsSelected([{ rowIdx: rowIdx, row: rowData }]);
		    }
		  },


		  // columnKey not used here as this function will select the whole row,
		  // but needed to match the function signature in the CheckboxEditor
		  handleRowSelect: function handleRowSelect(rowIdx, columnKey, rowData, e) {
		    e.stopPropagation();

		    if (this.useNewRowSelection()) {
		      if (this.props.rowSelection.enableShiftSelect === true) {
		        if (!this.handleShiftSelect(rowIdx)) {
		          this.handleNewRowSelect(rowIdx, rowData);
		        }
		      } else {
		        this.handleNewRowSelect(rowIdx, rowData);
		      }
		    } else {
		      // Fallback to old onRowSelect handler
		      var _selectedRows = this.props.enableRowSelect === 'single' ? [] : this.state.selectedRows.slice(0);
		      var selectedRow = this.getSelectedRow(_selectedRows, rowData[this.props.rowKey]);
		      if (selectedRow) {
		        selectedRow.isSelected = !selectedRow.isSelected;
		      } else {
		        rowData.isSelected = true;
		        _selectedRows.push(rowData);
		      }
		      this.setState({ selectedRows: _selectedRows, selected: { rowIdx: rowIdx, idx: 0 } });
		      if (this.props.onRowSelect) {
		        this.props.onRowSelect(_selectedRows.filter(function (r) {
		          return r.isSelected === true;
		        }));
		      }
		    }
		  },


		  handleCheckboxChange: function handleCheckboxChange(e) {
		    var allRowsSelected = void 0;
		    if (e.currentTarget instanceof HTMLInputElement && e.currentTarget.checked === true) {
		      allRowsSelected = true;
		    } else {
		      allRowsSelected = false;
		    }
		    if (this.useNewRowSelection()) {
		      var _props$rowSelection$s3 = this.props.rowSelection.selectBy,
		          keys = _props$rowSelection$s3.keys,
		          indexes = _props$rowSelection$s3.indexes,
		          isSelectedKey = _props$rowSelection$s3.isSelectedKey;


		      if (allRowsSelected && typeof this.props.rowSelection.onRowsSelected === 'function') {
		        var _selectedRows2 = [];
		        for (var i = 0; i < this.props.rowsCount; i++) {
		          var rowData = this.props.rowGetter(i);
		          if (!RowUtils.isRowSelected(keys, indexes, isSelectedKey, rowData, i)) {
		            _selectedRows2.push({ rowIdx: i, row: rowData });
		          }
		        }

		        if (_selectedRows2.length > 0) {
		          this.props.rowSelection.onRowsSelected(_selectedRows2);
		        }
		      } else if (!allRowsSelected && typeof this.props.rowSelection.onRowsDeselected === 'function') {
		        var deselectedRows = [];
		        for (var _i2 = 0; _i2 < this.props.rowsCount; _i2++) {
		          var _rowData = this.props.rowGetter(_i2);
		          if (RowUtils.isRowSelected(keys, indexes, isSelectedKey, _rowData, _i2)) {
		            deselectedRows.push({ rowIdx: _i2, row: _rowData });
		          }
		        }

		        if (deselectedRows.length > 0) {
		          this.props.rowSelection.onRowsDeselected(deselectedRows);
		        }
		      }
		    } else {
		      var _selectedRows3 = [];
		      for (var _i3 = 0; _i3 < this.props.rowsCount; _i3++) {
		        var row = Object.assign({}, this.props.rowGetter(_i3), { isSelected: allRowsSelected });
		        _selectedRows3.push(row);
		      }
		      this.setState({ selectedRows: _selectedRows3 });
		      if (typeof this.props.onRowSelect === 'function') {
		        this.props.onRowSelect(_selectedRows3.filter(function (r) {
		          return r.isSelected === true;
		        }));
		      }
		    }
		  },

		  getScrollOffSet: function getScrollOffSet() {
		    var scrollOffset = 0;
		    var canvas = ReactDOM.findDOMNode(this).querySelector('.react-grid-Canvas');
		    if (canvas) {
		      scrollOffset = canvas.offsetWidth - canvas.clientWidth;
		    }
		    this.setState({ scrollOffset: scrollOffset });
		  },
		  getRowOffsetHeight: function getRowOffsetHeight() {
		    var offsetHeight = 0;
		    this.getHeaderRows().forEach(function (row) {
		      return offsetHeight += parseFloat(row.height, 10);
		    });
		    return offsetHeight;
		  },
		  getHeaderRows: function getHeaderRows() {
		    var _this6 = this;

		    var rows = [{ ref: function ref(node) {
		        return _this6.row = node;
		      }, height: this.props.headerRowHeight || this.props.rowHeight, rowType: 'header' }];
		    if (this.state.canFilter === true) {
		      rows.push({
		        ref: function ref(node) {
		          return _this6.filterRow = node;
		        },
		        filterable: true,
		        onFilterChange: this.props.onAddFilter,
		        height: this.props.headerFiltersHeight,
		        rowType: 'filter'
		      });
		    }
		    return rows;
		  },


		  getInitialSelectedRows: function getInitialSelectedRows() {
		    var selectedRows = [];
		    for (var i = 0; i < this.props.rowsCount; i++) {
		      selectedRows.push(false);
		    }
		    return selectedRows;
		  },

		  getRowSelectionProps: function getRowSelectionProps() {
		    if (this.props.rowSelection) {
		      return this.props.rowSelection.selectBy;
		    }

		    return null;
		  },
		  getSelectedRows: function getSelectedRows() {
		    if (this.props.rowSelection) {
		      return null;
		    }

		    return this.state.selectedRows.filter(function (r) {
		      return r.isSelected === true;
		    });
		  },
		  getSelectedValue: function getSelectedValue() {
		    var rowIdx = this.state.selected.rowIdx;
		    var idx = this.state.selected.idx;
		    var cellKey = this.getColumn(idx).key;
		    var row = this.props.rowGetter(rowIdx);
		    return RowUtils.get(row, cellKey);
		  },
		  canExitGrid: function canExitGrid(e) {
		    // When the cellNavigationMode is 'none', you can exit the grid if you're at the start or end of the row
		    // When the cellNavigationMode is 'changeRow', you can exit the grid if you're at the first or last cell of the grid
		    // When the cellNavigationMode is 'loopOverRow', there is no logical exit point so you can't exit the grid
		    var atLastCellInRow = this.isAtLastCellInRow(this.getNbrColumns());
		    var atFirstCellInRow = this.isAtFirstCellInRow();
		    var atLastRow = this.isAtLastRow();
		    var atFirstRow = this.isAtFirstRow();
		    var shift = e.shiftKey === true;
		    var cellNavigationMode = this.props.cellNavigationMode;

		    if (shift) {
		      if (cellNavigationMode === 'none') {
		        if (atFirstCellInRow) {
		          return true;
		        }
		      } else if (cellNavigationMode === 'changeRow') {
		        if (atFirstCellInRow && atFirstRow) {
		          return true;
		        }
		      }
		    } else {
		      if (cellNavigationMode === 'none') {
		        if (atLastCellInRow) {
		          return true;
		        }
		      } else if (cellNavigationMode === 'changeRow') {
		        if (atLastCellInRow && atLastRow) {
		          return true;
		        }
		      }
		    }
		    return false;
		  },
		  moveSelectedCell: function moveSelectedCell(e, rowDelta, cellDelta) {
		    // we need to prevent default as we control grid scroll
		    // otherwise it moves every time you left/right which is janky
		    e.preventDefault();
		    var rowIdx = void 0;
		    var idx = void 0;
		    var cellNavigationMode = this.props.cellNavigationMode;

		    if (cellNavigationMode !== 'none') {
		      var _calculateNextSelecti = this.calculateNextSelectionPosition(cellNavigationMode, cellDelta, rowDelta);

		      idx = _calculateNextSelecti.idx;
		      rowIdx = _calculateNextSelecti.rowIdx;
		    } else {
		      rowIdx = this.state.selected.rowIdx + rowDelta;
		      idx = this.state.selected.idx + cellDelta;
		    }
		    this.scrollToColumn(idx);
		    this.onSelect({ idx: idx, rowIdx: rowIdx });
		  },
		  getNbrColumns: function getNbrColumns() {
		    var _props = this.props,
		        columns = _props.columns,
		        enableRowSelect = _props.enableRowSelect;

		    return enableRowSelect ? columns.length + 1 : columns.length;
		  },
		  getDataGridDOMNode: function getDataGridDOMNode() {
		    if (!this._gridNode) {
		      this._gridNode = ReactDOM.findDOMNode(this);
		    }
		    return this._gridNode;
		  },
		  calculateNextSelectionPosition: function calculateNextSelectionPosition(cellNavigationMode, cellDelta, rowDelta) {
		    var _rowDelta = rowDelta;
		    var idx = this.state.selected.idx + cellDelta;
		    var nbrColumns = this.getNbrColumns();
		    if (cellDelta > 0) {
		      if (this.isAtLastCellInRow(nbrColumns)) {
		        if (cellNavigationMode === 'changeRow') {
		          _rowDelta = this.isAtLastRow() ? rowDelta : rowDelta + 1;
		          idx = this.isAtLastRow() ? idx : 0;
		        } else {
		          idx = 0;
		        }
		      }
		    } else if (cellDelta < 0) {
		      if (this.isAtFirstCellInRow()) {
		        if (cellNavigationMode === 'changeRow') {
		          _rowDelta = this.isAtFirstRow() ? rowDelta : rowDelta - 1;
		          idx = this.isAtFirstRow() ? 0 : nbrColumns - 1;
		        } else {
		          idx = nbrColumns - 1;
		        }
		      }
		    }
		    var rowIdx = this.state.selected.rowIdx + _rowDelta;
		    return { idx: idx, rowIdx: rowIdx };
		  },
		  isAtLastCellInRow: function isAtLastCellInRow(nbrColumns) {
		    return this.state.selected.idx === nbrColumns - 1;
		  },
		  isAtLastRow: function isAtLastRow() {
		    return this.state.selected.rowIdx === this.props.rowsCount - 1;
		  },
		  isAtFirstCellInRow: function isAtFirstCellInRow() {
		    return this.state.selected.idx === 0;
		  },
		  isAtFirstRow: function isAtFirstRow() {
		    return this.state.selected.rowIdx === 0;
		  },
		  openCellEditor: function openCellEditor(rowIdx, idx) {
		    var _this7 = this;

		    var row = this.props.rowGetter(rowIdx);
		    var col = this.getColumn(idx);

		    if (!ColumnUtils.canEdit(col, row, this.props.enableCellSelect)) {
		      return;
		    }

		    var selected = { rowIdx: rowIdx, idx: idx };
		    if (this.hasSelectedCellChanged(selected)) {
		      this.setState({ selected: selected }, function () {
		        _this7.setActive('Enter');
		      });
		    } else {
		      this.setActive('Enter');
		    }
		  },
		  scrollToColumn: function scrollToColumn(colIdx) {
		    var canvas = ReactDOM.findDOMNode(this).querySelector('.react-grid-Canvas');
		    if (canvas) {
		      var left = 0;
		      var locked = 0;

		      for (var i = 0; i < colIdx; i++) {
		        var column = this.getColumn(i);
		        if (column) {
		          if (column.width) {
		            left += column.width;
		          }
		          if (column.locked) {
		            locked += column.width;
		          }
		        }
		      }

		      var selectedColumn = this.getColumn(colIdx);
		      if (selectedColumn) {
		        var scrollLeft = left - locked - canvas.scrollLeft;
		        var scrollRight = left + selectedColumn.width - canvas.scrollLeft;

		        if (scrollLeft < 0) {
		          canvas.scrollLeft += scrollLeft;
		        } else if (scrollRight > canvas.clientWidth) {
		          var scrollAmount = scrollRight - canvas.clientWidth;
		          canvas.scrollLeft += scrollAmount;
		        }
		      }
		    }
		  },
		  deselect: function deselect() {
		    var selected = { rowIdx: -1, idx: -1 };
		    this.setState({ selected: selected });
		  },
		  setActive: function setActive(keyPressed) {
		    var _this8 = this;

		    var rowIdx = this.state.selected.rowIdx;
		    var row = this.props.rowGetter(rowIdx);

		    var idx = this.state.selected.idx;
		    var column = this.getColumn(idx);

		    if (ColumnUtils.canEdit(column, row, this.props.enableCellSelect) && !this.isActive()) {
		      var _selected = Object.assign({}, this.state.selected, { idx: idx, rowIdx: rowIdx, active: true, initialKeyCode: keyPressed });
		      var showEditor = true;
		      if (typeof this.props.onCheckCellIsEditable === 'function') {
		        var args = Object.assign({}, { row: row, column: column }, _selected);
		        showEditor = this.props.onCheckCellIsEditable(args);
		      }
		      if (showEditor !== false) {
		        if (column.locked) {
		          this.setState({ selected: _selected });
		        } else {
		          this.setState({ selected: _selected }, function () {
		            _this8.scrollToColumn(idx);
		          });
		        }
		        this.props.onBeforeEdit();
		        this.handleCancelCopy();
		      }
		    }
		  },
		  setInactive: function setInactive() {
		    var rowIdx = this.state.selected.rowIdx;
		    var row = this.props.rowGetter(rowIdx);

		    var idx = this.state.selected.idx;
		    var col = this.getColumn(idx);

		    if (ColumnUtils.canEdit(col, row, this.props.enableCellSelect) && this.isActive()) {
		      var _selected2 = Object.assign({}, this.state.selected, { idx: idx, rowIdx: rowIdx, active: false });
		      this.setState({ selected: _selected2 });
		    }
		  },
		  isActive: function isActive() {
		    return this.state.selected.active === true;
		  },


		  setupGridColumns: function setupGridColumns() {
		    var _this9 = this;

		    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;
		    var columns = props.columns;

		    if (this._cachedColumns === columns) {
		      return this._cachedComputedColumns;
		    }

		    this._cachedColumns = columns;

		    var cols = columns.slice(0);
		    var unshiftedCols = {};
		    if (this.props.rowActionsCell || props.enableRowSelect && !this.props.rowSelection || props.rowSelection && props.rowSelection.showCheckbox !== false) {
		      var headerRenderer = props.enableRowSelect === 'single' ? null : React.createElement(
		        'div',
		        { className: 'react-grid-checkbox-container checkbox-align' },
		        React.createElement('input', { className: 'react-grid-checkbox', type: 'checkbox', name: 'select-all-checkbox', id: 'select-all-checkbox', ref: function ref(grid) {
		            return _this9.selectAllCheckbox = grid;
		          }, onChange: this.handleCheckboxChange }),
		        React.createElement('label', { htmlFor: 'select-all-checkbox', className: 'react-grid-checkbox-label' })
		      );
		      var Formatter = this.props.rowActionsCell ? this.props.rowActionsCell : CheckboxEditor;
		      var selectColumn = {
		        key: 'select-row',
		        name: '',
		        formatter: React.createElement(Formatter, { rowSelection: this.props.rowSelection }),
		        onCellChange: this.handleRowSelect,
		        filterable: false,
		        headerRenderer: headerRenderer,
		        width: 60,
		        locked: true,
		        getRowMetaData: function getRowMetaData(rowData) {
		          return rowData;
		        },
		        cellClass: this.props.rowActionsCell ? 'rdg-row-actions-cell' : ''
		      };
		      unshiftedCols = cols.unshift(selectColumn);
		      cols = unshiftedCols > 0 ? cols : unshiftedCols;
		    }
		    this._cachedComputedColumns = cols;

		    return this._cachedComputedColumns;
		  },

		  copyPasteEnabled: function copyPasteEnabled() {
		    return this.props.onCellCopyPaste !== null;
		  },

		  dragEnabled: function dragEnabled() {
		    return this.props.onGridRowsUpdated !== undefined || this.props.onCellsDragged !== undefined;
		  },

		  renderToolbar: function renderToolbar() {
		    var Toolbar = this.props.toolbar;
		    var toolBarProps = { columns: this.props.columns, onToggleFilter: this.onToggleFilter, numberOfRows: this.props.rowsCount };
		    if (React.isValidElement(Toolbar)) {
		      return React.cloneElement(Toolbar, toolBarProps);
		    } else if (isFunction(Toolbar)) {
		      return React.createElement(Toolbar, toolBarProps);
		    }
		  },
		  render: function render() {
		    var _this10 = this;

		    var cellMetaData = {
		      rowKey: this.props.rowKey,
		      selected: this.state.selected,
		      dragged: this.state.dragged,
		      hoveredRowIdx: this.state.hoveredRowIdx,
		      onCellClick: this.onCellClick,
		      onCellContextMenu: this.onCellContextMenu,
		      onCellDoubleClick: this.onCellDoubleClick,
		      onCommit: this.onCellCommit,
		      onCommitCancel: this.setInactive,
		      copied: this.state.copied,
		      handleDragEnterRow: this.handleDragEnter,
		      handleTerminateDrag: this.handleTerminateDrag,
		      enableCellSelect: this.props.enableCellSelect,
		      onColumnEvent: this.onColumnEvent,
		      openCellEditor: this.openCellEditor,
		      onDragHandleDoubleClick: this.onDragHandleDoubleClick,
		      onCellExpand: this.onCellExpand,
		      onRowExpandToggle: this.onRowExpandToggle,
		      onRowHover: this.onRowHover,
		      getDataGridDOMNode: this.getDataGridDOMNode,
		      getCellActions: this.props.getCellActions,
		      onDeleteSubRow: this.props.onDeleteSubRow,
		      onAddSubRow: this.props.onAddSubRow,
		      isScrollingVerticallyWithKeyboard: this.isKeyDown(KeyCodes.DownArrow) || this.isKeyDown(KeyCodes.UpArrow),
		      isScrollingHorizontallyWithKeyboard: this.isKeyDown(KeyCodes.LeftArrow) || this.isKeyDown(KeyCodes.RightArrow) || this.isKeyDown(KeyCodes.Tab),
		      enableCellAutoFocus: this.props.enableCellAutoFocus
		    };

		    var toolbar = this.renderToolbar();
		    var containerWidth = this.props.minWidth || this.DOMMetrics.gridWidth();
		    var gridWidth = containerWidth - this.state.scrollOffset;

		    // depending on the current lifecycle stage, gridWidth() may not initialize correctly
		    // this also handles cases where it always returns undefined -- such as when inside a div with display:none
		    // eg Bootstrap tabs and collapses
		    if (typeof containerWidth === 'undefined' || isNaN(containerWidth) || containerWidth === 0) {
		      containerWidth = '100%';
		    }
		    if (typeof gridWidth === 'undefined' || isNaN(gridWidth) || gridWidth === 0) {
		      gridWidth = '100%';
		    }
		    return React.createElement(
		      'div',
		      { className: 'react-grid-Container', style: { width: containerWidth } },
		      toolbar,
		      React.createElement(
		        'div',
		        { className: 'react-grid-Main' },
		        React.createElement(BaseGrid, _extends({
		          ref: function ref(node) {
		            return _this10.base = node;
		          }
		        }, this.props, {
		          rowKey: this.props.rowKey,
		          headerRows: this.getHeaderRows(),
		          columnMetrics: this.state.columnMetrics,
		          rowGetter: this.props.rowGetter,
		          rowsCount: this.props.rowsCount,
		          rowHeight: this.props.rowHeight,
		          cellMetaData: cellMetaData,
		          selectedRows: this.getSelectedRows(),
		          rowSelection: this.getRowSelectionProps(),
		          expandedRows: this.state.expandedRows,
		          rowOffsetHeight: this.getRowOffsetHeight(),
		          sortColumn: this.state.sortColumn,
		          sortDirection: this.state.sortDirection,
		          onSort: this.handleSort,
		          minHeight: this.props.minHeight,
		          totalWidth: gridWidth,
		          onViewportKeydown: this.onKeyDown,
		          onViewportKeyup: this.onKeyUp,
		          onViewportDragStart: this.onDragStart,
		          onViewportDragEnd: this.handleDragEnd,
		          onViewportClick: this.deselect,
		          onViewportDoubleClick: this.deselect,
		          onColumnResize: this.onColumnResize,
		          rowScrollTimeout: this.props.rowScrollTimeout,
		          scrollToRowIndex: this.props.scrollToRowIndex,
		          contextMenu: this.props.contextMenu,
		          overScan: this.props.overScan }))
		      )
		    );
		  }
		});

		module.exports = ReactDataGrid;

	/***/ }),
	/* 196 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

		var React = __webpack_require__(2);
		var createReactClass = __webpack_require__(10);
		var Draggable = __webpack_require__(184);
		__webpack_require__(19);

		var ResizeHandle = createReactClass({
		  displayName: 'ResizeHandle',

		  style: {
		    position: 'absolute',
		    top: 0,
		    right: 0,
		    width: 6,
		    height: '100%'
		  },

		  render: function render() {
		    return React.createElement(Draggable, _extends({}, this.props, {
		      className: 'react-grid-HeaderCell__resizeHandle',
		      style: this.style
		    }));
		  }
		});

		module.exports = ResizeHandle;

	/***/ }),
	/* 197 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		exports.__esModule = true;

		var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

		var _react = __webpack_require__(2);

		var _react2 = _interopRequireDefault(_react);

		var _propTypes = __webpack_require__(3);

		var _propTypes2 = _interopRequireDefault(_propTypes);

		var _utils = __webpack_require__(71);

		var _utils2 = _interopRequireDefault(_utils);

		__webpack_require__(28);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

		var cellMetaDataShape = __webpack_require__(11);

		var RowGroup = function (_Component) {
		  _inherits(RowGroup, _Component);

		  function RowGroup(props) {
		    _classCallCheck(this, RowGroup);

		    var _this = _possibleConstructorReturn(this, _Component.call(this, props));

		    _this.onRowExpandToggle = _this.onRowExpandToggle.bind(_this);
		    _this.onRowExpandClick = _this.onRowExpandClick.bind(_this);
		    _this.setScrollLeft = _this.setScrollLeft.bind(_this);
		    return _this;
		  }

		  RowGroup.prototype.onRowExpandToggle = function onRowExpandToggle(expand) {
		    var shouldExpand = expand == null ? !this.props.isExpanded : expand;
		    var meta = this.props.cellMetaData;
		    if (meta != null && meta.onRowExpandToggle && typeof meta.onRowExpandToggle === 'function') {
		      meta.onRowExpandToggle({ rowIdx: this.props.idx, shouldExpand: shouldExpand, columnGroupName: this.props.columnGroupName, name: this.props.name });
		    }
		  };

		  RowGroup.prototype.onRowExpandClick = function onRowExpandClick() {
		    this.onRowExpandToggle(!this.props.isExpanded);
		  };

		  RowGroup.prototype.setScrollLeft = function setScrollLeft(scrollLeft) {
		    if (this.rowGroupRenderer) {
		      this.rowGroupRenderer.setScrollLeft ? this.rowGroupRenderer.setScrollLeft(scrollLeft) : null;
		    }
		  };

		  RowGroup.prototype.render = function render() {
		    var _this2 = this;

		    var lastColumn = _utils2['default'].last(this.props.columns);

		    var style = { width: lastColumn.left + lastColumn.width };

		    return _react2['default'].createElement(
		      'div',
		      { style: style, className: 'react-grid-row-group' },
		      _react2['default'].createElement(this.props.renderer, _extends({ ref: function ref(node) {
		          _this2.rowGroupRenderer = node;
		        } }, this.props, { onRowExpandClick: this.onRowExpandClick, onRowExpandToggle: this.onRowExpandToggle }))
		    );
		  };

		  return RowGroup;
		}(_react.Component);

		RowGroup.propTypes = {
		  height: _propTypes2['default'].number.isRequired,
		  columns: _propTypes2['default'].oneOfType([_propTypes2['default'].object, _propTypes2['default'].array]).isRequired,
		  row: _propTypes2['default'].any.isRequired,
		  cellRenderer: _propTypes2['default'].func,
		  cellMetaData: _propTypes2['default'].shape(cellMetaDataShape),
		  isSelected: _propTypes2['default'].bool,
		  idx: _propTypes2['default'].number.isRequired,
		  expandedRows: _propTypes2['default'].arrayOf(_propTypes2['default'].object),
		  extraClasses: _propTypes2['default'].string,
		  forceUpdate: _propTypes2['default'].bool,
		  subRowDetails: _propTypes2['default'].object,
		  isRowHovered: _propTypes2['default'].bool,
		  colVisibleStart: _propTypes2['default'].number.isRequired,
		  colVisibleEnd: _propTypes2['default'].number.isRequired,
		  colDisplayStart: _propTypes2['default'].number.isRequired,
		  colDisplayEnd: _propTypes2['default'].number.isRequired,
		  isScrolling: _propTypes2['default'].bool.isRequired,
		  columnGroupName: _propTypes2['default'].string.isRequired,
		  isExpanded: _propTypes2['default'].bool.isRequired,
		  treeDepth: _propTypes2['default'].number.isRequired,
		  name: _propTypes2['default'].string.isRequired,
		  renderer: _propTypes2['default'].func
		};

		var DefaultRowGroupRenderer = function DefaultRowGroupRenderer(props) {
		  var treeDepth = props.treeDepth || 0;
		  var marginLeft = treeDepth * 20;

		  var style = {
		    height: '50px',
		    border: '1px solid #dddddd',
		    paddingTop: '15px',
		    paddingLeft: '5px'
		  };

		  var onKeyDown = function onKeyDown(e) {
		    if (e.key === 'ArrowLeft') {
		      props.onRowExpandToggle(false);
		    }
		    if (e.key === 'ArrowRight') {
		      props.onRowExpandToggle(true);
		    }
		    if (e.key === 'Enter') {
		      props.onRowExpandToggle(!props.isExpanded);
		    }
		  };
		  return _react2['default'].createElement(
		    'div',
		    { style: style, onKeyDown: onKeyDown, tabIndex: 0 },
		    _react2['default'].createElement(
		      'span',
		      { className: 'row-expand-icon', style: { float: 'left', marginLeft: marginLeft, cursor: 'pointer' }, onClick: props.onRowExpandClick },
		      props.isExpanded ? String.fromCharCode('9660') : String.fromCharCode('9658')
		    ),
		    _react2['default'].createElement(
		      'strong',
		      null,
		      props.columnGroupName,
		      ': ',
		      props.name
		    )
		  );
		};

		DefaultRowGroupRenderer.propTypes = {
		  onRowExpandClick: _propTypes2['default'].func.isRequired,
		  onRowExpandToggle: _propTypes2['default'].func.isRequired,
		  isExpanded: _propTypes2['default'].bool.isRequired,
		  treeDepth: _propTypes2['default'].number.isRequired,
		  name: _propTypes2['default'].string.isRequired,
		  columnGroupName: _propTypes2['default'].string.isRequired,
		  hideColumnName: _propTypes2['default'].bool
		};

		RowGroup.defaultProps = {
		  renderer: DefaultRowGroupRenderer
		};

		exports['default'] = RowGroup;

	/***/ }),
	/* 198 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		var _reactDom = __webpack_require__(5);

		var _reactDom2 = _interopRequireDefault(_reactDom);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		var ScrollShim = {
		  appendScrollShim: function appendScrollShim() {
		    if (!this._scrollShim) {
		      var size = this._scrollShimSize();
		      var shim = document.createElement('div');
		      if (shim.classList) {
		        shim.classList.add('react-grid-ScrollShim'); // flow - not compatible with HTMLElement
		      } else {
		        shim.className += ' react-grid-ScrollShim';
		      }
		      shim.style.position = 'absolute';
		      shim.style.top = 0;
		      shim.style.left = 0;
		      shim.style.width = size.width + 'px';
		      shim.style.height = size.height + 'px';
		      _reactDom2['default'].findDOMNode(this).appendChild(shim);
		      this._scrollShim = shim;
		    }
		    this._scheduleRemoveScrollShim();
		  },
		  _scrollShimSize: function _scrollShimSize() {
		    return {
		      width: this.props.width,
		      height: this.props.length * this.props.rowHeight
		    };
		  },
		  _scheduleRemoveScrollShim: function _scheduleRemoveScrollShim() {
		    if (this._scheduleRemoveScrollShimTimer) {
		      clearTimeout(this._scheduleRemoveScrollShimTimer);
		    }
		    this._scheduleRemoveScrollShimTimer = setTimeout(this._removeScrollShim, 200);
		  },
		  _removeScrollShim: function _removeScrollShim() {
		    if (this._scrollShim) {
		      this._scrollShim.parentNode.removeChild(this._scrollShim);
		      this._scrollShim = undefined;
		    }
		  }
		};

		module.exports = ScrollShim;

	/***/ }),
	/* 199 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		var _propTypes = __webpack_require__(3);

		var _propTypes2 = _interopRequireDefault(_propTypes);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		var React = __webpack_require__(2);
		var createReactClass = __webpack_require__(10);
		var Canvas = __webpack_require__(178);
		var ViewportScroll = __webpack_require__(200);
		var cellMetaDataShape = __webpack_require__(11);


		var Viewport = createReactClass({
		  displayName: 'Viewport',
		  mixins: [ViewportScroll],

		  propTypes: {
		    rowOffsetHeight: _propTypes2['default'].number.isRequired,
		    totalWidth: _propTypes2['default'].oneOfType([_propTypes2['default'].number, _propTypes2['default'].string]).isRequired,
		    columnMetrics: _propTypes2['default'].object.isRequired,
		    rowGetter: _propTypes2['default'].oneOfType([_propTypes2['default'].array, _propTypes2['default'].func]).isRequired,
		    selectedRows: _propTypes2['default'].array,
		    rowSelection: _propTypes2['default'].oneOfType([_propTypes2['default'].shape({
		      indexes: _propTypes2['default'].arrayOf(_propTypes2['default'].number).isRequired
		    }), _propTypes2['default'].shape({
		      isSelectedKey: _propTypes2['default'].string.isRequired
		    }), _propTypes2['default'].shape({
		      keys: _propTypes2['default'].shape({
		        values: _propTypes2['default'].array.isRequired,
		        rowKey: _propTypes2['default'].string.isRequired
		      }).isRequired
		    })]),
		    expandedRows: _propTypes2['default'].array,
		    rowRenderer: _propTypes2['default'].oneOfType([_propTypes2['default'].element, _propTypes2['default'].func]),
		    rowsCount: _propTypes2['default'].number.isRequired,
		    rowHeight: _propTypes2['default'].number.isRequired,
		    onRows: _propTypes2['default'].func,
		    onScroll: _propTypes2['default'].func,
		    minHeight: _propTypes2['default'].number,
		    cellMetaData: _propTypes2['default'].shape(cellMetaDataShape),
		    rowKey: _propTypes2['default'].string.isRequired,
		    rowScrollTimeout: _propTypes2['default'].number,
		    scrollToRowIndex: _propTypes2['default'].number,
		    contextMenu: _propTypes2['default'].element,
		    getSubRowDetails: _propTypes2['default'].func,
		    rowGroupRenderer: _propTypes2['default'].func
		  },

		  onScroll: function onScroll(scroll) {
		    this.updateScroll(scroll.scrollTop, scroll.scrollLeft, this.state.height, this.props.rowHeight, this.props.rowsCount);

		    if (this.props.onScroll) {
		      this.props.onScroll({ scrollTop: scroll.scrollTop, scrollLeft: scroll.scrollLeft });
		    }
		  },
		  getScroll: function getScroll() {
		    return this.canvas.getScroll();
		  },
		  setScrollLeft: function setScrollLeft(scrollLeft) {
		    this.canvas.setScrollLeft(scrollLeft);
		  },
		  render: function render() {
		    var _this = this;

		    var style = {
		      padding: 0,
		      bottom: 0,
		      left: 0,
		      right: 0,
		      overflow: 'hidden',
		      position: 'absolute',
		      top: this.props.rowOffsetHeight
		    };
		    return React.createElement(
		      'div',
		      {
		        className: 'react-grid-Viewport',
		        style: style },
		      React.createElement(Canvas, {
		        ref: function ref(node) {
		          return _this.canvas = node;
		        },
		        rowKey: this.props.rowKey,
		        totalWidth: this.props.totalWidth,
		        width: this.props.columnMetrics.width,
		        rowGetter: this.props.rowGetter,
		        rowsCount: this.props.rowsCount,
		        selectedRows: this.props.selectedRows,
		        expandedRows: this.props.expandedRows,
		        columns: this.props.columnMetrics.columns,
		        rowRenderer: this.props.rowRenderer,
		        displayStart: this.state.displayStart,
		        displayEnd: this.state.displayEnd,
		        visibleStart: this.state.visibleStart,
		        visibleEnd: this.state.visibleEnd,
		        colVisibleStart: this.state.colVisibleStart,
		        colVisibleEnd: this.state.colVisibleEnd,
		        colDisplayStart: this.state.colDisplayStart,
		        colDisplayEnd: this.state.colDisplayEnd,
		        cellMetaData: this.props.cellMetaData,
		        height: this.state.height,
		        rowHeight: this.props.rowHeight,
		        onScroll: this.onScroll,
		        onRows: this.props.onRows,
		        rowScrollTimeout: this.props.rowScrollTimeout,
		        scrollToRowIndex: this.props.scrollToRowIndex,
		        contextMenu: this.props.contextMenu,
		        rowSelection: this.props.rowSelection,
		        getSubRowDetails: this.props.getSubRowDetails,
		        rowGroupRenderer: this.props.rowGroupRenderer,
		        isScrolling: this.state.isScrolling || false
		      })
		    );
		  }
		});

		module.exports = Viewport;

	/***/ }),
	/* 200 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		var _ColumnUtils = __webpack_require__(9);

		var _ColumnUtils2 = _interopRequireDefault(_ColumnUtils);

		var _propTypes = __webpack_require__(3);

		var _propTypes2 = _interopRequireDefault(_propTypes);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		var ReactDOM = __webpack_require__(5);
		var DOMMetrics = __webpack_require__(23);
		var min = Math.min;
		var max = Math.max;
		var floor = Math.floor;
		var ceil = Math.ceil;


		module.exports = {
		  mixins: [DOMMetrics.MetricsMixin],

		  DOMMetrics: {
		    viewportHeight: function viewportHeight() {
		      return ReactDOM.findDOMNode(this).offsetHeight;
		    },
		    viewportWidth: function viewportWidth() {
		      return ReactDOM.findDOMNode(this).offsetWidth;
		    }
		  },

		  propTypes: {
		    rowHeight: _propTypes2['default'].number,
		    rowsCount: _propTypes2['default'].number.isRequired
		  },

		  getDefaultProps: function getDefaultProps() {
		    return {
		      rowHeight: 30
		    };
		  },
		  getInitialState: function getInitialState() {
		    return this.getGridState(this.props);
		  },
		  getGridState: function getGridState(props) {
		    var totalNumberColumns = _ColumnUtils2['default'].getSize(props.columnMetrics.columns);
		    var canvasHeight = props.minHeight - props.rowOffsetHeight;
		    var renderedRowsCount = ceil((props.minHeight - props.rowHeight) / props.rowHeight);
		    var totalRowCount = min(renderedRowsCount * 4, props.rowsCount);
		    return {
		      displayStart: 0,
		      displayEnd: totalRowCount,
		      visibleStart: 0,
		      visibleEnd: totalRowCount,
		      height: canvasHeight,
		      scrollTop: 0,
		      scrollLeft: 0,
		      colVisibleStart: 0,
		      colVisibleEnd: totalNumberColumns,
		      colDisplayStart: 0,
		      colDisplayEnd: totalNumberColumns
		    };
		  },
		  getRenderedColumnCount: function getRenderedColumnCount(displayStart, width) {
		    var remainingWidth = width && width > 0 ? width : this.props.columnMetrics.totalWidth;
		    if (remainingWidth === 0) {
		      remainingWidth = ReactDOM.findDOMNode(this).offsetWidth;
		    }
		    var columnIndex = displayStart;
		    var columnCount = 0;
		    while (remainingWidth > 0) {
		      var column = _ColumnUtils2['default'].getColumn(this.props.columnMetrics.columns, columnIndex);

		      if (!column) {
		        break;
		      }

		      columnCount++;
		      columnIndex++;
		      remainingWidth -= column.width;
		    }
		    return columnCount;
		  },
		  getVisibleColStart: function getVisibleColStart(scrollLeft) {
		    var remainingScroll = scrollLeft;
		    var columnIndex = -1;
		    while (remainingScroll >= 0) {
		      columnIndex++;
		      remainingScroll -= _ColumnUtils2['default'].getColumn(this.props.columnMetrics.columns, columnIndex).width;
		    }
		    return columnIndex;
		  },
		  clearScrollTimer: function clearScrollTimer() {
		    if (this.resetScrollStateTimeoutId) {
		      clearTimeout(this.resetScrollStateTimeoutId);
		    }
		  },
		  resetScrollStateAfterDelay: function resetScrollStateAfterDelay() {
		    this.clearScrollTimer();
		    this.resetScrollStateTimeoutId = setTimeout(this.resetScrollStateAfterDelayCallback, 500);
		  },
		  resetScrollStateAfterDelayCallback: function resetScrollStateAfterDelayCallback() {
		    this.resetScrollStateTimeoutId = null;
		    this.setState({
		      isScrolling: false
		    });
		  },
		  updateScroll: function updateScroll(scrollTop, scrollLeft, height, rowHeight, length, width) {
		    var isScrolling = true;
		    this.resetScrollStateAfterDelay();

		    var renderedRowsCount = ceil(height / rowHeight);

		    var visibleStart = max(0, floor(scrollTop / rowHeight));

		    var visibleEnd = min(visibleStart + renderedRowsCount, length);

		    var displayStart = max(0, visibleStart - this.props.overScan.rowsStart);

		    var displayEnd = min(visibleEnd + this.props.overScan.rowsEnd, length);

		    var totalNumberColumns = _ColumnUtils2['default'].getSize(this.props.columnMetrics.columns);
		    var colVisibleStart = totalNumberColumns > 0 ? max(0, this.getVisibleColStart(scrollLeft)) : 0;
		    var renderedColumnCount = this.getRenderedColumnCount(colVisibleStart, width);
		    var colVisibleEnd = renderedColumnCount !== 0 ? colVisibleStart + renderedColumnCount : totalNumberColumns;
		    var colDisplayStart = max(0, colVisibleStart - this.props.overScan.colsStart);
		    var colDisplayEnd = min(colVisibleEnd + this.props.overScan.colsEnd, totalNumberColumns);

		    var nextScrollState = {
		      visibleStart: visibleStart,
		      visibleEnd: visibleEnd,
		      displayStart: displayStart,
		      displayEnd: displayEnd,
		      height: height,
		      scrollTop: scrollTop,
		      scrollLeft: scrollLeft,
		      colVisibleStart: colVisibleStart,
		      colVisibleEnd: colVisibleEnd,
		      colDisplayStart: colDisplayStart,
		      colDisplayEnd: colDisplayEnd,
		      isScrolling: isScrolling
		    };

		    this.setState(nextScrollState);
		  },
		  metricsUpdated: function metricsUpdated() {
		    var height = this.DOMMetrics.viewportHeight();
		    var width = this.DOMMetrics.viewportWidth();
		    if (height) {
		      this.updateScroll(this.state.scrollTop, this.state.scrollLeft, height, this.props.rowHeight, this.props.rowsCount, width);
		    }
		  },
		  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
		    if (this.props.rowHeight !== nextProps.rowHeight || this.props.minHeight !== nextProps.minHeight) {
		      var newState = this.getGridState(nextProps);
		      this.updateScroll(newState.scrollTop, newState.scrollLeft, newState.height, nextProps.rowHeight, nextProps.rowsCount);
		    } else if (_ColumnUtils2['default'].getSize(this.props.columnMetrics.columns) !== _ColumnUtils2['default'].getSize(nextProps.columnMetrics.columns)) {
		      this.setState(this.getGridState(nextProps));
		    } else if (this.props.rowsCount !== nextProps.rowsCount) {
		      this.updateScroll(this.state.scrollTop, this.state.scrollLeft, this.state.height, nextProps.rowHeight, nextProps.rowsCount);
		      // Added to fix the hiding of the bottom scrollbar when showing the filters.
		    } else if (this.props.rowOffsetHeight !== nextProps.rowOffsetHeight) {
		      // The value of height can be positive or negative and will be added to the current height to cater for changes in the header height (due to the filer)
		      var _height = this.props.rowOffsetHeight - nextProps.rowOffsetHeight;

		      this.updateScroll(this.state.scrollTop, this.state.scrollLeft, this.state.height + _height, nextProps.rowHeight, nextProps.rowsCount);
		    }
		  },
		  componentWillUnmount: function componentWillUnmount() {
		    this.clearScrollTimer();
		  }
		};

	/***/ }),
	/* 201 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		var _propTypes = __webpack_require__(3);

		var _propTypes2 = _interopRequireDefault(_propTypes);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

		var React = __webpack_require__(2);
		var ExcelColumn = __webpack_require__(12);

		var FilterableHeaderCell = function (_React$Component) {
		  _inherits(FilterableHeaderCell, _React$Component);

		  function FilterableHeaderCell() {
		    var _temp, _this, _ret;

		    _classCallCheck(this, FilterableHeaderCell);

		    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
		      args[_key] = arguments[_key];
		    }

		    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = { filterTerm: '' }, _this.handleChange = function (e) {
		      var val = e.target.value;
		      _this.setState({ filterTerm: val });
		      _this.props.onChange({ filterTerm: val, column: _this.props.column });
		    }, _this.renderInput = function () {
		      if (_this.props.column.filterable === false) {
		        return React.createElement('span', null);
		      }

		      var inputKey = 'header-filter-' + _this.props.column.key;
		      return React.createElement('input', { key: inputKey, type: 'text', className: 'form-control input-sm', placeholder: 'Search', value: _this.state.filterTerm, onChange: _this.handleChange });
		    }, _temp), _possibleConstructorReturn(_this, _ret);
		  }

		  FilterableHeaderCell.prototype.render = function render() {
		    return React.createElement(
		      'div',
		      null,
		      React.createElement(
		        'div',
		        { className: 'form-group' },
		        this.renderInput()
		      )
		    );
		  };

		  return FilterableHeaderCell;
		}(React.Component);

		FilterableHeaderCell.propTypes = {
		  onChange: _propTypes2['default'].func.isRequired,
		  column: _propTypes2['default'].shape(ExcelColumn)
		};


		module.exports = FilterableHeaderCell;

	/***/ }),
	/* 202 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		var _propTypes = __webpack_require__(3);

		var _propTypes2 = _interopRequireDefault(_propTypes);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

		var React = __webpack_require__(2);

		var joinClasses = __webpack_require__(8);
		var DEFINE_SORT = {
		  ASC: 'ASC',
		  DESC: 'DESC',
		  NONE: 'NONE'
		};

		var SortableHeaderCell = function (_React$Component) {
		  _inherits(SortableHeaderCell, _React$Component);

		  function SortableHeaderCell() {
		    var _temp, _this, _ret;

		    _classCallCheck(this, SortableHeaderCell);

		    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
		      args[_key] = arguments[_key];
		    }

		    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.onClick = function () {
		      var direction = void 0;
		      switch (_this.props.sortDirection) {
		        default:
		        case null:
		        case undefined:
		        case DEFINE_SORT.NONE:
		          direction = DEFINE_SORT.ASC;
		          break;
		        case DEFINE_SORT.ASC:
		          direction = DEFINE_SORT.DESC;
		          break;
		        case DEFINE_SORT.DESC:
		          direction = DEFINE_SORT.NONE;
		          break;
		      }
		      _this.props.onSort(_this.props.columnKey, direction);
		    }, _this.getSortByText = function () {
		      var unicodeKeys = {
		        ASC: '9650',
		        DESC: '9660'
		      };
		      return _this.props.sortDirection === 'NONE' ? '' : String.fromCharCode(unicodeKeys[_this.props.sortDirection]);
		    }, _temp), _possibleConstructorReturn(_this, _ret);
		  }

		  SortableHeaderCell.prototype.render = function render() {
		    var className = joinClasses({
		      'react-grid-HeaderCell-sortable': true,
		      'react-grid-HeaderCell-sortable--ascending': this.props.sortDirection === 'ASC',
		      'react-grid-HeaderCell-sortable--descending': this.props.sortDirection === 'DESC'
		    });

		    return React.createElement(
		      'div',
		      { className: className,
		        onClick: this.onClick,
		        style: { cursor: 'pointer' } },
		      React.createElement(
		        'span',
		        { className: 'pull-right' },
		        this.getSortByText()
		      ),
		      this.props.column.name
		    );
		  };

		  return SortableHeaderCell;
		}(React.Component);

		SortableHeaderCell.propTypes = {
		  columnKey: _propTypes2['default'].string.isRequired,
		  column: _propTypes2['default'].shape({ name: _propTypes2['default'].node }),
		  onSort: _propTypes2['default'].func.isRequired,
		  sortDirection: _propTypes2['default'].oneOf(Object.keys(DEFINE_SORT))
		};


		module.exports = SortableHeaderCell;
		module.exports.DEFINE_SORT = DEFINE_SORT;

	/***/ }),
	/* 203 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

		var _propTypes = __webpack_require__(3);

		var _propTypes2 = _interopRequireDefault(_propTypes);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		var React = __webpack_require__(2);

		var createReactClass = __webpack_require__(10);
		var joinClasses = __webpack_require__(8);
		var keyboardHandlerMixin = __webpack_require__(63);
		var SimpleTextEditor = __webpack_require__(69);
		var isFunction = __webpack_require__(24);
		__webpack_require__(26);

		var EditorContainer = createReactClass({
		  displayName: 'EditorContainer',
		  mixins: [keyboardHandlerMixin],

		  propTypes: {
		    rowIdx: _propTypes2['default'].number,
		    rowData: _propTypes2['default'].object.isRequired,
		    value: _propTypes2['default'].oneOfType([_propTypes2['default'].string, _propTypes2['default'].number, _propTypes2['default'].object, _propTypes2['default'].bool]).isRequired,
		    cellMetaData: _propTypes2['default'].shape({
		      selected: _propTypes2['default'].object.isRequired,
		      copied: _propTypes2['default'].object,
		      dragged: _propTypes2['default'].object,
		      onCellClick: _propTypes2['default'].func,
		      onCellDoubleClick: _propTypes2['default'].func,
		      onCommitCancel: _propTypes2['default'].func,
		      onCommit: _propTypes2['default'].func
		    }).isRequired,
		    column: _propTypes2['default'].object.isRequired,
		    height: _propTypes2['default'].number.isRequired
		  },

		  changeCommitted: false,
		  changeCanceled: false,

		  getInitialState: function getInitialState() {
		    return { isInvalid: false };
		  },


		  componentDidMount: function componentDidMount() {
		    var inputNode = this.getInputNode();
		    if (inputNode !== undefined) {
		      this.setTextInputFocus();
		      if (!this.getEditor().disableContainerStyles) {
		        inputNode.className += ' editor-main';
		        inputNode.style.height = this.props.height - 1 + 'px';
		      }
		    }
		  },

		  componentWillUnmount: function componentWillUnmount() {
		    if (!this.changeCommitted && !this.changeCanceled) {
		      this.commit({ key: 'Enter' });
		    }
		  },

		  createEditor: function createEditor() {
		    var _this = this;

		    var editorRef = function editorRef(c) {
		      return _this.editor = c;
		    };
		    var editorProps = {
		      ref: editorRef,
		      column: this.props.column,
		      value: this.getInitialValue(),
		      onCommit: this.commit,
		      onCommitCancel: this.commitCancel,
		      rowMetaData: this.getRowMetaData(),
		      rowData: this.props.rowData,
		      height: this.props.height,
		      onBlur: this.commit,
		      onOverrideKeyDown: this.onKeyDown
		    };

		    var CustomEditor = this.props.column.editor;
		    // return custom column editor or SimpleEditor if none specified
		    if (React.isValidElement(CustomEditor)) {
		      return React.cloneElement(CustomEditor, editorProps);
		    }
		    if (isFunction(CustomEditor)) {
		      return React.createElement(CustomEditor, _extends({ ref: editorRef }, editorProps));
		    }

		    return React.createElement(SimpleTextEditor, { ref: editorRef, column: this.props.column, value: this.getInitialValue(), onBlur: this.commit, rowMetaData: this.getRowMetaData(), onKeyDown: function onKeyDown() {}, commit: function commit() {} });
		  },
		  onPressEnter: function onPressEnter() {
		    this.commit({ key: 'Enter' });
		  },
		  onPressTab: function onPressTab() {
		    this.commit({ key: 'Tab' });
		  },
		  onPressEscape: function onPressEscape(e) {
		    if (!this.editorIsSelectOpen()) {
		      this.commitCancel();
		    } else {
		      // prevent event from bubbling if editor has results to select
		      e.stopPropagation();
		    }
		  },
		  onPressArrowDown: function onPressArrowDown(e) {
		    if (this.editorHasResults()) {
		      // dont want to propogate as that then moves us round the grid
		      e.stopPropagation();
		    } else {
		      this.commit(e);
		    }
		  },
		  onPressArrowUp: function onPressArrowUp(e) {
		    if (this.editorHasResults()) {
		      // dont want to propogate as that then moves us round the grid
		      e.stopPropagation();
		    } else {
		      this.commit(e);
		    }
		  },
		  onPressArrowLeft: function onPressArrowLeft(e) {
		    // prevent event propogation. this disables left cell navigation
		    if (!this.isCaretAtBeginningOfInput()) {
		      e.stopPropagation();
		    } else {
		      this.commit(e);
		    }
		  },
		  onPressArrowRight: function onPressArrowRight(e) {
		    // prevent event propogation. this disables right cell navigation
		    if (!this.isCaretAtEndOfInput()) {
		      e.stopPropagation();
		    } else {
		      this.commit(e);
		    }
		  },
		  editorHasResults: function editorHasResults() {
		    if (isFunction(this.getEditor().hasResults)) {
		      return this.getEditor().hasResults();
		    }

		    return false;
		  },
		  editorIsSelectOpen: function editorIsSelectOpen() {
		    if (isFunction(this.getEditor().isSelectOpen)) {
		      return this.getEditor().isSelectOpen();
		    }

		    return false;
		  },
		  getRowMetaData: function getRowMetaData() {
		    // clone row data so editor cannot actually change this
		    // convention based method to get corresponding Id or Name of any Name or Id property
		    if (typeof this.props.column.getRowMetaData === 'function') {
		      return this.props.column.getRowMetaData(this.props.rowData, this.props.column);
		    }
		  },
		  getEditor: function getEditor() {
		    return this.editor;
		  },
		  getInputNode: function getInputNode() {
		    return this.getEditor().getInputNode();
		  },
		  getInitialValue: function getInitialValue() {
		    var selected = this.props.cellMetaData.selected;
		    var keyCode = selected.initialKeyCode;
		    if (keyCode === 'Delete' || keyCode === 'Backspace') {
		      return '';
		    } else if (keyCode === 'Enter') {
		      return this.props.value;
		    }

		    var text = keyCode ? String.fromCharCode(keyCode) : this.props.value;
		    return text;
		  },
		  getContainerClass: function getContainerClass() {
		    return joinClasses({
		      'has-error': this.state.isInvalid === true
		    });
		  },
		  commit: function commit(args) {
		    var opts = args || {};
		    var updated = this.getEditor().getValue();
		    if (this.isNewValueValid(updated)) {
		      this.changeCommitted = true;
		      var cellKey = this.props.column.key;
		      this.props.cellMetaData.onCommit({ cellKey: cellKey, rowIdx: this.props.rowIdx, updated: updated, key: opts.key });
		    }
		  },
		  commitCancel: function commitCancel() {
		    this.changeCanceled = true;
		    this.props.cellMetaData.onCommitCancel();
		  },
		  isNewValueValid: function isNewValueValid(value) {
		    if (isFunction(this.getEditor().validate)) {
		      var isValid = this.getEditor().validate(value);
		      this.setState({ isInvalid: !isValid });
		      return isValid;
		    }

		    return true;
		  },
		  setCaretAtEndOfInput: function setCaretAtEndOfInput() {
		    var input = this.getInputNode();
		    // taken from http://stackoverflow.com/questions/511088/use-javascript-to-place-cursor-at-end-of-text-in-text-input-element
		    var txtLength = input.value.length;
		    if (input.setSelectionRange) {
		      input.setSelectionRange(txtLength, txtLength);
		    } else if (input.createTextRange) {
		      var fieldRange = input.createTextRange();
		      fieldRange.moveStart('character', txtLength);
		      fieldRange.collapse();
		      fieldRange.select();
		    }
		  },
		  isCaretAtBeginningOfInput: function isCaretAtBeginningOfInput() {
		    var inputNode = this.getInputNode();
		    return inputNode.selectionStart === inputNode.selectionEnd && inputNode.selectionStart === 0;
		  },
		  isCaretAtEndOfInput: function isCaretAtEndOfInput() {
		    var inputNode = this.getInputNode();
		    return inputNode.selectionStart === inputNode.value.length;
		  },
		  isBodyClicked: function isBodyClicked(e) {
		    var relatedTarget = this.getRelatedTarget(e);
		    return relatedTarget === null;
		  },
		  isViewportClicked: function isViewportClicked(e) {
		    var relatedTarget = this.getRelatedTarget(e);
		    return relatedTarget.className.indexOf('react-grid-Viewport') > -1;
		  },
		  isClickInsideEditor: function isClickInsideEditor(e) {
		    var relatedTarget = this.getRelatedTarget(e);
		    return e.currentTarget.contains(relatedTarget) || relatedTarget.className.indexOf('editing') > -1 || relatedTarget.className.indexOf('react-grid-Cell') > -1;
		  },
		  getRelatedTarget: function getRelatedTarget(e) {
		    return e.relatedTarget || e.explicitOriginalTarget || document.activeElement; // IE11
		  },
		  handleRightClick: function handleRightClick(e) {
		    e.stopPropagation();
		  },
		  handleBlur: function handleBlur(e) {
		    e.stopPropagation();
		    if (this.isBodyClicked(e)) {
		      this.commit(e);
		    }

		    if (!this.isBodyClicked(e)) {
		      // prevent null reference
		      if (this.isViewportClicked(e) || !this.isClickInsideEditor(e)) {
		        this.commit(e);
		      }
		    }
		  },
		  setTextInputFocus: function setTextInputFocus() {
		    var selected = this.props.cellMetaData.selected;
		    var keyCode = selected.initialKeyCode;
		    var inputNode = this.getInputNode();
		    inputNode.focus();
		    if (inputNode.tagName === 'INPUT') {
		      if (!this.isKeyPrintable(keyCode)) {
		        inputNode.focus();
		        inputNode.select();
		      } else {
		        inputNode.select();
		      }
		    }
		  },
		  renderStatusIcon: function renderStatusIcon() {
		    if (this.state.isInvalid === true) {
		      return React.createElement('span', { className: 'glyphicon glyphicon-remove form-control-feedback' });
		    }
		  },
		  render: function render() {
		    return React.createElement(
		      'div',
		      { className: this.getContainerClass(), onBlur: this.handleBlur, onKeyDown: this.onKeyDown, onContextMenu: this.handleRightClick },
		      this.createEditor(),
		      this.renderStatusIcon()
		    );
		  }
		});

		module.exports = EditorContainer;

	/***/ }),
	/* 204 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		module.exports = {
		  CheckboxEditor: __webpack_require__(67),
		  EditorBase: __webpack_require__(68),
		  SimpleTextEditor: __webpack_require__(69)
		};

	/***/ }),
	/* 205 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		exports.__esModule = true;

		var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

		var _react = __webpack_require__(2);

		var _react2 = _interopRequireDefault(_react);

		var _reactDom = __webpack_require__(5);

		var _reactDom2 = _interopRequireDefault(_reactDom);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint-disable react/prop-types */


		var focusableComponentWrapper = function focusableComponentWrapper(WrappedComponent) {
		  return function (_Component) {
		    _inherits(ComponentWrapper, _Component);

		    function ComponentWrapper() {
		      _classCallCheck(this, ComponentWrapper);

		      var _this = _possibleConstructorReturn(this, _Component.call(this));

		      _this.checkFocus = _this.checkFocus.bind(_this);
		      _this.state = { isScrolling: false };
		      return _this;
		    }

		    ComponentWrapper.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
		      return WrappedComponent.isSelected(this.props) !== WrappedComponent.isSelected(nextProps);
		    };

		    ComponentWrapper.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
		      var isScrolling = WrappedComponent.isScrolling(nextProps);
		      if (isScrolling && !this.state.isScrolling) {
		        this.setState({ isScrolling: isScrolling });
		      }
		    };

		    ComponentWrapper.prototype.componentDidMount = function componentDidMount() {
		      this.checkFocus();
		    };

		    ComponentWrapper.prototype.componentDidUpdate = function componentDidUpdate() {
		      this.checkFocus();
		    };

		    ComponentWrapper.prototype.checkFocus = function checkFocus() {
		      if (WrappedComponent.isSelected(this.props) && this.state.isScrolling) {
		        this.focus();
		        this.setState({ isScrolling: false });
		      }
		    };

		    ComponentWrapper.prototype.focus = function focus() {
		      _reactDom2['default'].findDOMNode(this).focus();
		    };

		    ComponentWrapper.prototype.render = function render() {
		      return _react2['default'].createElement(WrappedComponent, _extends({}, this.props, this.state));
		    };

		    return ComponentWrapper;
		  }(_react.Component);
		};

		exports['default'] = focusableComponentWrapper;

	/***/ }),
	/* 206 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		module.exports = {
		  SimpleCellFormatter: __webpack_require__(70)
		};

	/***/ }),
	/* 207 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		var _GridPropHelpers = __webpack_require__(208);

		var _GridPropHelpers2 = _interopRequireDefault(_GridPropHelpers);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		module.exports = {
		  test: { GridPropHelpers: _GridPropHelpers2['default'] }
		};

	/***/ }),
	/* 208 */
	/***/ (function(module, exports) {

		'use strict';

		var _rows = [];
		for (var i = 0; i < 1000; i++) {
		  _rows.push({
		    id: i,
		    title: 'Title ' + i,
		    count: i * 1000
		  });
		}
		module.exports = {
		  columns: [{
		    key: 'id',
		    name: 'ID',
		    width: 100
		  }, {
		    key: 'title',
		    name: 'Title',
		    width: 100
		  }, {
		    key: 'count',
		    name: 'Count',
		    width: 100
		  }],
		  rowGetter: function rowGetter(i) {
		    return _rows[i];
		  },
		  rowsCount: function rowsCount() {
		    return _rows.length;
		  },
		  cellMetaData: {
		    selected: { idx: 2, rowIdx: 3 },
		    dragged: null,
		    copied: null
		  }
		};

	/***/ }),
	/* 209 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		var _RowComparer = __webpack_require__(64);

		var _RowComparer2 = _interopRequireDefault(_RowComparer);

		var _RowsContainer = __webpack_require__(66);

		var _RowsContainer2 = _interopRequireDefault(_RowsContainer);

		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

		var Grid = __webpack_require__(195);

		module.exports = Grid;
		module.exports.Row = __webpack_require__(36);
		module.exports.Cell = __webpack_require__(61);
		module.exports.HeaderCell = __webpack_require__(62);
		module.exports.RowComparer = _RowComparer2['default'];
		module.exports.EmptyChildRow = __webpack_require__(185);
		module.exports.RowsContainer = _RowsContainer2['default'];
		module.exports.editors = __webpack_require__(204);
		module.exports.formatters = __webpack_require__(206);
		module.exports.utils = __webpack_require__(71);
		module.exports.shapes = __webpack_require__(194);
		module.exports._constants = __webpack_require__(34);
		module.exports._helpers = __webpack_require__(207);

	/***/ }),
	/* 210 */
	/***/ (function(module, exports) {

		"use strict";

		var isEmptyArray = function isEmptyArray(obj) {
		  return Array.isArray(obj) && obj.length === 0;
		};

		module.exports = isEmptyArray;

	/***/ }),
	/* 211 */
	/***/ (function(module, exports) {

		"use strict";

		function isEmpty(obj) {
		  return Object.keys(obj).length === 0 && obj.constructor === Object;
		}

		module.exports = isEmpty;

	/***/ }),
	/* 212 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		var _immutable = __webpack_require__(20);

		var isImmutableCollection = function isImmutableCollection(objToVerify) {
		  return _immutable.Iterable.isIterable(objToVerify);
		};

		module.exports = isImmutableCollection;

	/***/ }),
	/* 213 */
	/***/ (function(module, exports, __webpack_require__) {

		'use strict';

		var _immutable = __webpack_require__(20);

		module.exports = _immutable.Map.isMap;

	/***/ }),
	/* 214 */
	/***/ (function(module, exports) {

		"use strict";

		var getMixedTypeValueRetriever = function getMixedTypeValueRetriever(isImmutable) {
		  var retObj = {};
		  var retriever = function retriever(item, key) {
		    return item[key];
		  };
		  var immutableRetriever = function immutableRetriever(immutable, key) {
		    return immutable.get(key);
		  };

		  retObj.getValue = isImmutable ? immutableRetriever : retriever;

		  return retObj;
		};

		module.exports = getMixedTypeValueRetriever;

	/***/ }),
	/* 215 */
	/***/ (function(module, exports, __webpack_require__) {

		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule invariant
		 */

		'use strict';

		/**
		 * Use invariant() to assert state which your program assumes to be true.
		 *
		 * Provide sprintf-style format (only %s is supported) and arguments
		 * to provide information about what broke and what you were
		 * expecting.
		 *
		 * The invariant message will be stripped in production, but the invariant
		 * will remain to ensure logic does not differ in production.
		 */

		function invariant(condition, format, a, b, c, d, e, f) {
		  if (false) {
		    if (format === undefined) {
		      throw new Error('invariant requires an error message argument');
		    }
		  }

		  if (!condition) {
		    var error;
		    if (format === undefined) {
		      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
		    } else {
		      var args = [a, b, c, d, e, f];
		      var argIndex = 0;
		      error = new Error(format.replace(/%s/g, function () {
		        return args[argIndex++];
		      }));
		      error.name = 'Invariant Violation';
		    }

		    error.framesToPop = 1; // we don't care about invariant's own frame
		    throw error;
		  }
		}

		module.exports = invariant;

	/***/ }),
	/* 216 */
	/***/ (function(module, exports, __webpack_require__) {

		/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 *
		 * @providesModule keyMirror
		 * @typechecks static-only
		 */

		'use strict';

		var invariant = __webpack_require__(215);

		/**
		 * Constructs an enumeration with keys equal to their value.
		 *
		 * For example:
		 *
		 *   var COLORS = keyMirror({blue: null, red: null});
		 *   var myColor = COLORS.blue;
		 *   var isColorValid = !!COLORS[myColor];
		 *
		 * The last line could not be performed if the values of the generated enum were
		 * not equal to their keys.
		 *
		 *   Input:  {key1: val1, key2: val2}
		 *   Output: {key1: key1, key2: key2}
		 *
		 * @param {object} obj
		 * @return {object}
		 */
		var keyMirror = function (obj) {
		  var ret = {};
		  var key;
		  !(obj instanceof Object && !Array.isArray(obj)) ?  false ? invariant(false, 'keyMirror(...): Argument must be an object.') : invariant(false) : undefined;
		  for (key in obj) {
		    if (!obj.hasOwnProperty(key)) {
		      continue;
		    }
		    ret[key] = key;
		  }
		  return ret;
		};

		module.exports = keyMirror;

	/***/ })
	/******/ ])))
	});
	;

/***/ }),
/* 466 */,
/* 467 */,
/* 468 */,
/* 469 */,
/* 470 */,
/* 471 */,
/* 472 */,
/* 473 */,
/* 474 */,
/* 475 */,
/* 476 */,
/* 477 */,
/* 478 */,
/* 479 */,
/* 480 */,
/* 481 */,
/* 482 */,
/* 483 */,
/* 484 */,
/* 485 */,
/* 486 */,
/* 487 */,
/* 488 */,
/* 489 */,
/* 490 */,
/* 491 */,
/* 492 */,
/* 493 */,
/* 494 */,
/* 495 */,
/* 496 */,
/* 497 */,
/* 498 */,
/* 499 */,
/* 500 */,
/* 501 */,
/* 502 */,
/* 503 */,
/* 504 */,
/* 505 */,
/* 506 */,
/* 507 */,
/* 508 */,
/* 509 */,
/* 510 */,
/* 511 */,
/* 512 */,
/* 513 */,
/* 514 */,
/* 515 */,
/* 516 */,
/* 517 */,
/* 518 */,
/* 519 */,
/* 520 */,
/* 521 */,
/* 522 */,
/* 523 */,
/* 524 */,
/* 525 */,
/* 526 */,
/* 527 */,
/* 528 */,
/* 529 */,
/* 530 */,
/* 531 */,
/* 532 */,
/* 533 */,
/* 534 */,
/* 535 */,
/* 536 */,
/* 537 */,
/* 538 */,
/* 539 */,
/* 540 */,
/* 541 */,
/* 542 */,
/* 543 */,
/* 544 */,
/* 545 */,
/* 546 */,
/* 547 */,
/* 548 */,
/* 549 */,
/* 550 */,
/* 551 */,
/* 552 */,
/* 553 */,
/* 554 */,
/* 555 */,
/* 556 */,
/* 557 */,
/* 558 */,
/* 559 */,
/* 560 */,
/* 561 */,
/* 562 */,
/* 563 */,
/* 564 */,
/* 565 */,
/* 566 */,
/* 567 */,
/* 568 */,
/* 569 */,
/* 570 */,
/* 571 */,
/* 572 */,
/* 573 */,
/* 574 */,
/* 575 */,
/* 576 */,
/* 577 */,
/* 578 */,
/* 579 */,
/* 580 */,
/* 581 */,
/* 582 */,
/* 583 */,
/* 584 */,
/* 585 */,
/* 586 */,
/* 587 */,
/* 588 */,
/* 589 */,
/* 590 */,
/* 591 */,
/* 592 */,
/* 593 */,
/* 594 */,
/* 595 */,
/* 596 */,
/* 597 */,
/* 598 */,
/* 599 */,
/* 600 */,
/* 601 */,
/* 602 */,
/* 603 */,
/* 604 */,
/* 605 */,
/* 606 */,
/* 607 */,
/* 608 */,
/* 609 */,
/* 610 */,
/* 611 */,
/* 612 */,
/* 613 */,
/* 614 */,
/* 615 */,
/* 616 */,
/* 617 */,
/* 618 */,
/* 619 */,
/* 620 */,
/* 621 */,
/* 622 */,
/* 623 */,
/* 624 */,
/* 625 */,
/* 626 */,
/* 627 */,
/* 628 */,
/* 629 */,
/* 630 */,
/* 631 */,
/* 632 */,
/* 633 */,
/* 634 */,
/* 635 */,
/* 636 */,
/* 637 */,
/* 638 */,
/* 639 */,
/* 640 */,
/* 641 */,
/* 642 */,
/* 643 */,
/* 644 */,
/* 645 */,
/* 646 */,
/* 647 */,
/* 648 */,
/* 649 */,
/* 650 */,
/* 651 */,
/* 652 */,
/* 653 */,
/* 654 */,
/* 655 */,
/* 656 */,
/* 657 */,
/* 658 */,
/* 659 */,
/* 660 */,
/* 661 */,
/* 662 */,
/* 663 */,
/* 664 */,
/* 665 */,
/* 666 */,
/* 667 */,
/* 668 */,
/* 669 */,
/* 670 */,
/* 671 */,
/* 672 */,
/* 673 */,
/* 674 */,
/* 675 */,
/* 676 */,
/* 677 */,
/* 678 */,
/* 679 */,
/* 680 */,
/* 681 */,
/* 682 */,
/* 683 */,
/* 684 */,
/* 685 */,
/* 686 */,
/* 687 */,
/* 688 */,
/* 689 */,
/* 690 */,
/* 691 */,
/* 692 */,
/* 693 */,
/* 694 */,
/* 695 */,
/* 696 */,
/* 697 */,
/* 698 */,
/* 699 */,
/* 700 */,
/* 701 */,
/* 702 */,
/* 703 */,
/* 704 */,
/* 705 */,
/* 706 */,
/* 707 */,
/* 708 */,
/* 709 */,
/* 710 */,
/* 711 */,
/* 712 */,
/* 713 */,
/* 714 */,
/* 715 */,
/* 716 */,
/* 717 */,
/* 718 */,
/* 719 */,
/* 720 */,
/* 721 */,
/* 722 */,
/* 723 */,
/* 724 */,
/* 725 */,
/* 726 */,
/* 727 */,
/* 728 */,
/* 729 */,
/* 730 */,
/* 731 */,
/* 732 */,
/* 733 */,
/* 734 */,
/* 735 */,
/* 736 */,
/* 737 */,
/* 738 */,
/* 739 */,
/* 740 */,
/* 741 */,
/* 742 */,
/* 743 */,
/* 744 */,
/* 745 */,
/* 746 */,
/* 747 */,
/* 748 */,
/* 749 */,
/* 750 */,
/* 751 */,
/* 752 */,
/* 753 */,
/* 754 */,
/* 755 */,
/* 756 */,
/* 757 */,
/* 758 */,
/* 759 */,
/* 760 */,
/* 761 */,
/* 762 */,
/* 763 */,
/* 764 */,
/* 765 */,
/* 766 */,
/* 767 */,
/* 768 */,
/* 769 */,
/* 770 */,
/* 771 */,
/* 772 */,
/* 773 */,
/* 774 */,
/* 775 */,
/* 776 */,
/* 777 */,
/* 778 */,
/* 779 */,
/* 780 */,
/* 781 */,
/* 782 */,
/* 783 */,
/* 784 */,
/* 785 */,
/* 786 */,
/* 787 */,
/* 788 */,
/* 789 */,
/* 790 */,
/* 791 */,
/* 792 */,
/* 793 */,
/* 794 */,
/* 795 */,
/* 796 */,
/* 797 */,
/* 798 */,
/* 799 */,
/* 800 */,
/* 801 */,
/* 802 */,
/* 803 */,
/* 804 */,
/* 805 */,
/* 806 */,
/* 807 */,
/* 808 */,
/* 809 */,
/* 810 */,
/* 811 */,
/* 812 */,
/* 813 */,
/* 814 */,
/* 815 */,
/* 816 */,
/* 817 */,
/* 818 */,
/* 819 */,
/* 820 */,
/* 821 */,
/* 822 */,
/* 823 */,
/* 824 */,
/* 825 */,
/* 826 */,
/* 827 */,
/* 828 */,
/* 829 */,
/* 830 */,
/* 831 */,
/* 832 */,
/* 833 */,
/* 834 */,
/* 835 */,
/* 836 */,
/* 837 */,
/* 838 */,
/* 839 */,
/* 840 */,
/* 841 */,
/* 842 */,
/* 843 */,
/* 844 */,
/* 845 */,
/* 846 */,
/* 847 */,
/* 848 */,
/* 849 */,
/* 850 */,
/* 851 */,
/* 852 */,
/* 853 */,
/* 854 */,
/* 855 */,
/* 856 */,
/* 857 */,
/* 858 */,
/* 859 */,
/* 860 */,
/* 861 */,
/* 862 */,
/* 863 */,
/* 864 */,
/* 865 */,
/* 866 */,
/* 867 */,
/* 868 */,
/* 869 */,
/* 870 */,
/* 871 */,
/* 872 */,
/* 873 */,
/* 874 */,
/* 875 */,
/* 876 */,
/* 877 */,
/* 878 */,
/* 879 */,
/* 880 */,
/* 881 */,
/* 882 */,
/* 883 */,
/* 884 */,
/* 885 */,
/* 886 */,
/* 887 */,
/* 888 */,
/* 889 */,
/* 890 */,
/* 891 */,
/* 892 */,
/* 893 */,
/* 894 */,
/* 895 */,
/* 896 */,
/* 897 */,
/* 898 */,
/* 899 */,
/* 900 */,
/* 901 */,
/* 902 */,
/* 903 */,
/* 904 */,
/* 905 */,
/* 906 */,
/* 907 */,
/* 908 */,
/* 909 */,
/* 910 */,
/* 911 */,
/* 912 */,
/* 913 */,
/* 914 */,
/* 915 */,
/* 916 */,
/* 917 */,
/* 918 */,
/* 919 */,
/* 920 */,
/* 921 */,
/* 922 */,
/* 923 */,
/* 924 */,
/* 925 */,
/* 926 */,
/* 927 */,
/* 928 */,
/* 929 */,
/* 930 */,
/* 931 */,
/* 932 */,
/* 933 */,
/* 934 */,
/* 935 */,
/* 936 */,
/* 937 */,
/* 938 */,
/* 939 */,
/* 940 */,
/* 941 */,
/* 942 */,
/* 943 */,
/* 944 */,
/* 945 */,
/* 946 */,
/* 947 */,
/* 948 */,
/* 949 */,
/* 950 */,
/* 951 */,
/* 952 */,
/* 953 */,
/* 954 */,
/* 955 */,
/* 956 */,
/* 957 */,
/* 958 */,
/* 959 */,
/* 960 */,
/* 961 */,
/* 962 */,
/* 963 */,
/* 964 */,
/* 965 */,
/* 966 */,
/* 967 */,
/* 968 */,
/* 969 */,
/* 970 */,
/* 971 */,
/* 972 */,
/* 973 */,
/* 974 */,
/* 975 */,
/* 976 */,
/* 977 */,
/* 978 */,
/* 979 */,
/* 980 */,
/* 981 */,
/* 982 */,
/* 983 */,
/* 984 */,
/* 985 */,
/* 986 */,
/* 987 */,
/* 988 */,
/* 989 */,
/* 990 */,
/* 991 */,
/* 992 */,
/* 993 */,
/* 994 */,
/* 995 */,
/* 996 */,
/* 997 */,
/* 998 */,
/* 999 */,
/* 1000 */,
/* 1001 */,
/* 1002 */,
/* 1003 */,
/* 1004 */,
/* 1005 */,
/* 1006 */,
/* 1007 */,
/* 1008 */,
/* 1009 */,
/* 1010 */,
/* 1011 */,
/* 1012 */,
/* 1013 */,
/* 1014 */,
/* 1015 */,
/* 1016 */,
/* 1017 */,
/* 1018 */,
/* 1019 */,
/* 1020 */,
/* 1021 */,
/* 1022 */,
/* 1023 */,
/* 1024 */,
/* 1025 */,
/* 1026 */,
/* 1027 */,
/* 1028 */,
/* 1029 */,
/* 1030 */,
/* 1031 */,
/* 1032 */,
/* 1033 */,
/* 1034 */,
/* 1035 */,
/* 1036 */,
/* 1037 */,
/* 1038 */,
/* 1039 */,
/* 1040 */,
/* 1041 */,
/* 1042 */,
/* 1043 */,
/* 1044 */,
/* 1045 */,
/* 1046 */,
/* 1047 */,
/* 1048 */,
/* 1049 */,
/* 1050 */,
/* 1051 */,
/* 1052 */,
/* 1053 */,
/* 1054 */,
/* 1055 */,
/* 1056 */,
/* 1057 */,
/* 1058 */,
/* 1059 */,
/* 1060 */,
/* 1061 */,
/* 1062 */,
/* 1063 */,
/* 1064 */,
/* 1065 */,
/* 1066 */,
/* 1067 */,
/* 1068 */,
/* 1069 */,
/* 1070 */,
/* 1071 */,
/* 1072 */,
/* 1073 */,
/* 1074 */,
/* 1075 */,
/* 1076 */,
/* 1077 */,
/* 1078 */,
/* 1079 */,
/* 1080 */,
/* 1081 */,
/* 1082 */,
/* 1083 */,
/* 1084 */,
/* 1085 */,
/* 1086 */,
/* 1087 */,
/* 1088 */,
/* 1089 */,
/* 1090 */,
/* 1091 */,
/* 1092 */,
/* 1093 */,
/* 1094 */,
/* 1095 */,
/* 1096 */,
/* 1097 */,
/* 1098 */,
/* 1099 */,
/* 1100 */,
/* 1101 */,
/* 1102 */,
/* 1103 */,
/* 1104 */,
/* 1105 */,
/* 1106 */,
/* 1107 */,
/* 1108 */,
/* 1109 */,
/* 1110 */,
/* 1111 */,
/* 1112 */,
/* 1113 */,
/* 1114 */,
/* 1115 */,
/* 1116 */,
/* 1117 */,
/* 1118 */,
/* 1119 */,
/* 1120 */,
/* 1121 */,
/* 1122 */,
/* 1123 */,
/* 1124 */,
/* 1125 */,
/* 1126 */,
/* 1127 */,
/* 1128 */,
/* 1129 */,
/* 1130 */,
/* 1131 */,
/* 1132 */,
/* 1133 */,
/* 1134 */,
/* 1135 */,
/* 1136 */,
/* 1137 */,
/* 1138 */,
/* 1139 */,
/* 1140 */,
/* 1141 */,
/* 1142 */,
/* 1143 */,
/* 1144 */,
/* 1145 */,
/* 1146 */,
/* 1147 */,
/* 1148 */,
/* 1149 */,
/* 1150 */,
/* 1151 */,
/* 1152 */,
/* 1153 */,
/* 1154 */,
/* 1155 */,
/* 1156 */,
/* 1157 */,
/* 1158 */,
/* 1159 */,
/* 1160 */,
/* 1161 */,
/* 1162 */,
/* 1163 */,
/* 1164 */,
/* 1165 */,
/* 1166 */,
/* 1167 */,
/* 1168 */,
/* 1169 */,
/* 1170 */,
/* 1171 */,
/* 1172 */,
/* 1173 */,
/* 1174 */,
/* 1175 */,
/* 1176 */,
/* 1177 */,
/* 1178 */,
/* 1179 */,
/* 1180 */,
/* 1181 */,
/* 1182 */,
/* 1183 */,
/* 1184 */,
/* 1185 */,
/* 1186 */,
/* 1187 */,
/* 1188 */,
/* 1189 */,
/* 1190 */,
/* 1191 */,
/* 1192 */,
/* 1193 */,
/* 1194 */,
/* 1195 */,
/* 1196 */,
/* 1197 */,
/* 1198 */,
/* 1199 */,
/* 1200 */,
/* 1201 */,
/* 1202 */,
/* 1203 */,
/* 1204 */,
/* 1205 */,
/* 1206 */,
/* 1207 */,
/* 1208 */,
/* 1209 */,
/* 1210 */,
/* 1211 */,
/* 1212 */,
/* 1213 */,
/* 1214 */,
/* 1215 */,
/* 1216 */,
/* 1217 */,
/* 1218 */,
/* 1219 */,
/* 1220 */,
/* 1221 */,
/* 1222 */,
/* 1223 */,
/* 1224 */,
/* 1225 */,
/* 1226 */,
/* 1227 */,
/* 1228 */,
/* 1229 */,
/* 1230 */,
/* 1231 */,
/* 1232 */,
/* 1233 */,
/* 1234 */,
/* 1235 */,
/* 1236 */,
/* 1237 */,
/* 1238 */,
/* 1239 */,
/* 1240 */,
/* 1241 */,
/* 1242 */,
/* 1243 */,
/* 1244 */,
/* 1245 */,
/* 1246 */,
/* 1247 */,
/* 1248 */,
/* 1249 */,
/* 1250 */,
/* 1251 */,
/* 1252 */,
/* 1253 */,
/* 1254 */,
/* 1255 */,
/* 1256 */,
/* 1257 */,
/* 1258 */,
/* 1259 */,
/* 1260 */,
/* 1261 */,
/* 1262 */,
/* 1263 */,
/* 1264 */,
/* 1265 */,
/* 1266 */,
/* 1267 */,
/* 1268 */,
/* 1269 */,
/* 1270 */,
/* 1271 */,
/* 1272 */,
/* 1273 */,
/* 1274 */,
/* 1275 */,
/* 1276 */,
/* 1277 */,
/* 1278 */,
/* 1279 */,
/* 1280 */,
/* 1281 */,
/* 1282 */,
/* 1283 */,
/* 1284 */,
/* 1285 */,
/* 1286 */,
/* 1287 */,
/* 1288 */,
/* 1289 */,
/* 1290 */,
/* 1291 */,
/* 1292 */,
/* 1293 */,
/* 1294 */,
/* 1295 */,
/* 1296 */,
/* 1297 */,
/* 1298 */,
/* 1299 */,
/* 1300 */,
/* 1301 */,
/* 1302 */,
/* 1303 */,
/* 1304 */,
/* 1305 */,
/* 1306 */,
/* 1307 */,
/* 1308 */,
/* 1309 */,
/* 1310 */,
/* 1311 */,
/* 1312 */,
/* 1313 */,
/* 1314 */,
/* 1315 */,
/* 1316 */,
/* 1317 */,
/* 1318 */,
/* 1319 */,
/* 1320 */,
/* 1321 */,
/* 1322 */,
/* 1323 */,
/* 1324 */,
/* 1325 */,
/* 1326 */,
/* 1327 */,
/* 1328 */,
/* 1329 */,
/* 1330 */,
/* 1331 */,
/* 1332 */,
/* 1333 */,
/* 1334 */,
/* 1335 */,
/* 1336 */,
/* 1337 */,
/* 1338 */,
/* 1339 */,
/* 1340 */,
/* 1341 */,
/* 1342 */,
/* 1343 */,
/* 1344 */,
/* 1345 */,
/* 1346 */,
/* 1347 */,
/* 1348 */,
/* 1349 */,
/* 1350 */,
/* 1351 */,
/* 1352 */,
/* 1353 */,
/* 1354 */,
/* 1355 */,
/* 1356 */,
/* 1357 */,
/* 1358 */,
/* 1359 */,
/* 1360 */,
/* 1361 */,
/* 1362 */,
/* 1363 */,
/* 1364 */,
/* 1365 */,
/* 1366 */,
/* 1367 */,
/* 1368 */,
/* 1369 */,
/* 1370 */,
/* 1371 */,
/* 1372 */,
/* 1373 */,
/* 1374 */,
/* 1375 */,
/* 1376 */,
/* 1377 */,
/* 1378 */,
/* 1379 */,
/* 1380 */,
/* 1381 */,
/* 1382 */,
/* 1383 */,
/* 1384 */,
/* 1385 */,
/* 1386 */,
/* 1387 */,
/* 1388 */,
/* 1389 */,
/* 1390 */,
/* 1391 */,
/* 1392 */,
/* 1393 */,
/* 1394 */,
/* 1395 */,
/* 1396 */,
/* 1397 */,
/* 1398 */,
/* 1399 */,
/* 1400 */,
/* 1401 */,
/* 1402 */,
/* 1403 */,
/* 1404 */,
/* 1405 */,
/* 1406 */,
/* 1407 */,
/* 1408 */,
/* 1409 */,
/* 1410 */,
/* 1411 */,
/* 1412 */,
/* 1413 */,
/* 1414 */,
/* 1415 */,
/* 1416 */,
/* 1417 */,
/* 1418 */,
/* 1419 */,
/* 1420 */,
/* 1421 */,
/* 1422 */,
/* 1423 */,
/* 1424 */,
/* 1425 */,
/* 1426 */,
/* 1427 */,
/* 1428 */,
/* 1429 */,
/* 1430 */,
/* 1431 */,
/* 1432 */,
/* 1433 */,
/* 1434 */,
/* 1435 */,
/* 1436 */,
/* 1437 */,
/* 1438 */,
/* 1439 */,
/* 1440 */,
/* 1441 */,
/* 1442 */,
/* 1443 */,
/* 1444 */,
/* 1445 */,
/* 1446 */,
/* 1447 */,
/* 1448 */,
/* 1449 */,
/* 1450 */,
/* 1451 */,
/* 1452 */,
/* 1453 */,
/* 1454 */,
/* 1455 */,
/* 1456 */,
/* 1457 */,
/* 1458 */,
/* 1459 */,
/* 1460 */,
/* 1461 */,
/* 1462 */,
/* 1463 */,
/* 1464 */,
/* 1465 */,
/* 1466 */,
/* 1467 */,
/* 1468 */,
/* 1469 */,
/* 1470 */,
/* 1471 */,
/* 1472 */,
/* 1473 */,
/* 1474 */,
/* 1475 */,
/* 1476 */,
/* 1477 */,
/* 1478 */,
/* 1479 */,
/* 1480 */,
/* 1481 */,
/* 1482 */,
/* 1483 */,
/* 1484 */,
/* 1485 */,
/* 1486 */,
/* 1487 */,
/* 1488 */,
/* 1489 */,
/* 1490 */,
/* 1491 */,
/* 1492 */,
/* 1493 */,
/* 1494 */,
/* 1495 */,
/* 1496 */,
/* 1497 */,
/* 1498 */,
/* 1499 */,
/* 1500 */,
/* 1501 */,
/* 1502 */,
/* 1503 */,
/* 1504 */,
/* 1505 */,
/* 1506 */,
/* 1507 */,
/* 1508 */,
/* 1509 */,
/* 1510 */,
/* 1511 */,
/* 1512 */,
/* 1513 */,
/* 1514 */,
/* 1515 */,
/* 1516 */,
/* 1517 */,
/* 1518 */,
/* 1519 */,
/* 1520 */,
/* 1521 */,
/* 1522 */,
/* 1523 */,
/* 1524 */,
/* 1525 */,
/* 1526 */,
/* 1527 */,
/* 1528 */,
/* 1529 */,
/* 1530 */,
/* 1531 */,
/* 1532 */,
/* 1533 */,
/* 1534 */,
/* 1535 */,
/* 1536 */,
/* 1537 */,
/* 1538 */,
/* 1539 */,
/* 1540 */,
/* 1541 */,
/* 1542 */,
/* 1543 */,
/* 1544 */,
/* 1545 */,
/* 1546 */,
/* 1547 */,
/* 1548 */,
/* 1549 */,
/* 1550 */,
/* 1551 */,
/* 1552 */,
/* 1553 */,
/* 1554 */,
/* 1555 */,
/* 1556 */,
/* 1557 */,
/* 1558 */,
/* 1559 */,
/* 1560 */,
/* 1561 */,
/* 1562 */,
/* 1563 */,
/* 1564 */,
/* 1565 */,
/* 1566 */,
/* 1567 */,
/* 1568 */,
/* 1569 */,
/* 1570 */,
/* 1571 */,
/* 1572 */,
/* 1573 */,
/* 1574 */,
/* 1575 */,
/* 1576 */,
/* 1577 */,
/* 1578 */,
/* 1579 */,
/* 1580 */,
/* 1581 */,
/* 1582 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__, __webpack_module_template_argument_3__, __webpack_module_template_argument_4__) {

	var hashClear = __webpack_require__(__webpack_module_template_argument_0__),
	    hashDelete = __webpack_require__(__webpack_module_template_argument_1__),
	    hashGet = __webpack_require__(__webpack_module_template_argument_2__),
	    hashHas = __webpack_require__(__webpack_module_template_argument_3__),
	    hashSet = __webpack_require__(__webpack_module_template_argument_4__);

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;

	module.exports = Hash;


/***/ }),
/* 1583 */,
/* 1584 */,
/* 1585 */,
/* 1586 */,
/* 1587 */,
/* 1588 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__, __webpack_module_template_argument_3__, __webpack_module_template_argument_4__) {

	var listCacheClear = __webpack_require__(__webpack_module_template_argument_0__),
	    listCacheDelete = __webpack_require__(__webpack_module_template_argument_1__),
	    listCacheGet = __webpack_require__(__webpack_module_template_argument_2__),
	    listCacheHas = __webpack_require__(__webpack_module_template_argument_3__),
	    listCacheSet = __webpack_require__(__webpack_module_template_argument_4__);

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;

	module.exports = ListCache;


/***/ }),
/* 1589 */,
/* 1590 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__) {

	var getNative = __webpack_require__(__webpack_module_template_argument_0__),
	    root = __webpack_require__(__webpack_module_template_argument_1__);

	/* Built-in method references that are verified to be native. */
	var Map = getNative(root, 'Map');

	module.exports = Map;


/***/ }),
/* 1591 */,
/* 1592 */,
/* 1593 */,
/* 1594 */,
/* 1595 */,
/* 1596 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__, __webpack_module_template_argument_3__, __webpack_module_template_argument_4__) {

	var mapCacheClear = __webpack_require__(__webpack_module_template_argument_0__),
	    mapCacheDelete = __webpack_require__(__webpack_module_template_argument_1__),
	    mapCacheGet = __webpack_require__(__webpack_module_template_argument_2__),
	    mapCacheHas = __webpack_require__(__webpack_module_template_argument_3__),
	    mapCacheSet = __webpack_require__(__webpack_module_template_argument_4__);

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;

	module.exports = MapCache;


/***/ }),
/* 1597 */,
/* 1598 */,
/* 1599 */,
/* 1600 */,
/* 1601 */,
/* 1602 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__) {

	var getNative = __webpack_require__(__webpack_module_template_argument_0__),
	    root = __webpack_require__(__webpack_module_template_argument_1__);

	/* Built-in method references that are verified to be native. */
	var Set = getNative(root, 'Set');

	module.exports = Set;


/***/ }),
/* 1603 */,
/* 1604 */,
/* 1605 */,
/* 1606 */,
/* 1607 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__) {

	var MapCache = __webpack_require__(__webpack_module_template_argument_0__),
	    setCacheAdd = __webpack_require__(__webpack_module_template_argument_1__),
	    setCacheHas = __webpack_require__(__webpack_module_template_argument_2__);

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values == null ? 0 : values.length;

	  this.__data__ = new MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;

	module.exports = SetCache;


/***/ }),
/* 1608 */,
/* 1609 */,
/* 1610 */,
/* 1611 */,
/* 1612 */,
/* 1613 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	var root = __webpack_require__(__webpack_module_template_argument_0__);

	/** Built-in value references. */
	var Symbol = root.Symbol;

	module.exports = Symbol;


/***/ }),
/* 1614 */,
/* 1615 */,
/* 1616 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__, __webpack_module_template_argument_3__, __webpack_module_template_argument_4__, __webpack_module_template_argument_5__) {

	var baseTimes = __webpack_require__(__webpack_module_template_argument_0__),
	    isArguments = __webpack_require__(__webpack_module_template_argument_1__),
	    isArray = __webpack_require__(__webpack_module_template_argument_2__),
	    isBuffer = __webpack_require__(__webpack_module_template_argument_3__),
	    isIndex = __webpack_require__(__webpack_module_template_argument_4__),
	    isTypedArray = __webpack_require__(__webpack_module_template_argument_5__);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray(value),
	      isArg = !isArr && isArguments(value),
	      isBuff = !isArr && !isArg && isBuffer(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = arrayLikeKeys;


/***/ }),
/* 1617 */,
/* 1618 */,
/* 1619 */,
/* 1620 */,
/* 1621 */,
/* 1622 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	var eq = __webpack_require__(__webpack_module_template_argument_0__);

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	module.exports = assocIndexOf;


/***/ }),
/* 1623 */,
/* 1624 */,
/* 1625 */,
/* 1626 */,
/* 1627 */,
/* 1628 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	var defineProperty = __webpack_require__(__webpack_module_template_argument_0__);

	/**
	 * The base implementation of `assignValue` and `assignMergeValue` without
	 * value checks.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function baseAssignValue(object, key, value) {
	  if (key == '__proto__' && defineProperty) {
	    defineProperty(object, key, {
	      'configurable': true,
	      'enumerable': true,
	      'value': value,
	      'writable': true
	    });
	  } else {
	    object[key] = value;
	  }
	}

	module.exports = baseAssignValue;


/***/ }),
/* 1629 */,
/* 1630 */,
/* 1631 */,
/* 1632 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__) {

	var Symbol = __webpack_require__(__webpack_module_template_argument_0__),
	    getRawTag = __webpack_require__(__webpack_module_template_argument_1__),
	    objectToString = __webpack_require__(__webpack_module_template_argument_2__);

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}

	module.exports = baseGetTag;


/***/ }),
/* 1633 */,
/* 1634 */,
/* 1635 */,
/* 1636 */,
/* 1637 */,
/* 1638 */,
/* 1639 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__) {

	var baseGetTag = __webpack_require__(__webpack_module_template_argument_0__),
	    isObjectLike = __webpack_require__(__webpack_module_template_argument_1__);

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]';

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike(value) && baseGetTag(value) == argsTag;
	}

	module.exports = baseIsArguments;


/***/ }),
/* 1640 */,
/* 1641 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__, __webpack_module_template_argument_3__) {

	var isFunction = __webpack_require__(__webpack_module_template_argument_0__),
	    isMasked = __webpack_require__(__webpack_module_template_argument_1__),
	    isObject = __webpack_require__(__webpack_module_template_argument_2__),
	    toSource = __webpack_require__(__webpack_module_template_argument_3__);

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	module.exports = baseIsNative;


/***/ }),
/* 1642 */,
/* 1643 */,
/* 1644 */,
/* 1645 */,
/* 1646 */,
/* 1647 */,
/* 1648 */,
/* 1649 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__) {

	var baseGetTag = __webpack_require__(__webpack_module_template_argument_0__),
	    isLength = __webpack_require__(__webpack_module_template_argument_1__),
	    isObjectLike = __webpack_require__(__webpack_module_template_argument_2__);

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	}

	module.exports = baseIsTypedArray;


/***/ }),
/* 1650 */,
/* 1651 */,
/* 1652 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	var root = __webpack_require__(__webpack_module_template_argument_0__);

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	module.exports = coreJsData;


/***/ }),
/* 1653 */,
/* 1654 */,
/* 1655 */,
/* 1656 */,
/* 1657 */,
/* 1658 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	var getNative = __webpack_require__(__webpack_module_template_argument_0__);

	var defineProperty = (function() {
	  try {
	    var func = getNative(Object, 'defineProperty');
	    func({}, '', {});
	    return func;
	  } catch (e) {}
	}());

	module.exports = defineProperty;


/***/ }),
/* 1659 */,
/* 1660 */,
/* 1661 */,
/* 1662 */,
/* 1663 */,
/* 1664 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	var isKeyable = __webpack_require__(__webpack_module_template_argument_0__);

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	module.exports = getMapData;


/***/ }),
/* 1665 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__) {

	var baseIsNative = __webpack_require__(__webpack_module_template_argument_0__),
	    getValue = __webpack_require__(__webpack_module_template_argument_1__);

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	module.exports = getNative;


/***/ }),
/* 1666 */,
/* 1667 */,
/* 1668 */,
/* 1669 */,
/* 1670 */,
/* 1671 */,
/* 1672 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	var Symbol = __webpack_require__(__webpack_module_template_argument_0__);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	module.exports = getRawTag;


/***/ }),
/* 1673 */,
/* 1674 */,
/* 1675 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	var nativeCreate = __webpack_require__(__webpack_module_template_argument_0__);

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	  this.size = 0;
	}

	module.exports = hashClear;


/***/ }),
/* 1676 */,
/* 1677 */,
/* 1678 */,
/* 1679 */,
/* 1680 */,
/* 1681 */,
/* 1682 */,
/* 1683 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	var nativeCreate = __webpack_require__(__webpack_module_template_argument_0__);

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}

	module.exports = hashGet;


/***/ }),
/* 1684 */,
/* 1685 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	var nativeCreate = __webpack_require__(__webpack_module_template_argument_0__);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
	}

	module.exports = hashHas;


/***/ }),
/* 1686 */,
/* 1687 */,
/* 1688 */,
/* 1689 */,
/* 1690 */,
/* 1691 */,
/* 1692 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	var nativeCreate = __webpack_require__(__webpack_module_template_argument_0__);

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}

	module.exports = hashSet;


/***/ }),
/* 1693 */,
/* 1694 */,
/* 1695 */,
/* 1696 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	var coreJsData = __webpack_require__(__webpack_module_template_argument_0__);

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	module.exports = isMasked;


/***/ }),
/* 1697 */,
/* 1698 */,
/* 1699 */,
/* 1700 */,
/* 1701 */,
/* 1702 */,
/* 1703 */,
/* 1704 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	var assocIndexOf = __webpack_require__(__webpack_module_template_argument_0__);

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	module.exports = listCacheDelete;


/***/ }),
/* 1705 */,
/* 1706 */,
/* 1707 */,
/* 1708 */,
/* 1709 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	var assocIndexOf = __webpack_require__(__webpack_module_template_argument_0__);

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	module.exports = listCacheGet;


/***/ }),
/* 1710 */,
/* 1711 */,
/* 1712 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	var assocIndexOf = __webpack_require__(__webpack_module_template_argument_0__);

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}

	module.exports = listCacheHas;


/***/ }),
/* 1713 */,
/* 1714 */,
/* 1715 */,
/* 1716 */,
/* 1717 */,
/* 1718 */,
/* 1719 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	var assocIndexOf = __webpack_require__(__webpack_module_template_argument_0__);

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	module.exports = listCacheSet;


/***/ }),
/* 1720 */,
/* 1721 */,
/* 1722 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__) {

	var Hash = __webpack_require__(__webpack_module_template_argument_0__),
	    ListCache = __webpack_require__(__webpack_module_template_argument_1__),
	    Map = __webpack_require__(__webpack_module_template_argument_2__);

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}

	module.exports = mapCacheClear;


/***/ }),
/* 1723 */,
/* 1724 */,
/* 1725 */,
/* 1726 */,
/* 1727 */,
/* 1728 */,
/* 1729 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	var getMapData = __webpack_require__(__webpack_module_template_argument_0__);

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	module.exports = mapCacheDelete;


/***/ }),
/* 1730 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	var getMapData = __webpack_require__(__webpack_module_template_argument_0__);

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}

	module.exports = mapCacheGet;


/***/ }),
/* 1731 */,
/* 1732 */,
/* 1733 */,
/* 1734 */,
/* 1735 */,
/* 1736 */,
/* 1737 */,
/* 1738 */,
/* 1739 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	var getMapData = __webpack_require__(__webpack_module_template_argument_0__);

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}

	module.exports = mapCacheHas;


/***/ }),
/* 1740 */,
/* 1741 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	var getMapData = __webpack_require__(__webpack_module_template_argument_0__);

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	module.exports = mapCacheSet;


/***/ }),
/* 1742 */,
/* 1743 */,
/* 1744 */,
/* 1745 */,
/* 1746 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	var getNative = __webpack_require__(__webpack_module_template_argument_0__);

	/* Built-in method references that are verified to be native. */
	var nativeCreate = getNative(Object, 'create');

	module.exports = nativeCreate;


/***/ }),
/* 1747 */,
/* 1748 */,
/* 1749 */,
/* 1750 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(__webpack_module_template_argument_0__);

	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && freeGlobal.process;

	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
	  } catch (e) {}
	}());

	module.exports = nodeUtil;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 1751 */,
/* 1752 */,
/* 1753 */,
/* 1754 */,
/* 1755 */,
/* 1756 */,
/* 1757 */,
/* 1758 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	var freeGlobal = __webpack_require__(__webpack_module_template_argument_0__);

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	module.exports = root;


/***/ }),
/* 1759 */,
/* 1760 */,
/* 1761 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__) {

	var baseIsArguments = __webpack_require__(__webpack_module_template_argument_0__),
	    isObjectLike = __webpack_require__(__webpack_module_template_argument_1__);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};

	module.exports = isArguments;


/***/ }),
/* 1762 */,
/* 1763 */,
/* 1764 */,
/* 1765 */,
/* 1766 */,
/* 1767 */,
/* 1768 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__) {

	var isFunction = __webpack_require__(__webpack_module_template_argument_0__),
	    isLength = __webpack_require__(__webpack_module_template_argument_1__);

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	module.exports = isArrayLike;


/***/ }),
/* 1769 */,
/* 1770 */,
/* 1771 */,
/* 1772 */,
/* 1773 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__) {

	/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(__webpack_module_template_argument_0__),
	    stubFalse = __webpack_require__(__webpack_module_template_argument_1__);

	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse;

	module.exports = isBuffer;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)(module)))

/***/ }),
/* 1774 */,
/* 1775 */,
/* 1776 */,
/* 1777 */,
/* 1778 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__) {

	var baseGetTag = __webpack_require__(__webpack_module_template_argument_0__),
	    isObject = __webpack_require__(__webpack_module_template_argument_1__);

	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	module.exports = isFunction;


/***/ }),
/* 1779 */,
/* 1780 */,
/* 1781 */,
/* 1782 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__, __webpack_module_template_argument_1__, __webpack_module_template_argument_2__) {

	var baseIsTypedArray = __webpack_require__(__webpack_module_template_argument_0__),
	    baseUnary = __webpack_require__(__webpack_module_template_argument_1__),
	    nodeUtil = __webpack_require__(__webpack_module_template_argument_2__);

	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	module.exports = isTypedArray;


/***/ }),
/* 1783 */,
/* 1784 */,
/* 1785 */
/***/ (function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	var MapCache = __webpack_require__(__webpack_module_template_argument_0__);

	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoized function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize(func, resolver) {
	  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  var memoized = function() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;

	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result) || cache;
	    return result;
	  };
	  memoized.cache = new (memoize.Cache || MapCache);
	  return memoized;
	}

	// Expose `MapCache`.
	memoize.Cache = MapCache;

	module.exports = memoize;


/***/ })
/******/ ])))
});
;