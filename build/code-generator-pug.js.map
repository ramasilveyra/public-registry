{"version":3,"sources":["../src/code-generator-pug.js"],"names":["codeGeneratorPug","node","initialIndentLevel","indentLevel","previousSibling","type","rootName","children","map","child","join","mixinName","elementName","indent","generateTag","tagName","i","attributes","textName","value","attributeName","generateProperty","name","expression","interpolationEscapedName","conditionName","includes","generateInterpolationEscaped","generateCondition","test","consequent","alternate","iterationName","generateIteration","iterable","currentValue","index","array","body","TypeError","properties","startTag","htmlTagsVoids","addSpace","tag","normalizedName","normalizePropertyName","newConsequent","alternateOrNull","stuff","conditionArray","filter","Boolean","params","iterationArray","generateScriptlet","str","indentChar","indentLength","startIndentNumber","isRoot","strIndented","repeat"],"mappings":"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","file":"code-generator-pug.js","sourcesContent":["/* eslint-disable no-param-reassign */\nimport htmlTagsVoids from 'html-tags/void';\nimport {\n  attributeName,\n  conditionName,\n  elementName,\n  interpolationEscapedName,\n  iterationName,\n  mixinName,\n  rootName,\n  textName\n} from './ast';\n\nfunction codeGeneratorPug(\n  node,\n  { initialIndentLevel = 0, indentLevel = initialIndentLevel, previousSibling = null } = {}\n) {\n  switch (node.type) {\n    case rootName:\n      return node.children\n        .map(child => codeGeneratorPug(child, { initialIndentLevel, indentLevel }))\n        .join('');\n    case mixinName:\n      return node.children.map(child =>\n        codeGeneratorPug(child, { initialIndentLevel, indentLevel })\n      );\n    case elementName:\n      return indent(\n        generateTag(\n          node.tagName,\n          node.children\n            .map((child, i) =>\n              codeGeneratorPug(child, {\n                initialIndentLevel,\n                indentLevel: indentLevel + 1,\n                previousSibling: i > 0 ? node.children[i - 1] : null\n              })\n            )\n            .join(''),\n          node.attributes\n            .map(child =>\n              codeGeneratorPug(child, { initialIndentLevel, indentLevel: indentLevel + 1 })\n            )\n            .join(', ')\n        ),\n        {\n          initialIndentLevel,\n          indentLevel\n        }\n      );\n    case textName:\n      if (previousSibling && previousSibling.type === elementName) {\n        return indent(`| ${node.value}`, { initialIndentLevel, indentLevel });\n      }\n      return node.value;\n    case attributeName:\n      return generateProperty(node.name, node.value, node.expression);\n    case interpolationEscapedName:\n      if (previousSibling && [elementName, conditionName].includes(previousSibling.type)) {\n        return indent(`| ${generateInterpolationEscaped(node.value)}`, {\n          initialIndentLevel,\n          indentLevel\n        });\n      }\n      return generateInterpolationEscaped(node.value);\n    case conditionName:\n      return indent(\n        generateCondition(\n          node.test,\n          codeGeneratorPug(node.consequent, { initialIndentLevel, indentLevel: indentLevel + 1 }),\n          node.alternate &&\n            codeGeneratorPug(node.alternate, { initialIndentLevel, indentLevel: indentLevel + 1 }),\n          initialIndentLevel,\n          indentLevel + 1\n        ),\n        {\n          initialIndentLevel,\n          indentLevel\n        }\n      );\n    case iterationName:\n      return indent(\n        generateIteration({\n          iterable: node.iterable,\n          currentValue: node.currentValue,\n          index: node.index,\n          array: node.array,\n          body: codeGeneratorPug(node.body, { initialIndentLevel, indentLevel: indentLevel + 1 }),\n          initialIndentLevel,\n          indentLevel\n        }),\n        {\n          initialIndentLevel,\n          indentLevel\n        }\n      );\n    default:\n      throw new TypeError(node.type);\n  }\n}\n\nexport default codeGeneratorPug;\n\nfunction generateTag(tagName, children, properties) {\n  const startTag = `${tagName}${properties ? '(' : ''}${properties}${properties ? ')' : ''}`;\n  if (htmlTagsVoids.includes(tagName)) {\n    return startTag;\n  }\n  const addSpace = children && !children[0].includes('\\n');\n  const tag = startTag + (addSpace ? ` ${children}` : children);\n  return tag;\n}\n\nfunction generateProperty(name, value, expression) {\n  const normalizedName = normalizePropertyName(name);\n\n  // NOTE: `value === true` is to accept boolean attributes, e.g.: `<input checked />`.\n  if (value === true) {\n    return normalizedName;\n  }\n\n  if (expression) {\n    return `${normalizedName}=${value}`;\n  }\n\n  return `${normalizedName}=\"${value}\"`;\n}\n\nfunction normalizePropertyName(name) {\n  switch (name) {\n    case 'className':\n      return 'class';\n    case 'htmlFor':\n      return 'for';\n    case 'tabIndex':\n      return 'tabindex';\n    default:\n      return name;\n  }\n}\n\nfunction generateCondition(test, consequent, alternate, initialIndentLevel, indentLevel) {\n  const newConsequent =\n    consequent[0] === '\\n' ? consequent : indent(consequent, { initialIndentLevel, indentLevel });\n  const alternateOrNull = stuff => (alternate ? stuff() : null);\n  const conditionArray = [\n    `if ${test}`,\n    newConsequent,\n    alternateOrNull(() => indent('else', { initialIndentLevel, indentLevel: indentLevel - 1 })),\n    alternateOrNull(\n      () =>\n        alternate[0] === '\\n' ? alternate : indent(alternate, { initialIndentLevel, indentLevel })\n    )\n  ].filter(Boolean);\n  return conditionArray.join('');\n}\n\nfunction generateIteration({\n  iterable,\n  currentValue,\n  index,\n  array,\n  body,\n  initialIndentLevel,\n  indentLevel\n}) {\n  const params = [currentValue, index].filter(Boolean).join(', ');\n  const iterationArray = [\n    `each ${params} in ${iterable}`,\n    array\n      ? indent(generateScriptlet(`const ${array} = ${iterable};`), {\n          initialIndentLevel,\n          indentLevel: indentLevel + 1\n        })\n      : null,\n    body\n  ].filter(Boolean);\n  return iterationArray.join('');\n}\n\nfunction generateScriptlet(value) {\n  return `- ${value}`;\n}\n\nfunction generateInterpolationEscaped(value) {\n  return `#{${value}}`;\n}\n\nfunction indent(str, { initialIndentLevel, indentLevel }) {\n  const indentChar = ' ';\n  const indentLength = 2;\n  const startIndentNumber = indentLevel * indentLength;\n  const isRoot = indentLevel === initialIndentLevel;\n  const strIndented = `${isRoot ? '' : '\\n'}${indentChar.repeat(startIndentNumber)}${str}${\n    isRoot ? '\\n' : ''\n  }`;\n  return strIndented;\n}\n"]}