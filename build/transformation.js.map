{"version":3,"sources":["../src/transformation.js"],"names":["t","transformation","oldAst","inputFilePath","newAst","table","components","dependencies","reactComponentVisitor","JSXElement","path","tagName","node","openingElement","name","isFromDependency","isUsedAsRC","element","context","getContext","setContext","JSXText","elems","value","text","JSXExpressionContainer","isJSXAttribute","parent","expressionPath","get","expression","isLogicalExpression","operator","isConditionalExpression","isIterator","isMapIterator","identifiers","getIdentifiersInfo","isIdentifier","interpolationEscaped","code","JSXAttribute","valueNode","shouldIgnoreAttr","attribute","isStringLiteral","isJSXExpressionContainer","styles","properties","forEach","prop","key","stringInlineStyles","generated","concise","sourceMaps","fixedIdentifiers","Object","keys","reduce","obj","keyMappings","rawMappings","filter","keyMapping","map","indentifier","i","start","column","end","length","CallExpression","callee","aarguments","arguments","iterable","replace","currentValue","params","index","array","iteration","LogicalExpression","test","findParent","left","condition","consequent","ConditionalExpression","testPath","ignoreConsequent","isNullLiteral","padding","StringLiteral","generalVisitor","ImportDeclaration","source","specifier","specifiers","find","isImportDefaultSpecifier","local","requiredFrom","VariableDeclaration","checkForReactComponent","FunctionDeclaration","ExportDefaultDeclaration","exportedComponent","declaration","component","defaultExport","mainComponent","values","ast","is","isFunctionDeclaration","isExportDefaultDeclaration","props","mixin","createdFrom","traverse","_context","pathItem","property","includes","info","idInfo","getIdentifierInfo","Identifier","push","idStart","idEnd"],"mappings":"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","file":"transformation.js","sourcesContent":["/* eslint-disable no-underscore-dangle, no-param-reassign */\nimport babelTraverse from '@babel/traverse';\nimport babelGenerator from '@babel/generator';\nimport * as t from '@babel/types';\nimport cleanJSXElementLiteralChild from '@babel/types/lib/utils/react/cleanJSXElementLiteralChild';\nimport {\n  createAttribute,\n  createCondition,\n  createElement,\n  createInterpolationEscaped,\n  createIteration,\n  createMixin,\n  createRoot,\n  createText\n} from './ast';\nimport isFunctionalReactComponent from './utils/is-functional-react-component';\nimport getReactComponentName from './utils/get-react-component-name';\nimport addToContext from './utils/add-to-context';\nimport getReactComponentProps from './utils/get-react-component-props';\nimport inlineStyles from './utils/inline-styles';\n\nfunction transformation(oldAst, inputFilePath) {\n  const newAst = createRoot();\n  const table = { components: {}, dependencies: {} };\n\n  const reactComponentVisitor = {\n    JSXElement(path) {\n      const tagName = path.node.openingElement.name.name;\n      const isFromDependency = table.dependencies[tagName];\n      if (isFromDependency) {\n        isFromDependency.isUsedAsRC = true;\n      }\n      const element = createElement(tagName);\n      const context = getContext(path);\n      addToContext(context, element);\n      setContext(path, element);\n    },\n    JSXText(path) {\n      const elems = [];\n      cleanJSXElementLiteralChild(path.node, elems);\n      const value = elems[0] ? elems[0].value : '';\n      if (!value) {\n        return;\n      }\n      const text = createText(value);\n      const context = getContext(path);\n      addToContext(context, text);\n    },\n    JSXExpressionContainer(path) {\n      // Let JSXAttribute visitor handle JSXExpressionContainer of attributes.\n      if (t.isJSXAttribute(path.parent)) {\n        return;\n      }\n\n      const expressionPath = path.get('expression');\n      const expression = expressionPath.node;\n\n      if (t.isLogicalExpression(expression, { operator: '&&' })) {\n        return;\n      }\n      if (t.isLogicalExpression(expression, { operator: '||' })) {\n        return;\n      }\n      if (t.isConditionalExpression(expression)) {\n        return;\n      }\n\n      const isIterator = isMapIterator(expression);\n\n      if (isIterator) {\n        return;\n      }\n\n      const context = getContext(path);\n      const identifiers = getIdentifiersInfo(expressionPath);\n\n      if (t.isIdentifier(expression)) {\n        const interpolationEscaped = createInterpolationEscaped(expression.name, identifiers);\n        addToContext(context, interpolationEscaped);\n        return;\n      }\n      const { code } = babelGenerator(expression);\n      const interpolationEscaped = createInterpolationEscaped(code, identifiers);\n      addToContext(context, interpolationEscaped);\n    },\n    JSXAttribute(path) {\n      const context = getContext(path);\n      const name = path.node.name.name;\n      const valueNode = path.node.value;\n      if (shouldIgnoreAttr(name)) {\n        return;\n      }\n      if (!valueNode) {\n        const attribute = createAttribute({ name, value: true, expression: true });\n        addToContext(context, attribute, 'attributes');\n        return;\n      }\n      if (t.isStringLiteral(valueNode)) {\n        const attribute = createAttribute({ name, value: valueNode.value });\n        addToContext(context, attribute, 'attributes');\n        return;\n      }\n      const expression = path.get('value.expression');\n      if (t.isJSXExpressionContainer(valueNode) && t.isIdentifier(expression.node)) {\n        const identifiers = getIdentifiersInfo(expression);\n        const attribute = createAttribute({\n          name,\n          value: expression.node.name,\n          expression: true,\n          identifiers\n        });\n        addToContext(context, attribute, 'attributes');\n        return;\n      }\n      if (name === 'style') {\n        const styles = {};\n        expression.node.properties.forEach(prop => {\n          styles[prop.key.name] = prop.value.value;\n        });\n        const stringInlineStyles = inlineStyles(styles);\n        if (stringInlineStyles) {\n          const attribute = createAttribute({ name, value: stringInlineStyles });\n          addToContext(context, attribute, 'attributes');\n        }\n        return;\n      }\n\n      const generated = babelGenerator(expression.node, { concise: true, sourceMaps: true });\n      const identifiers = getIdentifiersInfo(expression);\n      const fixedIdentifiers = Object.keys(identifiers).reduce((obj, key) => {\n        const keyMappings = generated.rawMappings.filter(keyMapping => keyMapping.name === key);\n        obj[key] = identifiers[key].map((indentifier, i) => {\n          const start = keyMappings[i].generated.column;\n          const end = start + key.length;\n          return { start, end };\n        });\n        return obj;\n      }, {});\n      const attribute = createAttribute({\n        name,\n        value: generated.code,\n        expression: true,\n        identifiers: fixedIdentifiers\n      });\n      addToContext(context, attribute, 'attributes');\n    },\n    CallExpression(path) {\n      const callee = path.node.callee;\n      const aarguments = path.node.arguments[0];\n      const isIterator = isMapIterator(path.node);\n      if (isIterator) {\n        const context = getContext(path);\n        const { code } = babelGenerator(callee);\n        const iterable = code.replace('.map', '');\n        const currentValue = aarguments.params[0].name;\n        const index = aarguments.params[1] ? aarguments.params[1].name : null;\n        const array = aarguments.params[2] ? aarguments.params[2].name : null;\n        const iteration = createIteration({ iterable, currentValue, index, array });\n        addToContext(context, iteration);\n        setContext(path, iteration);\n      }\n    },\n    LogicalExpression(path) {\n      if (t.isConditionalExpression(path.parent) && path.parent.test === path.node) {\n        return;\n      }\n      if (path.findParent(node => t.isJSXAttribute(node)) || t.isLogicalExpression(path.parent)) {\n        return;\n      }\n      const left = path.get('left');\n      const context = getContext(path);\n      const identifiers = getIdentifiersInfo(left);\n      if (path.node.operator === '&&') {\n        const { code } = babelGenerator(left.node);\n        const condition = createCondition({ test: code, identifiers });\n        addToContext(context, condition);\n        setContext(path, condition);\n        return;\n      }\n      const { code } = babelGenerator(left.node);\n      const interpolationEscaped = createInterpolationEscaped(code, identifiers);\n      const condition = createCondition({\n        test: code,\n        consequent: interpolationEscaped,\n        identifiers\n      });\n      addToContext(context, condition);\n      setContext(path, condition);\n    },\n    ConditionalExpression(path) {\n      if (path.findParent(node => t.isJSXAttribute(node))) {\n        return;\n      }\n      const testPath = path.get('test');\n      const context = getContext(path);\n      const ignoreConsequent = t.isNullLiteral(path.node.consequent);\n      const padding = ignoreConsequent ? 2 : 0;\n      const identifiers = getIdentifiersInfo(testPath, padding);\n      const { code } = babelGenerator(testPath.node);\n      const test = ignoreConsequent ? `!(${code})` : code;\n      const condition = createCondition({ test, identifiers });\n      addToContext(context, condition);\n      setContext(path, condition);\n    },\n    StringLiteral(path) {\n      if (path.findParent(node => t.isJSXAttribute(node))) {\n        return;\n      }\n      if (t.isConditionalExpression(path.parent)) {\n        const context = getContext(path);\n        const text = createText(path.node.value);\n        addToContext(context, text);\n      }\n    }\n  };\n\n  const generalVisitor = {\n    ImportDeclaration(path) {\n      const source = path.node.source.value;\n      const specifier = path.node.specifiers.find(node => t.isImportDefaultSpecifier(node)).local\n        .name;\n      table.dependencies[specifier] = { source, requiredFrom: inputFilePath };\n    },\n    VariableDeclaration(path) {\n      checkForReactComponent(path);\n    },\n    FunctionDeclaration(path) {\n      checkForReactComponent(path);\n    },\n    ExportDefaultDeclaration(path) {\n      const exportedComponent = path.node.declaration.name;\n      const component = table.components[exportedComponent];\n      if (component) {\n        component.defaultExport = true;\n      }\n    }\n  };\n\n  babelTraverse(oldAst, generalVisitor, null);\n\n  const mainComponent = Object.values(table.components).find(component => component.defaultExport);\n  addToContext(newAst, mainComponent.node);\n\n  return { ast: newAst, table };\n\n  function checkForReactComponent(path) {\n    const is = isFunctionalReactComponent(path);\n    const name = getReactComponentName(path.node);\n    const defaultExport = t.isFunctionDeclaration(path.node)\n      ? t.isExportDefaultDeclaration(path.parent)\n      : false;\n    const props = getReactComponentProps(path.node);\n    if (is) {\n      const mixin = createMixin(name, props);\n      setContext(path, mixin);\n      table.components[name] = {\n        node: mixin,\n        defaultExport,\n        createdFrom: inputFilePath\n      };\n      path.traverse(reactComponentVisitor);\n    }\n  }\n}\n\nexport default transformation;\n\nfunction setContext(path, context) {\n  path.node._context = context;\n}\n\nfunction getContext(path) {\n  const context = path.findParent(pathItem => !!pathItem.node._context).node._context;\n  return context;\n}\n\nfunction isMapIterator(node) {\n  const callee = node.callee;\n  if (!callee || !callee.property) {\n    return false;\n  }\n  const is = callee.property.name === 'map';\n  return is;\n}\n\nfunction shouldIgnoreAttr(name) {\n  if (['key', 'onClick', 'ref'].includes(name)) {\n    return true;\n  }\n  return false;\n}\n\nfunction getIdentifiersInfo(path, padding = 0) {\n  const start = path.node.start;\n  const info = {};\n  if (t.isIdentifier(path.node)) {\n    const { name, info: idInfo } = getIdentifierInfo(path.node, start, padding);\n    info[name] = [idInfo];\n    return info;\n  }\n  path.traverse({\n    Identifier({ node }) {\n      const { name, info: idInfo } = getIdentifierInfo(node, start, padding);\n      if (info[name]) {\n        info[name].push(idInfo);\n      } else {\n        info[name] = [idInfo];\n      }\n    }\n  });\n  return info;\n}\n\nfunction getIdentifierInfo(node, start, padding) {\n  const idStart = node.start - start + padding;\n  const idEnd = node.end - start + padding;\n  const name = node.name;\n  const info = { start: idStart, end: idEnd };\n  return { name, info };\n}\n"]}