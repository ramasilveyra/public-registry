{"version":3,"sources":["../src/code-generator-ejs.js"],"names":["t","codeGeneratorEjs","node","initialIndentLevel","indentLevel","scope","type","rootName","children","map","child","join","mixinName","elementName","indent","generateTag","tagName","attributes","textName","value","attributeName","generateProperty","name","isBoolean","isString","valuePath","isRequired","interpolationEscapedName","generateInterpolation","interpolationUnescapedName","conditionName","generateCondition","testPath","consequent","alternate","iterationName","params","getIterationParams","currentValuePath","indexPath","arrayPath","generateIteration","iterablePath","body","concat","TypeError","properties","startTagBeginning","htmlTagsVoids","includes","startTag","endTag","tag","normalizedName","startPropertyBeginning","makeReferenceSafe","generatedValue","concise","resultString","resolvesToString","propertyInterpolated","generateScriptlet","code","conditionArray","filter","Boolean","iterationScope","getIterationScope","addParenthesis","isLogicalExpression","iterableCode","paramsCode","iterationArray","currentValueCode","indexCode","arrayCode","traverse","ArrowFunctionExpression","path","forEach","param","push","isIdentifier","referenceSafeReplacement","isMemberExpression","pathFirst","Identifier","path1","parent","isObjectProperty","MemberExpression","isFromScope","find","scopeVar","isUndefined","replaceWith","memberExpression","identifier","str","indentChar","indentLength","startIndentNumber","endIndentNumber","strIndented","repeat","isTemplateLiteral","isConditionalExpression","isStringLiteral","operator","right","isBinaryExpression","nodeLeft","left","nodeRight","isTaggedTemplateExpression"],"mappings":"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","file":"code-generator-ejs.js","sourcesContent":["/* eslint-disable no-param-reassign */\nimport htmlTagsVoids from 'html-tags/void';\nimport * as t from '@babel/types';\nimport babelGenerator from '@babel/generator';\nimport {\n  attributeName,\n  conditionName,\n  elementName,\n  interpolationEscapedName,\n  interpolationUnescapedName,\n  iterationName,\n  mixinName,\n  rootName,\n  textName\n} from './ast';\nimport normalizePropertyName from './utils/normalize-property-name';\nimport getFirstMemberExpression from './utils/get-first-member-expression';\n\nfunction codeGeneratorEjs(\n  node,\n  { initialIndentLevel = 0, indentLevel = initialIndentLevel, scope = [] } = {}\n) {\n  switch (node.type) {\n    case rootName:\n      return node.children\n        .map(child => codeGeneratorEjs(child, { initialIndentLevel, indentLevel, scope }))\n        .join('');\n    case mixinName:\n      return node.children\n        .map(child => codeGeneratorEjs(child, { initialIndentLevel, indentLevel, scope }))\n        .join('');\n    case elementName:\n      return indent(\n        generateTag(\n          node.tagName,\n          node.children\n            .map(child =>\n              codeGeneratorEjs(child, { initialIndentLevel, indentLevel: indentLevel + 1, scope })\n            )\n            .join(''),\n          node.attributes\n            .map(child =>\n              codeGeneratorEjs(child, { initialIndentLevel, indentLevel: indentLevel + 1, scope })\n            )\n            .join('')\n        ),\n        {\n          initialIndentLevel,\n          indentLevel\n        }\n      );\n    case textName:\n      return node.value;\n    case attributeName:\n      return generateProperty({\n        name: node.name,\n        isBoolean: node.isBoolean,\n        isString: node.isString,\n        value: node.value,\n        valuePath: node.valuePath,\n        isRequired: node.isRequired,\n        scope\n      });\n    case interpolationEscapedName:\n      return generateInterpolation('escaped', node.valuePath, scope);\n    case interpolationUnescapedName:\n      return generateInterpolation('unescaped', node.valuePath, scope);\n    case conditionName:\n      return indent(\n        generateCondition(\n          node.testPath,\n          codeGeneratorEjs(node.consequent, {\n            initialIndentLevel,\n            indentLevel: indentLevel + 1,\n            scope\n          }),\n          node.alternate &&\n            codeGeneratorEjs(node.alternate, {\n              initialIndentLevel,\n              indentLevel: indentLevel + 1,\n              scope\n            }),\n          scope\n        ),\n        {\n          initialIndentLevel,\n          indentLevel\n        }\n      );\n    case iterationName: {\n      const params = getIterationParams(node.currentValuePath, node.indexPath, node.arrayPath);\n      return indent(\n        generateIteration({\n          iterablePath: node.iterablePath,\n          params,\n          body: codeGeneratorEjs(node.body, {\n            initialIndentLevel,\n            indentLevel: indentLevel + 1,\n            scope: scope.concat(params)\n          }),\n          scope\n        }),\n        {\n          initialIndentLevel,\n          indentLevel\n        }\n      );\n    }\n    default:\n      throw new TypeError(node.type);\n  }\n}\n\nexport default codeGeneratorEjs;\n\nfunction generateTag(tagName, children, properties) {\n  const startTagBeginning = `<${tagName}${properties}`;\n  if (htmlTagsVoids.includes(tagName)) {\n    return `${startTagBeginning} />`;\n  }\n  const startTag = `${startTagBeginning}>`;\n  const endTag = `</${tagName}>`;\n  const tag = startTag + children + endTag;\n\n  return tag;\n}\n\nfunction generateProperty({ name, isBoolean, isString, value, valuePath, isRequired, scope }) {\n  const normalizedName = normalizePropertyName(name);\n  const startPropertyBeginning = ` ${normalizedName}`;\n\n  if (isBoolean) {\n    return startPropertyBeginning;\n  }\n\n  if (isString) {\n    return `${startPropertyBeginning}=\"${value}\"`;\n  }\n\n  makeReferenceSafe(valuePath, scope);\n  const generatedValue = babelGenerator(valuePath.node, { concise: true });\n  const resultString = resolvesToString(valuePath);\n  const propertyInterpolated = `${startPropertyBeginning}=\"${generateInterpolation(\n    'escaped',\n    valuePath,\n    scope\n  )}\"`;\n  if (!resultString && !isRequired) {\n    return `${generateScriptlet(\n      `if (![null,undefined].includes(${generatedValue.code})) {`\n    )}${propertyInterpolated}${generateScriptlet('}')}`;\n  }\n  return propertyInterpolated;\n}\n\nfunction generateCondition(testPath, consequent, alternate, scope) {\n  makeReferenceSafe(testPath, scope);\n  const generatedValue = babelGenerator(testPath.node, { concise: true });\n  const conditionArray = [\n    generateScriptlet(`if (${generatedValue.code}) {`),\n    consequent,\n    alternate ? generateScriptlet('} else {') : null,\n    alternate,\n    generateScriptlet('}')\n  ].filter(Boolean);\n  return conditionArray.join('');\n}\n\nfunction generateIteration({ iterablePath, params, body, scope }) {\n  const iterationScope = getIterationScope(iterablePath, scope);\n  makeReferenceSafe(iterablePath, iterationScope);\n  const addParenthesis = t.isLogicalExpression(iterablePath.node);\n  const iterableCode = babelGenerator(iterablePath.node, { concise: true }).code;\n  const paramsCode = params.join(', ');\n  const iterationArray = [\n    generateScriptlet(\n      `${addParenthesis ? `(${iterableCode})` : iterableCode}.forEach((${paramsCode}) => {`\n    ),\n    body,\n    generateScriptlet('})')\n  ].filter(Boolean);\n  return iterationArray.join('');\n}\n\nfunction getIterationParams(currentValuePath, indexPath, arrayPath) {\n  const currentValueCode = currentValuePath\n    ? babelGenerator(currentValuePath.node, { concise: true }).code\n    : null;\n  const indexCode = indexPath ? babelGenerator(indexPath.node, { concise: true }).code : null;\n  const arrayCode = arrayPath ? babelGenerator(arrayPath.node, { concise: true }).code : null;\n  const params = [currentValueCode, indexCode, arrayCode].filter(Boolean);\n  return params;\n}\n\nfunction getIterationScope(iterablePath, scope) {\n  const iterationScope = [];\n  iterablePath.traverse({\n    ArrowFunctionExpression(path) {\n      path.node.params.forEach(param => iterationScope.push(param.name));\n    }\n  });\n\n  return iterationScope.concat(scope);\n}\n\nfunction generateScriptlet(value) {\n  return `<% ${value} %>`;\n}\n\nfunction generateInterpolation(type, valuePath, scope) {\n  makeReferenceSafe(valuePath, scope);\n  const generatedValue = babelGenerator(valuePath.node, { concise: true });\n  if (type === 'unescaped') {\n    return `<%- ${generatedValue.code} %>`;\n  }\n  return `<%= ${generatedValue.code} %>`;\n}\n\nfunction makeReferenceSafe(path, scope) {\n  if (t.isIdentifier(path)) {\n    referenceSafeReplacement(scope, path);\n    return;\n  }\n\n  if (t.isMemberExpression(path)) {\n    const pathFirst = getFirstMemberExpression(path);\n    if (pathFirst.node.name === 'locals') {\n      return;\n    }\n    referenceSafeReplacement(scope, pathFirst);\n  }\n\n  path.traverse({\n    Identifier(path1) {\n      if (t.isMemberExpression(path1.parent) || t.isObjectProperty(path1.parent)) {\n        return;\n      }\n      referenceSafeReplacement(scope, path1);\n    },\n    MemberExpression(path1) {\n      if (t.isMemberExpression(path1.parent)) {\n        return;\n      }\n      const pathFirst = getFirstMemberExpression(path1);\n      if (!t.isIdentifier(pathFirst)) {\n        return;\n      }\n      if (pathFirst.node.name === 'locals') {\n        return;\n      }\n      referenceSafeReplacement(scope, pathFirst);\n    }\n  });\n}\n\nfunction referenceSafeReplacement(scope, path) {\n  const isFromScope = !!scope.find(scopeVar => scopeVar === path.node.name);\n  const isUndefined = path.node.name === 'undefined';\n  if (isFromScope || isUndefined) {\n    return;\n  }\n  path.replaceWith(t.memberExpression(t.identifier('locals'), path.node));\n}\n\nfunction indent(str, { initialIndentLevel, indentLevel }) {\n  const indentChar = ' ';\n  const indentLength = 2;\n  const startIndentNumber = indentLevel * indentLength;\n  const endIndentNumber = (indentLevel ? indentLevel - 1 : indentLevel) * indentLength;\n  const strIndented = `${indentLevel === initialIndentLevel ? '' : '\\n'}${indentChar.repeat(\n    startIndentNumber\n  )}${str}${'\\n'}${indentChar.repeat(endIndentNumber)}`;\n  return strIndented;\n}\n\nfunction resolvesToString(path) {\n  if (t.isTemplateLiteral(path.node)) {\n    return true;\n  }\n  if (\n    t.isConditionalExpression(path.node) &&\n    t.isStringLiteral(path.node.consequent) &&\n    t.isStringLiteral(path.node.alternate)\n  ) {\n    return true;\n  }\n  if (\n    t.isLogicalExpression(path.node) &&\n    path.node.operator === '||' &&\n    t.isStringLiteral(path.node.right)\n  ) {\n    return true;\n  }\n  if (t.isBinaryExpression(path.node) && path.node.operator === '+') {\n    const nodeLeft = path.node.left;\n    const nodeRight = path.node.right;\n    if (\n      t.isTaggedTemplateExpression(nodeLeft) ||\n      t.isStringLiteral(nodeLeft) ||\n      t.isTemplateLiteral(nodeLeft) ||\n      t.isTaggedTemplateExpression(nodeRight) ||\n      t.isStringLiteral(nodeRight) ||\n      t.isTemplateLiteral(nodeRight)\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n"]}