{"version":3,"sources":["../src/optimize.js"],"names":["optimize","ast","table","Element","exit","node","name","tagName","isRC","htmlTags","includes","tableRC","getTableComponent","propsToInline","props","map","prop","children","value","attributes","find","attr","componentNode","_","merge","Object","assign","inlinepProps","components","tableDep","dependencies","component","values","rc","createdFrom","path","defaultExport","Attribute","parent","identifiers","MagicString","propsToChange","filter","propsToNotChange","forEach","makeUndefined","propIDs","propValue","canMakeText","keys","length","start","end","propID","isText","expression","content","String","overwrite","toString","result","evaluate","remove","confident","undefined","InterpolationEscaped","position","findIndex","child","slice","type","textName","Iteration","propToInline","iterable","Condition","enter","test","evaluates","isTruthy","conditionName","alternate","consequent","Boolean","magicString","key","code","bodyChild","getBodyChild","evaluateTruthy","Program","body","get"],"mappings":"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","file":"optimize.js","sourcesContent":["/* eslint-disable no-param-reassign */\nimport htmlTags from 'html-tags';\nimport _ from 'lodash';\nimport MagicString from 'magic-string';\nimport babelTraverse from '@babel/traverse';\nimport traverser from './traverser';\nimport { conditionName, textName } from './ast';\nimport parse from './parser';\n\nfunction optimize(ast, table) {\n  traverser(ast, {\n    Element: {\n      exit(node) {\n        const name = node.tagName;\n        const isRC = !htmlTags.includes(name);\n        const tableRC = getTableComponent(name, table);\n        if (isRC && tableRC) {\n          // Generate collection of props name and value.\n          const propsToInline =\n            tableRC.node.props &&\n            tableRC.node.props.map(prop => {\n              if (prop === 'children' && node.children) {\n                return { name: prop, value: node.children };\n              }\n              return {\n                name: prop,\n                value: node.attributes.find(attr => attr.name === prop)\n              };\n            });\n          // Clone Mixin.\n          const componentNode = _.merge({}, tableRC.node);\n          // Convert Element in Mixin.\n          Object.assign(node, componentNode);\n          delete node.tagName;\n          delete node.attributes;\n          // Inline props.\n          if (propsToInline) {\n            inlinepProps(node, propsToInline);\n          }\n          // Check again if new Mixin has React Components.\n          optimize(node, table);\n        }\n      }\n    }\n  });\n  return ast;\n}\n\nexport default optimize;\n\nfunction getTableComponent(name, table) {\n  if (table.components[name]) {\n    return table.components[name];\n  }\n  const tableDep = table.dependencies[name];\n  if (tableDep) {\n    const component = Object.values(table.components).find(\n      rc => rc.createdFrom === tableDep.path && rc.defaultExport\n    );\n    return component;\n  }\n  return null;\n}\n\nfunction inlinepProps(ast, props) {\n  traverser(ast, {\n    Attribute: {\n      exit(node, parent) {\n        // 1. Inlining.\n        if (!node.identifiers) {\n          return;\n        }\n        const value = new MagicString(node.value);\n        const propsToChange = props.filter(prop => prop.value && node.identifiers[prop.name]);\n        const propsToNotChange = props.filter(prop => !prop.value && node.identifiers[prop.name]);\n        propsToNotChange.forEach(prop => makeUndefined(node, prop, value));\n        propsToChange.forEach(prop => {\n          const propIDs = node.identifiers[prop.name];\n          const propValue = prop.value.value;\n          const canMakeText =\n            Object.keys(node.identifiers).length === 1 &&\n            propIDs.length === 1 &&\n            propIDs[0].start === 0 &&\n            propIDs[0].end === node.value.length;\n          propIDs.forEach(propID => {\n            const isText = prop.value.expression === false;\n            const content = !canMakeText && isText ? `'${String(propValue)}'` : String(propValue);\n            value.overwrite(propID.start, propID.end, content);\n            if (canMakeText && isText) {\n              // Make attr text;\n              node.expression = false;\n            }\n          });\n        });\n        node.value = value.toString();\n        // 2. Dead code elimination.\n        if (node.value === 'undefined') {\n          parent.attributes = parent.attributes.filter(attr => attr !== node);\n          return;\n        }\n        if (node.expression) {\n          const result = evaluate(node.value);\n          const remove = result.confident && [null, undefined].includes(result.value);\n          if (remove) {\n            parent.attributes = parent.attributes.filter(attr => attr !== node);\n            return;\n          }\n          if (result.confident) {\n            node.value = result.value;\n            node.expression = false;\n          }\n        }\n      }\n    },\n    InterpolationEscaped: {\n      exit(node, parent) {\n        // 1. Inlining.\n        const value = new MagicString(node.value);\n        const propsToChange = props.filter(prop => prop.value && node.identifiers[prop.name]);\n        const propsToNotChange = props.filter(prop => !prop.value && node.identifiers[prop.name]);\n        propsToNotChange.forEach(prop => makeUndefined(node, prop, value));\n        propsToChange.forEach(prop => {\n          if (prop.name === 'children') {\n            const position = parent.children.findIndex(child => child.value === 'children');\n            parent.children = [\n              ...parent.children.slice(0, position),\n              ...prop.value,\n              ...parent.children.slice(position + 1)\n            ];\n            return;\n          }\n          const propIDs = node.identifiers[prop.name];\n          const propValue = prop.value.value;\n          const canMakeText =\n            Object.keys(node.identifiers).length === 1 &&\n            propIDs.length === 1 &&\n            propIDs[0].start === 0 &&\n            propIDs[0].end === node.value.length;\n          propIDs.forEach(propID => {\n            const isText = prop.value.expression === false;\n            const content = !canMakeText && isText ? `'${String(propValue)}'` : String(propValue);\n            value.overwrite(propID.start, propID.end, content);\n            if (canMakeText && isText) {\n              // Convert to Text.\n              node.type = textName;\n              delete node.identifiers;\n            }\n          });\n          node.value = value.toString();\n        });\n        // 2. Dead code elimination.\n        if (node.value === 'undefined') {\n          // HACK: to \"remove\" InterpolationEscaped.\n          node.value = '';\n          node.type = textName;\n        }\n      }\n    },\n    Iteration: {\n      exit(node) {\n        const propToInline = props.find(prop => prop.name === node.iterable);\n        if (propToInline && propToInline.value && propToInline.value.expression) {\n          node.iterable = propToInline.value.value;\n        }\n      }\n    },\n    Condition: {\n      enter(node, parent) {\n        // 1. Inlining.\n        const test = new MagicString(node.test);\n        const propsToChange = props.filter(prop => prop.value && node.identifiers[prop.name]);\n        const propsToNotChange = props.filter(prop => !prop.value && node.identifiers[prop.name]);\n        propsToNotChange.forEach(prop => makeUndefined(node, prop, test, 'test'));\n        propsToChange.forEach(prop => {\n          const propIDs = node.identifiers[prop.name];\n          const propValue = prop.value.value;\n          if (prop.value.expression === false) {\n            node.test = `\"${propValue}\"`;\n            return;\n          }\n          propIDs.forEach(propID => {\n            test.overwrite(propID.start, propID.end, String(propValue));\n          });\n          node.test = test.toString();\n        });\n        // 2. Dead code elimination.\n        const evaluates = isTruthy(node.test);\n        if (evaluates === false) {\n          if (parent.type === conditionName) {\n            delete parent.type;\n            delete parent.test;\n            delete parent.alternate;\n            delete parent.consequent;\n            delete parent.identifiers;\n            Object.assign(parent, node.alternate);\n            return;\n          }\n          parent.children = parent.children\n            .map(child => {\n              if (child === node) {\n                return node.alternate;\n              }\n              return child;\n            })\n            .filter(Boolean);\n          return;\n        }\n        if (evaluates === true) {\n          parent.children = parent.children\n            .map(child => {\n              if (child === node) {\n                return node.consequent;\n              }\n              return child;\n            })\n            .filter(Boolean);\n        }\n      }\n    }\n  });\n}\n\n// function makeReferenceSafe(node, prop, magicString, key = 'value') {\n//   const propIDs = node.identifiers[prop.name];\n//   propIDs.forEach(propID => {\n//     const contentVar = magicString.slice(propID.start, propID.end);\n//     const content = `(typeof ${contentVar} === 'undefined' ? undefined : ${contentVar})`;\n//     magicString.overwrite(propID.start, propID.end, content);\n//   });\n//   node[key] = magicString.toString();\n// }\n\nfunction makeUndefined(node, prop, magicString, key = 'value') {\n  const propIDs = node.identifiers[prop.name];\n  propIDs.forEach(propID => {\n    const content = 'undefined';\n    magicString.overwrite(propID.start, propID.end, content);\n  });\n  node[key] = magicString.toString();\n}\n\nfunction isTruthy(code) {\n  const bodyChild = getBodyChild(code);\n  if (!bodyChild) {\n    return null;\n  }\n  const evaluates = bodyChild.evaluateTruthy();\n  return evaluates;\n}\n\nfunction evaluate(code) {\n  const bodyChild = getBodyChild(code);\n  if (!bodyChild) {\n    return null;\n  }\n  const evaluates = bodyChild.evaluate();\n  return evaluates;\n}\n\nfunction getBodyChild(code) {\n  let bodyChild = null;\n  babelTraverse(\n    parse(`(${code})`),\n    {\n      Program(path) {\n        const body = path.get('body');\n        if (!body) {\n          return;\n        }\n        bodyChild = body[0];\n      }\n    },\n    null\n  );\n  return bodyChild;\n}\n"]}