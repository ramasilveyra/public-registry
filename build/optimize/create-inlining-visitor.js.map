{"version":3,"sources":["../../src/optimize/create-inlining-visitor.js"],"names":["t","createInliningVisitor","props","Attribute","exit","node","parent","inlineNodeVisitor","InterpolationEscaped","Iteration","Condition","enter","key","clonePath","isIdentifier","isMemberExpression","inline","traverse","Identifier","path","iteration","findParent","type","iterationName","matchedProp","find","prop","name","currentValuePath","value","isBoolean","replaceWith","BooleanLiteral","isString","stringLiteral","position","children","findIndex","child","valuePath","slice","matchedPropNode","condition","target","_parent","code","ast","newPath","Program","get","isExpressionStatement"],"mappings":"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","file":"create-inlining-visitor.js","sourcesContent":["/* eslint-disable no-param-reassign, no-underscore-dangle */\nimport * as t from '@babel/types';\nimport babelTraverse from '@babel/traverse';\nimport babelGenerator from '@babel/generator';\nimport { iterationName } from '../ast';\nimport parser from '../parser';\n\nfunction createInliningVisitor(props) {\n  return {\n    Attribute: {\n      exit(node, parent) {\n        inlineNodeVisitor(node, parent, props, 'valuePath');\n      }\n    },\n    InterpolationEscaped: {\n      exit(node, parent) {\n        inlineNodeVisitor(node, parent, props, 'valuePath');\n      }\n    },\n    Iteration: {\n      exit(node, parent) {\n        inlineNodeVisitor(node, parent, props, 'iterablePath');\n      }\n    },\n    Condition: {\n      enter(node, parent) {\n        inlineNodeVisitor(node, parent, props, 'testPath');\n      }\n    }\n  };\n}\n\nexport default createInliningVisitor;\n\nfunction inlineNodeVisitor(node, parent, props, key) {\n  if (!node[key]) {\n    return;\n  }\n  node[key] = clonePath(node[key].node);\n  if (t.isIdentifier(node[key].node) && !t.isMemberExpression(node[key].parent)) {\n    inline(props, node[key], parent);\n    return;\n  }\n  node[key].traverse({\n    Identifier(path) {\n      if (t.isMemberExpression(path.parent)) {\n        return;\n      }\n      inline(props, path, parent);\n    }\n  });\n}\n\nfunction inline(props, path, parent) {\n  const iteration = findParent(parent, node => node.type === iterationName);\n  const matchedProp = props.find(prop => prop.name === path.node.name);\n  if (iteration && iteration.currentValuePath.node.name === path.node.name) {\n    return;\n  }\n  if (!matchedProp || !matchedProp.value) {\n    path.node.name = 'undefined';\n    return;\n  }\n  if (matchedProp.value.isBoolean) {\n    path.replaceWith(t.BooleanLiteral(true));\n    return;\n  }\n  if (matchedProp.value.isString) {\n    path.replaceWith(t.stringLiteral(matchedProp.value.value));\n    return;\n  }\n  if (matchedProp.name === 'children') {\n    const position = parent.children.findIndex(child => {\n      if (child.valuePath) {\n        return t.isIdentifier(child.valuePath.node, { name: 'children' });\n      }\n      return false;\n    });\n    parent.children = [\n      ...parent.children.slice(0, position),\n      ...matchedProp.value,\n      ...parent.children.slice(position + 1)\n    ];\n    return;\n  }\n  const matchedPropNode = matchedProp.value.valuePath.node;\n  if (t.isIdentifier(matchedPropNode)) {\n    path.node.name = matchedPropNode.name;\n    return;\n  }\n  path.replaceWith(matchedPropNode);\n}\n\nfunction findParent(node, condition) {\n  let target = node;\n  while (target._parent) {\n    if (condition(target)) {\n      return target;\n    }\n    target = target._parent;\n  }\n  return null;\n}\n\nfunction clonePath(node) {\n  const code = babelGenerator(node).code;\n  const ast = parser(code);\n  let newPath = null;\n  babelTraverse(\n    ast,\n    {\n      Program(path) {\n        newPath = path.get('body.0');\n        if (t.isExpressionStatement(newPath.node)) {\n          newPath = newPath.get('expression');\n        }\n      }\n    },\n    null\n  );\n  return newPath;\n}\n"]}