{"version":3,"sources":["../../src/optimize/dead-code-elimination-visitor.js"],"names":["t","deadCodeElimination","Attribute","exit","node","parent","isBoolean","isString","isIdentifier","valuePath","name","attributes","filter","attr","result","confident","includes","value","isTemplateLiteral","constantFoldingTemplateLiteral","InterpolationEscaped","type","textName","isStringLiteral","Condition","enter","pNode","testPath","isLogicalExpressionAnd","isLogicalExpression","operator","hasStringRight","left","right","hasStringLeft","replaceWith","identifier","evaluates","conditionName","alternate","consequent","_parent","Object","assign","children","map","child","Boolean","path","traverse","ConditionalExpression","nodePath","evaluate","nodeStart","start","nodeIndex","expressions","findIndex","expr","quasis","q","placeholdersStart","end","cooked","raw","remove","quasiExtra","parentPath","get","quasiExtraValue","quasiBefore"],"mappings":"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","file":"dead-code-elimination-visitor.js","sourcesContent":["/* eslint-disable no-param-reassign, no-underscore-dangle */\nimport * as t from '@babel/types';\nimport evaluate from './evaluate';\nimport isTruthy from './is-truthy';\nimport { conditionName, textName } from '../ast';\n\nconst deadCodeElimination = {\n  Attribute: {\n    exit(node, parent) {\n      if (node.isBoolean || node.isString) {\n        return;\n      }\n      if (t.isIdentifier(node.valuePath.node) && node.valuePath.node.name === 'undefined') {\n        parent.attributes = parent.attributes.filter(attr => attr !== node);\n        return;\n      }\n      const result = evaluate(node.valuePath);\n      if (result.confident && ['string', 'number'].includes(typeof result.value)) {\n        node.value = result.value;\n        node.isString = true;\n      } else if (t.isTemplateLiteral(node.valuePath.node)) {\n        constantFoldingTemplateLiteral(node.valuePath);\n      }\n    }\n  },\n  InterpolationEscaped: {\n    exit(node) {\n      if (t.isIdentifier(node.valuePath.node, { name: 'undefined' })) {\n        // HACK: to \"remove\" InterpolationEscaped.\n        node.valuePath = null;\n        node.type = textName;\n        return;\n      }\n\n      if (t.isStringLiteral(node.valuePath.node)) {\n        node.type = textName;\n        node.value = node.valuePath.node.value;\n        delete node.valuePath;\n      }\n    }\n  },\n  Condition: {\n    enter(node, parent) {\n      const pNode = node.testPath.node;\n      const isLogicalExpressionAnd = t.isLogicalExpression(pNode, { operator: '&&' });\n      const hasStringRight =\n        isLogicalExpressionAnd && t.isIdentifier(pNode.left) && t.isStringLiteral(pNode.right);\n      const hasStringLeft =\n        isLogicalExpressionAnd && t.isStringLiteral(pNode.left) && t.isIdentifier(pNode.right);\n      if (hasStringRight) {\n        node.testPath.replaceWith(t.identifier(pNode.left.name));\n      }\n      if (hasStringLeft) {\n        node.testPath.replaceWith(t.identifier(pNode.right.name));\n      }\n      const evaluates = isTruthy(node.testPath);\n      if (evaluates === false) {\n        if (parent.type === conditionName) {\n          delete parent.type;\n          delete parent.testPath;\n          delete parent.alternate;\n          delete parent.consequent;\n          delete parent._parent;\n          delete node._parent;\n          Object.assign(parent, node.alternate);\n          return;\n        }\n        parent.children = parent.children\n          .map(child => {\n            if (child === node) {\n              return node.alternate;\n            }\n            return child;\n          })\n          .filter(Boolean);\n        return;\n      }\n      if (evaluates === true) {\n        parent.children = parent.children\n          .map(child => {\n            if (child === node) {\n              return node.consequent;\n            }\n            return child;\n          })\n          .filter(Boolean);\n      }\n    }\n  }\n};\n\nexport default deadCodeElimination;\n\nfunction constantFoldingTemplateLiteral(path) {\n  path.traverse({\n    ConditionalExpression(nodePath) {\n      const result = nodePath.evaluate();\n      if (result.confident && typeof result.value === 'string') {\n        const nodeStart = nodePath.node.start;\n        const nodeIndex = nodePath.parent.expressions.findIndex(expr => expr === nodePath.node);\n        nodePath.parent.quasis = nodePath.parent.quasis.map(q => {\n          const placeholdersStart = 2; // placeholders start symbols length \"${\".\n          if (q.end === nodeStart - placeholdersStart) {\n            q.value.cooked += result.value;\n            q.value.raw += result.value;\n          }\n          return q;\n        });\n        nodePath.remove();\n        const quasiExtra = nodePath.parentPath.get(`quasis.${nodeIndex + 1}`);\n        const quasiExtraValue = quasiExtra.node.value.cooked;\n        quasiExtra.remove();\n        const quasiBefore = nodePath.parentPath.get(`quasis.${nodeIndex}`);\n        quasiBefore.node.value.cooked += quasiExtraValue;\n        quasiBefore.node.value.raw += quasiExtraValue;\n      }\n    }\n  });\n}\n"]}