{"version":3,"sources":["../../src/optimize/dead-code-elimination-visitor.js"],"names":["t","deadCodeElimination","Attribute","exit","node","parent","isBoolean","isString","isNode","isBooleanLiteral","valuePath","value","isIdentifier","name","attributes","filter","attr","result","confident","includes","undefined","isTemplateLiteral","constantFoldingTemplateLiteral","InterpolationEscaped","type","textName","isStringLiteral","Condition","enter","pNode","testPath","isJSXElement","inlineTruthyCondition","isLogicalExpressionAnd","isLogicalExpression","operator","hasStringRight","left","right","hasStringLeft","replaceWith","identifier","evaluates","conditionName","alternate","consequent","_parent","Object","assign","children","map","child","Boolean","path","traverse","ConditionalExpression","nodePath","evaluate","nodeStart","start","nodeIndex","expressions","findIndex","expr","quasis","q","placeholdersStart","end","cooked","raw","remove","quasiExtra","parentPath","get","quasiExtraValue","quasiBefore"],"mappings":"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","file":"dead-code-elimination-visitor.js","sourcesContent":["/* eslint-disable no-param-reassign, no-underscore-dangle */\nimport * as t from '@babel/types';\nimport evaluate from './evaluate';\nimport isTruthy from './is-truthy';\nimport { conditionName, textName } from '../ast';\n\nconst deadCodeElimination = {\n  Attribute: {\n    exit(node, parent) {\n      if (node.isBoolean || node.isString || node.isNode) {\n        return;\n      }\n      if (t.isBooleanLiteral(node.valuePath.node, { value: true })) {\n        node.isBoolean = true;\n        return;\n      }\n      if (t.isIdentifier(node.valuePath.node) && node.valuePath.node.name === 'undefined') {\n        parent.attributes = parent.attributes.filter(attr => attr !== node);\n        return;\n      }\n      const result = evaluate(node.valuePath);\n      if (result.confident && ['string', 'number'].includes(typeof result.value)) {\n        node.value = result.value;\n        node.isString = true;\n        node.valuePath = undefined;\n      } else if (result.confident && [null, false].includes(result.value)) {\n        parent.attributes = parent.attributes.filter(attr => attr !== node);\n      } else if (result.confident && typeof result.value === 'boolean') {\n        node.value = result.value;\n        node.isBoolean = true;\n      } else if (t.isTemplateLiteral(node.valuePath.node)) {\n        constantFoldingTemplateLiteral(node.valuePath);\n      }\n    }\n  },\n  InterpolationEscaped: {\n    exit(node) {\n      if (t.isIdentifier(node.valuePath.node, { name: 'undefined' })) {\n        // HACK: to \"remove\" InterpolationEscaped.\n        node.valuePath = null;\n        node.type = textName;\n        return;\n      }\n\n      if (t.isStringLiteral(node.valuePath.node)) {\n        node.type = textName;\n        node.value = node.valuePath.node.value;\n        delete node.valuePath;\n      }\n    }\n  },\n  Condition: {\n    enter(node, parent) {\n      const pNode = node.testPath.node;\n      if (t.isJSXElement(pNode)) {\n        inlineTruthyCondition(parent, node);\n        return;\n      }\n      const isLogicalExpressionAnd = t.isLogicalExpression(pNode, { operator: '&&' });\n      const hasStringRight =\n        isLogicalExpressionAnd && t.isIdentifier(pNode.left) && t.isStringLiteral(pNode.right);\n      const hasStringLeft =\n        isLogicalExpressionAnd && t.isStringLiteral(pNode.left) && t.isIdentifier(pNode.right);\n      if (hasStringRight) {\n        node.testPath.replaceWith(t.identifier(pNode.left.name));\n      }\n      if (hasStringLeft) {\n        node.testPath.replaceWith(t.identifier(pNode.right.name));\n      }\n      const evaluates = isTruthy(node.testPath);\n      if (evaluates === false) {\n        if (parent.type === conditionName) {\n          delete parent.type;\n          delete parent.testPath;\n          delete parent.alternate;\n          delete parent.consequent;\n          delete parent._parent;\n          delete node._parent;\n          Object.assign(parent, node.alternate);\n          return;\n        }\n        parent.children = parent.children\n          .map(child => {\n            if (child === node) {\n              return node.alternate;\n            }\n            return child;\n          })\n          .filter(Boolean);\n        return;\n      }\n      if (evaluates === true) {\n        inlineTruthyCondition(parent, node);\n      }\n    }\n  }\n};\n\nexport default deadCodeElimination;\n\nfunction inlineTruthyCondition(parent, node) {\n  if (parent.type === conditionName) {\n    delete parent.type;\n    delete parent.testPath;\n    delete parent.alternate;\n    delete parent.consequent;\n    delete parent._parent;\n    delete node._parent;\n    Object.assign(parent, node.consequent);\n    return;\n  }\n  parent.children = parent.children\n    .map(child => {\n      if (child === node) {\n        return node.consequent;\n      }\n      return child;\n    })\n    .filter(Boolean);\n}\n\nfunction constantFoldingTemplateLiteral(path) {\n  path.traverse({\n    ConditionalExpression(nodePath) {\n      const result = nodePath.evaluate();\n      if (result.confident && typeof result.value === 'string') {\n        const nodeStart = nodePath.node.start;\n        const nodeIndex = nodePath.parent.expressions.findIndex(expr => expr === nodePath.node);\n        nodePath.parent.quasis = nodePath.parent.quasis.map(q => {\n          const placeholdersStart = 2; // placeholders start symbols length \"${\".\n          if (q.end === nodeStart - placeholdersStart) {\n            q.value.cooked += result.value;\n            q.value.raw += result.value;\n          }\n          return q;\n        });\n        nodePath.remove();\n        const quasiExtra = nodePath.parentPath.get(`quasis.${nodeIndex + 1}`);\n        const quasiExtraValue = quasiExtra.node.value.cooked;\n        quasiExtra.remove();\n        const quasiBefore = nodePath.parentPath.get(`quasis.${nodeIndex}`);\n        quasiBefore.node.value.cooked += quasiExtraValue;\n        quasiBefore.node.value.raw += quasiExtraValue;\n      }\n    }\n  });\n}\n"]}