{"version":3,"sources":["../../src/optimize/dead-code-elimination-visitor.js"],"names":["t","deadCodeElimination","Attribute","exit","node","parent","isBoolean","isString","isBooleanLiteral","valuePath","value","isIdentifier","name","attributes","filter","attr","result","confident","includes","isTemplateLiteral","constantFoldingTemplateLiteral","InterpolationEscaped","type","textName","isStringLiteral","Condition","enter","pNode","testPath","isLogicalExpressionAnd","isLogicalExpression","operator","hasStringRight","left","right","hasStringLeft","replaceWith","identifier","evaluates","conditionName","alternate","consequent","_parent","Object","assign","children","map","child","Boolean","path","traverse","ConditionalExpression","nodePath","evaluate","nodeStart","start","nodeIndex","expressions","findIndex","expr","quasis","q","placeholdersStart","end","cooked","raw","remove","quasiExtra","parentPath","get","quasiExtraValue","quasiBefore"],"mappings":"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","file":"dead-code-elimination-visitor.js","sourcesContent":["/* eslint-disable no-param-reassign, no-underscore-dangle */\nimport * as t from '@babel/types';\nimport evaluate from './evaluate';\nimport isTruthy from './is-truthy';\nimport { conditionName, textName } from '../ast';\n\nconst deadCodeElimination = {\n  Attribute: {\n    exit(node, parent) {\n      if (node.isBoolean || node.isString) {\n        return;\n      }\n      if (t.isBooleanLiteral(node.valuePath.node, { value: true })) {\n        node.isBoolean = true;\n        return;\n      }\n      if (t.isIdentifier(node.valuePath.node) && node.valuePath.node.name === 'undefined') {\n        parent.attributes = parent.attributes.filter(attr => attr !== node);\n        return;\n      }\n      const result = evaluate(node.valuePath);\n      if (result.confident && ['string', 'number'].includes(typeof result.value)) {\n        node.value = result.value;\n        node.isString = true;\n      } else if (result.confident && [null, false].includes(result.value)) {\n        parent.attributes = parent.attributes.filter(attr => attr !== node);\n      } else if (result.confident && typeof result.value === 'boolean') {\n        node.value = result.value;\n        node.isBoolean = true;\n      } else if (t.isTemplateLiteral(node.valuePath.node)) {\n        constantFoldingTemplateLiteral(node.valuePath);\n      }\n    }\n  },\n  InterpolationEscaped: {\n    exit(node) {\n      if (t.isIdentifier(node.valuePath.node, { name: 'undefined' })) {\n        // HACK: to \"remove\" InterpolationEscaped.\n        node.valuePath = null;\n        node.type = textName;\n        return;\n      }\n\n      if (t.isStringLiteral(node.valuePath.node)) {\n        node.type = textName;\n        node.value = node.valuePath.node.value;\n        delete node.valuePath;\n      }\n    }\n  },\n  Condition: {\n    enter(node, parent) {\n      const pNode = node.testPath.node;\n      const isLogicalExpressionAnd = t.isLogicalExpression(pNode, { operator: '&&' });\n      const hasStringRight =\n        isLogicalExpressionAnd && t.isIdentifier(pNode.left) && t.isStringLiteral(pNode.right);\n      const hasStringLeft =\n        isLogicalExpressionAnd && t.isStringLiteral(pNode.left) && t.isIdentifier(pNode.right);\n      if (hasStringRight) {\n        node.testPath.replaceWith(t.identifier(pNode.left.name));\n      }\n      if (hasStringLeft) {\n        node.testPath.replaceWith(t.identifier(pNode.right.name));\n      }\n      const evaluates = isTruthy(node.testPath);\n      if (evaluates === false) {\n        if (parent.type === conditionName) {\n          delete parent.type;\n          delete parent.testPath;\n          delete parent.alternate;\n          delete parent.consequent;\n          delete parent._parent;\n          delete node._parent;\n          Object.assign(parent, node.alternate);\n          return;\n        }\n        parent.children = parent.children\n          .map(child => {\n            if (child === node) {\n              return node.alternate;\n            }\n            return child;\n          })\n          .filter(Boolean);\n        return;\n      }\n      if (evaluates === true) {\n        parent.children = parent.children\n          .map(child => {\n            if (child === node) {\n              return node.consequent;\n            }\n            return child;\n          })\n          .filter(Boolean);\n      }\n    }\n  }\n};\n\nexport default deadCodeElimination;\n\nfunction constantFoldingTemplateLiteral(path) {\n  path.traverse({\n    ConditionalExpression(nodePath) {\n      const result = nodePath.evaluate();\n      if (result.confident && typeof result.value === 'string') {\n        const nodeStart = nodePath.node.start;\n        const nodeIndex = nodePath.parent.expressions.findIndex(expr => expr === nodePath.node);\n        nodePath.parent.quasis = nodePath.parent.quasis.map(q => {\n          const placeholdersStart = 2; // placeholders start symbols length \"${\".\n          if (q.end === nodeStart - placeholdersStart) {\n            q.value.cooked += result.value;\n            q.value.raw += result.value;\n          }\n          return q;\n        });\n        nodePath.remove();\n        const quasiExtra = nodePath.parentPath.get(`quasis.${nodeIndex + 1}`);\n        const quasiExtraValue = quasiExtra.node.value.cooked;\n        quasiExtra.remove();\n        const quasiBefore = nodePath.parentPath.get(`quasis.${nodeIndex}`);\n        quasiBefore.node.value.cooked += quasiExtraValue;\n        quasiBefore.node.value.raw += quasiExtraValue;\n      }\n    }\n  });\n}\n"]}